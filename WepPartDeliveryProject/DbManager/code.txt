GraphHealthCheck.cs
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Neo4jClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager
{
    public class GraphHealthCheck : IHealthCheck
    {

        private readonly IGraphClient _client;
        public GraphHealthCheck(IGraphClient client)
        {
            _client = client;
        }

        public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
        {

            var healthCheckResultHealthy = await CheckNeo4jGraphConnectionAsync();


            if (healthCheckResultHealthy)
            {
                return HealthCheckResult.Healthy("neo4j graph db health check success");
            }

            return HealthCheckResult.Unhealthy("neo4j graph db health check success"); ;
        }

        private async Task<bool> CheckNeo4jGraphConnectionAsync()
        {
            try
            {
                await _client.ConnectAsync();
            }

            catch (Exception)
            {
                return false;
            }

            return true;
        }
    }
}

Neo4jSettings.cs
namespace DbManager
{
    public class Neo4jSettings
    {
        public Uri Neo4jConnection { get; set; }

        public string Neo4jUser { get; set; }

        public string Neo4jPassword { get; set; }

        public string Neo4jDatabase { get; set; }
    }
}

ServiceRegistration.cs
using DbManager.Neo4j.Implementations;
using DbManager.Neo4j.Interfaces;
using Microsoft.Extensions.DependencyInjection;
using Neo4jClient;
using DbManager.Data.Nodes;
using DbManager.Services;
using DbManager.Neo4j.DataGenerator;
using Microsoft.Extensions.Configuration;
using DbManager.Data.Relations;
using DbManager.Data;

namespace DbManager
{
    public static class ServiceRegistration
    {
        public static void AddDbInfrastructure(this IServiceCollection services, IConfiguration configuration)
        {
            // Fetch settings object from configuration
            var settings = new Neo4jSettings();
            configuration.GetSection("Neo4jSettings").Bind(settings);

            // This is to register Neo4j Client Object as a singleton
            services.AddSingleton<IGraphClient, BoltGraphClient>(op => {
                        var graphClient = new BoltGraphClient(settings.Neo4jConnection, settings.Neo4jUser, settings.Neo4jPassword);
                        graphClient.ConnectAsync().Wait();
                        if(Convert.ToBoolean(configuration.GetSection("ApplicationSettings:GenerateData").Value) == false)
                            PrepareData(graphClient, configuration.GetSection("ClientAppSettings:PathToPublicSourceDirecroty").Value, configuration.GetSection("ClientAppSettings:DirectoryWithDishImages").Value);
                        return graphClient;
                    });

            services.AddSingleton<IRepositoryFactory, RepositoryFactory>();

            services.AddTransient<IPasswordService, PasswordService>();

            services.AddTransient<DataGenerator>();
            services.AddSingleton<GeneratorService>();

            // This is the registration for custom repository class
            services.AddTransient<IGeneralRepository<Order>, OrderRepository>();
            services.AddTransient<IGeneralRepository<Dish>, DishRepository>();
            services.AddTransient<IGeneralRepository<User>, UserRepository>();
            services.AddTransient<IGeneralRepository<Client>, ClientRepository>();
            services.AddTransient<IGeneralRepository<DeliveryMan>, DeliveryManRepository>();
        }

        private static void PrepareData(IGraphClient graphClient, string pathToPublicClientAppDirectory, string dirWithDishImages)
        {
            var categoryRepo = new GeneralRepository<Category>(graphClient);
            var dishRepo = new GeneralRepository<Dish>(graphClient);

            OrderState.OrderStatesFromDb = new GeneralRepository<OrderState>(graphClient).GetNodesAsync().Result;

            Category.CategoriesFromDb = categoryRepo.GetNodesAsync().Result;

            foreach (var category in Category.CategoriesFromDb)
            {
                var categoryDishes = categoryRepo.GetRelationsOfNodesAsync<ContainsDish, Dish>(category).Result.Select(h=>(Dish)h.NodeTo);

                foreach (var dish in categoryDishes)
                {
                    var pathToDishDir = PathToDirWithDish(pathToPublicClientAppDirectory, dirWithDishImages, category.LinkName, dish.Id.ToString());
                    if (Directory.Exists(pathToDishDir))
                    {
                        dish.Images = Directory
                            .GetFiles(pathToDishDir)
                            //получаемый путь
                            // /dishes/{Название категории на англ}/{Guid}/{Название файла}
                            .Select(h => ConvertFromIOPathToInternetPath_DirWithDish(pathToPublicClientAppDirectory, h))
                            .ToList();

                        dishRepo.UpdateNodeAsync(dish).Wait();
                    }
                    else
                    {
                        Directory.CreateDirectory(pathToDishDir);
                    }
                }
            }
            
        }

        public static string PathToDirWithDish(string pathToPublicClientAppDirectory, string dirWithDishImages, string categoryLink, string dishId)
        {
            var pathToDishesDir = Path.Combine(pathToPublicClientAppDirectory, dirWithDishImages);
            var pathToCategoryDir = Path.Combine(pathToDishesDir, categoryLink);
            var pathToDishDir = Path.Combine(pathToCategoryDir, dishId);

            return pathToDishDir;
        }

        public static string ConvertFromIOPathToInternetPath_DirWithDish(string pathToPublicClientAppDirectory, string pathToImage)
        {
            pathToImage = pathToImage
                .Replace(pathToPublicClientAppDirectory, "")
                .Replace('\\', '/');

            return Path.Combine("/", pathToImage);
        }
    }
}

IModel.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data
{
    public interface IModel
    {
        public Guid Id { get; set; }
    }
}

INode.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data
{
    public interface INode : IModel
    {
    }
}

IRelation.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data
{
    public interface IRelation : IModel
    {
        INode NodeFrom { get; set; }
        INode NodeTo { get; set; }

        Guid? NodeFromId { get; set; }
        Guid? NodeToId { get; set; }
    }
}

Node.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data
{
    public abstract class Node : INode
    {
        public Guid Id { get; set; }
    }
}

OrderStateEnum.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data
{
    [Flags]
    public enum OrderStateEnum
    {
        InQueue = 1,
        Cooking = 2,
        WaitDeliveryMan = 4,
        Delivering = 8,
        Finished = 16,
        Cancelled = 32,
    }
}

Relation.cs
using Neo4jClient;
using Newtonsoft.Json;

namespace DbManager.Data
{
    public class Relation<TFrom, TTo> : IRelation where TFrom : class, INode where TTo : class, INode
    {
        public Guid Id { get; set; }

        private TFrom? _nodeFrom;
        private TTo? _nodeTo;

        [Neo4jIgnore]
        public INode NodeFrom
        {
            get => _nodeFrom;
            set
            {
                NodeFromId = value.Id;
                _nodeFrom = (TFrom)value;
            }
        }

        [Neo4jIgnore]
        public INode NodeTo
        {
            get => _nodeTo;
            set
            {
                NodeToId = value.Id;
                _nodeTo = (TTo)value;
            }
        }

        public Guid? NodeFromId { get; set; }
        public Guid? NodeToId { get; set; }

    }
}

User.cs
using Neo4jClient;

namespace DbManager.Data
{
    public class User : Node
    {
        public string Login { get; set; }
        public List<byte> PasswordHash { get; set; }
        public string PhoneNumber { get; set; }
        public string Address { get; set; }
        public string Name { get; set; }
        [Neo4jDateTime]
        public DateTime? Born { get; set; }
        public Guid RefreshToken { get; set; }
        [Neo4jDateTime]
        public DateTime RefreshTokenCreated { get; set; }
        public bool IsBlocked { get; set; }
    }
}

JwtTokenInfoOutDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class JwtTokenInfoOutDTO
    {
        public string JwtToken { get; set; }
        public DateTime ValidTo { get; set; }
        public List<string> RoleNames { get; set; }
    }
}

KitchenWorkerOutDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class KitchenWorkerOutDTO
    {
        public Guid Id { get; set; }
        public string Login { get; set; }
        public string PhoneNumber { get; set; }
        public string Name { get; set; }
        public DateTime? Born { get; set; }
        public bool IsBlocked { get; set; }
        public string? JobTitle { get; set; }

        public DateTime GotJob { get; set; }
    }
}

ManipulateDishDataInDTO.cs
using Microsoft.AspNetCore.Http;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class ManipulateDishDataInDTO
    {
        public Guid? Id { get; set; }
        public string? Name { get; set; }
        public string? Description { get; set; }
        public double? Price { get; set; }
        public int? Weight { get; set; }
        public bool? IsAvailableForUser { get; set; }
        public bool? IsDeleted { get; set; }

        public string? CategoryId { get; set; }
        public IFormFileCollection? ImagesFiles { get; set; }
    }
}

ManipulateOrderDataInDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class ManipulateOrderDataInDTO
    {
        public int? NewCount { get; set; }
        public string? OrderId { get; set; }
        public string? DishId { get; set; }
        public string? ReasonOfCancel { get; set; }
    }
}

ManipulateUserDataInDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class ManipulateUserDataInDTO
    {
        public string UserId { get; set; }
        public string? ChangeRole { get; set; }
    }
}

OrderOutDTO.cs
using DbManager.Data.Relations;
using Neo4jClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class OrderOutDTO
    {
        public Guid Id { get; set; }
        public double Price { get; set; }
        public int SumWeight { get; set; }
        public string DeliveryAddress { get; set; }
        public string PhoneNumber { get; set; }
        public string? Review { get; set; }
        public int? ClientRating { get; set; }

        public List<OrderStateItemOutDTO> Story { get; set; } = new List<OrderStateItemOutDTO>();
    }
}

OrderStateItemOutDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class OrderStateItemOutDTO
    {
        public DateTime? TimeStartState { get; set; }
        public string? Comment { get; set; }
        public Guid OrderStateId { get; set; }
        public int NumberOfStage { get; set; }
        public string NameOfState { get; set; }
        public string DescriptionForClient { get; set; }
    }
}

PlaceAnOrderInDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class PlaceAnOrderInDTO
    {
        public string DeliveryAddress { get; set; }
        public string PhoneNumber { get; set; }
        public string? Comment { get; set; }  
    }
}

ProfileUserOutDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class ProfileUserOutDTO
    {
        public string Login { get; set; }
        public string PhoneNumber { get; set; }
        public string Name { get; set; }
        public DateTime? Born { get; set; }

        // Client props
        public double? Bonuses { get; set; }

        //KitchenWorker props
        public string? JobTitle { get; set; }

        //Admin props

    }
}

ReviewOrderInDTO.cs
using Neo4jClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class ReviewOrderInDTO
    {
        public string? OrderId { get; set; }
        public int? ClientRating { get; set; }
        public string? Review { get; set; }
    }
}

StatisticQueryDataItemOutDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class StatisticQueryDataItemOutDTO
    {
        public string X { get; set; }
        public List<double> Y { get; set; }
    }
}

StatisticQueryInfoOutDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class StatisticQueryInfoOutDTO
    {
        public string NameQuery { get;set; }
        public string LinkToQuery { get;set; }
        public string ChartName { get;set; }
        public bool NeedDataRange { get;set; }
        public List<string>? NameDatasets { get; set; }
    }
}

UserForAdminOutDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class UserForAdminOutDTO
    {
        public Guid Id { get; set; }
        public string Login { get; set; }
        public string PhoneNumber { get; set; }
        public string Name { get; set; }
        public DateTime? Born { get; set; }
        public bool IsBlocked { get; set; }
        public string Address { get; set; }

        public string Roles { get; set; }
    }
}

UserLoginInDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class UserLoginInDTO
    {
        public string Login { get; set; }
        public string Password { get; set; }
    }
}

UserSignupInDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class UserSignupInDTO
    {
        public string Login { get; set; }
        public string Password { get; set; }
        public string? PhoneNumber { get; set; }
        public string? Address { get; set; }
        public string Name { get; set; }
        public DateTime? Born { get; set; }
    }
}

Admin.cs

namespace DbManager.Data.Nodes
{
    public class Admin: User, INode
    {
    }
}

Category.cs

using Neo4jClient;
using Newtonsoft.Json;

namespace DbManager.Data.Nodes
{
    public class Category : Node, INode
    {
        public string Name { get; set; }
        public string? Description { get; set; }
        public string LinkName { get; set; }
        public int CategoryNumber { get; set; }

        /// <summary>
        /// Categories loading from DB when app starts
        /// </summary>
        [JsonIgnore]
        [Neo4jIgnore]
        public static List<Category> CategoriesFromDb = new List<Category>();
    }
}

Client.cs
using DbManager.Data.Relations;
using Neo4jClient;

namespace DbManager.Data.Nodes
{
    public class Client : User, INode
    {
        public double Bonuses { get; set; }

        [Neo4jIgnore]
        public List<Ordered>? ClientOrders { get; set; }
    }
}

DeliveryMan.cs
using DbManager.Data.Relations;
using Neo4jClient;

namespace DbManager.Data.Nodes
{
    public class DeliveryMan : User, INode
    {
        public int MaxWeight { get; set; }

        [Neo4jIgnore]
        public List<DeliveredBy>? DeliveredOrders { get; set; }
    }
}

Dish.cs
using DbManager.Data.Relations;
using Neo4jClient;

namespace DbManager.Data.Nodes
{
    /// <summary>
    /// Продаваемое блюдо (напиток, товар)
    /// </summary>
    public class Dish : Node, INode
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public double Price { get; set; }
        public int Weight { get; set; }
        public bool IsAvailableForUser { get; set; }
        public bool IsDeleted { get; set; }
        /// <summary>
        /// Images of product. First image is main
        /// </summary>
        public List<string> Images { get; set; }

        [Neo4jIgnore]
        public List<OrderedDish>? Orders { get; set; }
    }
}

Kitchen.cs
using DbManager.Data.Relations;
using Neo4jClient;

namespace DbManager.Data.Nodes
{
    public class Kitchen : Node, INode
    {
        public string Address { get; set; }

        [Neo4jIgnore]
        public List<CookedBy>? PreparedOrders { get; set; }
    }
}

KitchenWorker.cs
using DbManager.Data.Relations;
using Neo4jClient;

namespace DbManager.Data.Nodes
{
    public class KitchenWorker : User, INode
    {
        public string JobTitle { get; set; }

        [Neo4jIgnore]
        public WorkedIn? Kitchen { get; set; }
    }
}

Order.cs
using DbManager.Data.Relations;
using Neo4jClient;
using Newtonsoft.Json;

namespace DbManager.Data.Nodes
{
    public class Order : Node, INode
    {
        public double Price { get; set; }
        public int SumWeight { get; set; }
        public string DeliveryAddress { get; set; }
        public string PhoneNumber { get; set; }

        [Neo4jIgnore]
        public List<HasOrderState> Story { get; set; } = new List<HasOrderState>();

        public string StoryJson
        {
            get
            {
                return JsonConvert.SerializeObject(Story, Formatting.Indented, new JsonSerializerSettings() { NullValueHandling = NullValueHandling.Ignore});
            }
            set
            {
                Story = JsonConvert.DeserializeObject<List<HasOrderState>>(value, new JsonSerializerSettings() { NullValueHandling = NullValueHandling.Ignore });
            }
        }

        [Neo4jIgnore]
        public List<OrderedDish>? OrderedObjects { get; set; }
        [Neo4jIgnore]
        public DeliveredBy? DeliveredMan { get; set; }
        [Neo4jIgnore]
        public Ordered Client { get; set; }
        [Neo4jIgnore]
        public CookedBy? Kitchen { get; set; }

    }
}

OrderState.cs
using Neo4jClient;
using Newtonsoft.Json;

namespace DbManager.Data.Nodes
{
    public class OrderState : Node, INode
    {
        public int NumberOfStage { get; set; }
        public string NameOfState { get; set; }
        public string DescriptionForClient { get; set; }

        /// <summary>
        /// Order states loading from DB when app starts
        /// </summary>
        [JsonIgnore]
        [Neo4jIgnore]
        public static List<OrderState> OrderStatesFromDb = new List<OrderState>();

        [Neo4jIgnore]
        public List<Order> Orders { get; set; } 
    }
}

ContainsDish.cs
using DbManager.Data.Nodes;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// Category -> Dish
    /// </summary>
    public class ContainsDish : Relation<Category, Dish>
    {

    }
}

CookedBy.cs
using DbManager.Data.Nodes;
using Neo4jClient;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// Kitchen -> Order
    /// </summary>
    public class CookedBy : Relation<Kitchen, Order>
    {
    }
}

DeliveredBy.cs
using DbManager.Data.Nodes;
using Neo4jClient;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// DeliveryMan -> Order
    /// </summary>
    public class DeliveredBy : Relation<DeliveryMan, Order>
    {

    }
}

HasOrderState.cs
using DbManager.Data.Nodes;
using Neo4jClient;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// Order -> OrderState
    /// </summary>
    public class HasOrderState : Relation<Order, OrderState>
    {
        [Neo4jDateTime]
        public DateTime TimeStartState { get; set; }
        public string? Comment { get; set; }

    }
}

Ordered.cs
using DbManager.Data.Nodes;
using Neo4jClient;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// Client -> Order
    /// </summary>
    public class Ordered : Relation<Client, Order>
    {

    }
}

OrderedDish.cs
using Neo4jClient;
using DbManager.Data.Nodes;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// Order -> Dish
    /// </summary>
    public class OrderedDish : Relation<Order, Dish>
    {
        public int Count { get; set; }
    }
}

ReviewedBy.cs
using DbManager.Data.Nodes;
using Neo4jClient;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// Client -> Order
    /// </summary>
    public class ReviewedBy : Relation<Client, Order>
    {
        public int? ClientRating { get; set; }
        [Neo4jDateTime]
        public DateTime TimeCreated { get; set; }
        public string? Review { get; set; }
    }
}

WorkedIn.cs
using DbManager.Data.Nodes;
using Neo4jClient;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// KitchenWorker -> Kitchen
    /// </summary>
    public class WorkedIn : Relation<KitchenWorker, Kitchen>
    {
        [Neo4jDateTime]
        public DateTime GotJob { get; set; }
    }
}

MapperProfile.cs
using DbManager.Data.Nodes;
using DbManager.Data;
using AutoMapper;
using DbManager.Data.DTOs;
using DbManager.Data.Relations;
using Neo4jClient.Extensions;

namespace DbManager.Mapper
{
    public class MapperProfile : Profile
    {
        public MapperProfile()
        {
            CreateMap<User, ProfileUserOutDTO>();
            CreateMap<Client, ProfileUserOutDTO>();
            CreateMap<Admin, ProfileUserOutDTO>();
            CreateMap<KitchenWorker, ProfileUserOutDTO>();

            CreateMap<User, UserForAdminOutDTO>();
            CreateMap<List<string>, UserForAdminOutDTO>()
                .ForMember(h => h.Roles, opt => opt.MapFrom(src => string.Join(", ", src)));

            CreateMap<KitchenWorker, KitchenWorkerOutDTO>();

            CreateMap<OrderState, OrderStateItemOutDTO>()
                .ForMember(h=>h.OrderStateId, (o) => o.MapFrom(src=>src.Id));

            CreateMap<HasOrderState, OrderStateItemOutDTO>()
                .BeforeMap((h,k) => h.NodeTo = OrderState.OrderStatesFromDb.FirstOrDefault(s=>s.Id == h.NodeToId))
                .ForMember(h => h.OrderStateId, (o) => o.MapFrom(src => src.NodeToId))
                .ForMember(h => h.NumberOfStage, (o) => o.MapFrom(src => ((OrderState)src.NodeTo).NumberOfStage))
                .ForMember(h => h.NameOfState, (o) => o.MapFrom(src => ((OrderState)src.NodeTo).NameOfState))
                .ForMember(h => h.DescriptionForClient, (o) => o.MapFrom(src => ((OrderState)src.NodeTo).DescriptionForClient));

            CreateMap<Order, OrderOutDTO>()
                .ForMember(dest => dest.Story, opt => opt.MapFrom(src => src.Story));

            CreateMap<ReviewedBy, OrderOutDTO>()
                .ForMember(h => h.Review, (o) => o.MapFrom(src => src.Review))
                .ForMember(h => h.ClientRating, (o) => o.MapFrom(src => src.ClientRating));

            CreateMap<Dish, ManipulateDishDataInDTO>();
            CreateMap<ManipulateDishDataInDTO, Dish>()
                .ForMember(h=>h.Id, o => o.Ignore());
        }
    }
}

Neo4jExtentions.cs
using DbManager.Data;
using Neo4jClient.Cypher;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j
{
    internal static class Neo4jExtentions
    {
        public static ICypherFluentQuery<TModel> ChangeQueryForPagination<TModel>(this ICypherFluentQuery<TModel> query, string[] orderByProperty, int? skipCount = null, int? limitCount = null) where TModel : IModel
        {
            if (orderByProperty != null && orderByProperty.Length != 0)
                query = query.OrderBy(orderByProperty);

            query = query
                .Skip(skipCount)
                .Limit(limitCount);

            return query;
        }

        public static ICypherFluentQuery<T> ChangeQueryForPaginationAnonymousType<T>(this ICypherFluentQuery<T> query, string[] orderByProperty, int? skipCount = null, int? limitCount = null) where T : class
        {
            if (orderByProperty != null && orderByProperty.Length != 0)
                query = query.OrderBy(orderByProperty);

            query = query
                .Skip(skipCount)
                .Limit(limitCount);

            return query;
        }
    }
}

BogusExtentions.cs
using Bogus;

namespace DbManager.Neo4j.DataGenerator
{
    internal static class BogusExtentions
    {
        /// <summary>
        /// Get a random list item and remove it from list.
        /// </summary>
        public static T ListItemWithRemove<T>(this Randomizer randomizer, List<T> list)
        {
            var item = randomizer.ListItem(list as IList<T>);
            list.Remove(item);
            return item;
        }
    }
}

DataGenerator.cs
using Bogus;
using DbManager.Data;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Services;
using Microsoft.Extensions.Configuration;

namespace DbManager.Neo4j.DataGenerator
{
    public class DataGenerator
    {
        private IPasswordService pswService { get; set; }
        private IConfiguration _configuration { get; set; }


        public DataGenerator(IPasswordService passwordService, IConfiguration configuration)
        {
            pswService = passwordService;
            _configuration = configuration;
        }

        public List<Admin> GenerateAdmins(int count)
            => ObjectGenerator.GenerateAdmin(pswService).Generate(count);

        public List<Client> GenerateClients(int count)
            => ObjectGenerator.GenerateClient(pswService).Generate(count);

        public List<DeliveryMan> GenerateDeliveryMen(int count)
            => ObjectGenerator.GenerateDeliveryMan(pswService).Generate(count);

        public List<KitchenWorker> GenerateKitchenWorkers(int count)
            => ObjectGenerator.GenerateKitchenWorker(pswService).Generate(count);
    
        public List<Dish> GenerateDishes(int count)
            => ObjectGenerator.GenerateDish().Generate(count);

        public List<Dish> GenerateDishes(int count, List<string> dishNames)
            => ObjectGenerator.GenerateDish(dishNames).Generate(count);

        public List<Order> GenerateOrders(int count)
            => ObjectGenerator.GenerateOrder().Generate(count);

        public List<Kitchen> GenerateKitchens(int count)
            => ObjectGenerator.GenerateKitchen().Generate(count);

        public List<Category> GenerateCategories(int count)
            => ObjectGenerator.GenerateCategory().Generate(count);

        public List<OrderState> GenerateOrderStates()
            => new List<OrderState> 
            {
                new OrderState() { Id = Guid.NewGuid(), NumberOfStage = (int)OrderStateEnum.InQueue, NameOfState = "В очереди заказов", DescriptionForClient = "Заказ был получен и в текущий момент находится в очереди заказов на кухне"},
                new OrderState() { Id = Guid.NewGuid(), NumberOfStage = (int)OrderStateEnum.Cooking, NameOfState = "Готовится", DescriptionForClient = "Блюда готовятся на кухне"},
                new OrderState() { Id = Guid.NewGuid(), NumberOfStage = (int)OrderStateEnum.WaitDeliveryMan, NameOfState = "В ожидании курьера", DescriptionForClient = "Заказ собран и ожидает когда его заберет курьер"},
                new OrderState() { Id = Guid.NewGuid(), NumberOfStage = (int)OrderStateEnum.Delivering, NameOfState = "Доставляется", DescriptionForClient = "Заказ находится у курьера, который его доставляет"},
                new OrderState() { Id = Guid.NewGuid(), NumberOfStage = (int)OrderStateEnum.Finished, NameOfState = "Завершен", DescriptionForClient = "Заказ был завершен"},
                new OrderState() { Id = Guid.NewGuid(), NumberOfStage = (int)OrderStateEnum.Cancelled, NameOfState = "Отменён", DescriptionForClient = "Заказ был отменен"},
            };

        public List<CookedBy> GenerateRelationsCookedBy(int count, List<Order> orders, List<Kitchen> kitchens)
            => ObjectGenerator.GenerateCookedBy(orders, kitchens).Generate(count);

        public List<ContainsDish> GenerateRelationsContainsDishWithNodes(int countDish, int countCategory, List<Category> categories, List<Dish> dishes)
        {
            var relations = new List<ContainsDish>();
            var mediumCountDishesInCategory = countDish / countCategory;
            var random = new Random();

            categories.AddRange(GenerateCategories(countCategory));

            for (int i = 0, j = 1; i < categories.Count; i++, j = (int)Math.Pow(2, i))
            {
                categories[i].CategoryNumber = j;
                var categoryDishNames = CategoryLinkWithDishNames[categories[i].LinkName];
                var categoryDishes = GenerateDishes(random.Next(2, mediumCountDishesInCategory + 2), categoryDishNames);
                dishes.AddRange(categoryDishes);

                var pathToPublicClientAppDirectory = _configuration.GetSection("ClientAppSettings:PathToPublicSourceDirecroty").Value;
                var dirWithDishImages = _configuration.GetSection("ClientAppSettings:DirectoryWithDishImages").Value;
                var dirWithImagesForGeneration = Path.Combine("ImagesForGeneration", categories[i].LinkName);
                var filesForGeneration = Directory.GetFiles(dirWithImagesForGeneration);

                for (int l = 0; l < filesForGeneration.Length; l++)
                {
                    var pathToDishDir = ServiceRegistration.PathToDirWithDish(  pathToPublicClientAppDirectory, 
                                                                                dirWithDishImages, 
                                                                                categories[i].LinkName, 
                                                                                categoryDishes[l % categoryDishes.Count].Id.ToString());
                    var imageName = filesForGeneration[l].Replace(dirWithImagesForGeneration+"\\", "");
                    var pathToDishFile = Path.Combine(pathToDishDir, imageName);

                    if (!Directory.Exists(pathToDishDir))
                        Directory.CreateDirectory(pathToDishDir);

                    File.Copy(filesForGeneration[l], pathToDishFile, false);

                    if (categoryDishes[l % categoryDishes.Count].Images == null)
                        categoryDishes[l % categoryDishes.Count].Images = new List<string>();

                    categoryDishes[l % categoryDishes.Count].Images.Add(ServiceRegistration.ConvertFromIOPathToInternetPath_DirWithDish(pathToPublicClientAppDirectory, pathToDishFile));
                }

                var categoryContainsDishRelation = ObjectGenerator.GenerateContainsDish(new List<Category>() { categories[i] }, categoryDishes)
                    .Generate(categoryDishes.Count);

                relations.AddRange(categoryContainsDishRelation);
            }

            return relations;
        }

        public List<DeliveredBy> GenerateRelationsDeliveredBy(int count, List<Order> orders, List<DeliveryMan> deliveryMen)
            => ObjectGenerator.GenerateDeliveredBy(orders, deliveryMen).Generate(count);

        public List<HasOrderState> GenerateRelationsHasOrderState(int count, List<Order> orders, List<OrderState> orderStates)
            => ObjectGenerator.GenerateHasOrderState(orders, orderStates).Generate(count);

        public List<HasOrderState> GenerateOrderStory(List<HasOrderState> currentOrderStates, List<OrderState> orderStates)
        {
            foreach (var curOrderState in currentOrderStates)
            {
                var order = (Order)curOrderState.NodeFrom;
                var state = (OrderState)curOrderState.NodeTo;
                var faker = new Faker("ru");
                var previousStageTimeStart = curOrderState.TimeStartState.AddHours(-5);
                //если заказ отменен, то он может быть отменен только до завершения заказа
                var limitStory = state.NumberOfStage == (int)OrderStateEnum.Cancelled ? (int)OrderStateEnum.Finished : state.NumberOfStage;

                for (int i = 0, j = 1; j < limitStory; i++, j = (int)Math.Pow(2,i))
                {
                    if(j != (int)OrderStateEnum.InQueue && state.NumberOfStage == (int)OrderStateEnum.Cancelled)
                    {
                        //с вероятностью 1/3 прекращаем создавать историю, тем самым
                        //отменяя заказ после случайной стадии
                        var rand = new Random().Next(0, 3);
                        if(rand == 0)
                        {
                            break;
                        }
                    }

                    var orderStoryState = new HasOrderState()
                    {
                        TimeStartState = faker.Date.Between(previousStageTimeStart, previousStageTimeStart.AddHours(1)),
                        Comment = faker.Lorem.Sentence(),
                        Id = Guid.NewGuid(),
                        NodeFromId = order.Id,
                        NodeToId = orderStates[i].Id,
                    };
                    order.Story.Add(orderStoryState);
                    previousStageTimeStart = orderStoryState.TimeStartState;
                }

                order.Story.Add(new HasOrderState()
                {
                    TimeStartState = curOrderState.TimeStartState,
                    Comment = faker.Lorem.Sentence(),
                    Id = curOrderState.Id,
                    NodeFromId = order.Id,
                    NodeToId = state.Id,
                });
            }
            return currentOrderStates;
        }

        public List<Ordered> GenerateRelationsOrdered(int count, List<Order> orders, List<Client> client)
            => ObjectGenerator.GenerateOrdered(orders, client).Generate(count);

        public List<OrderedDish> GenerateRelationsOrderedDish(int count, List<Order> orders, List<Dish> dishes)
        {
            var mediumCountDishesInOrder = count / orders.Count;
            var rand = new Random();
            List<OrderedDish> relations = new List<OrderedDish>();

            foreach (var order in orders)
            {
                var countDishInOrder = rand.Next(1, mediumCountDishesInOrder + 2);
                relations.AddRange(ObjectGenerator.GenerateOrderedDish(new List<Order>() { order }, dishes).Generate(countDishInOrder));
            }

            relations = ExcludeDuplicate(relations);

            for (int i = 0; i < relations.Count; i++)
            {
                var orderItem = (Order)relations[i].NodeFrom;
                var dishItem = (Dish)relations[i].NodeTo;

                orderItem.SumWeight += dishItem.Weight * relations[i].Count;
                orderItem.Price += dishItem.Price * relations[i].Count;
            }
            return relations;
        }

        public List<ReviewedBy> GenerateRelationsReviewedBy(int count, List<Order> orders, List<Client> reviewers)
            => ObjectGenerator.GenerateReviewedBy(orders, reviewers).Generate(count);

        public List<WorkedIn> GenerateRelationsWorkedIn(int count, List<Kitchen> kitchens, List<KitchenWorker> kitchenWorkers)
            => ObjectGenerator.GenerateWorkedIn(kitchens, kitchenWorkers).Generate(count);

        /// <summary>
        /// Exclude Duplicate. Compare NodeFrom.Ids and NodeTo.Ids then remove this relations from list and return it
        /// </summary>
        /// <param name="relations">List with relations</param>
        /// <returns>Relations without duplicate</returns>
        private List<TRelation> ExcludeDuplicate<TRelation>(List<TRelation> relations) where TRelation: IRelation
        {
            relations = relations.OrderBy(x => x.NodeFrom.Id).ThenBy(x => x.NodeTo.Id).ToList();
            var relationsForRemove = new List<TRelation>();

            for (int i = 0; i < relations.Count - 1; i++)
            {
                for (int j = i + 1; j < relations.Count; j++)
                {
                    if (relations[i].NodeFrom.Id == relations[j].NodeFrom.Id && relations[i].NodeTo.Id == relations[j].NodeTo.Id)
                    {
                        relationsForRemove.Add(relations[j]);
                    }
                    else break;
                }
            }

            relations = relations.Except(relationsForRemove).ToList();

            return relations;
        }

        private Dictionary<string, List<string>> CategoryLinkWithDishNames { get; set; } =
            new Dictionary<string, List<string>>()
            {
                {"Rolls", new List<string>{ "Суши с лососем", "Унаги ролл", "Калифорния ролл", "Филадельфия ролл", "Авокадо ролл", "Креветка ролл", "Темпура ролл", "Дракон ролл", "Спайси тунец ролл", "Ролл с огурцом" } },
                {"Drinks", new List<string>{ "Мохито", "Пина Колада", "Дайкири", "Маргарита", "Май Тай", "Космополитен", "Мартини", "Белый Русский", "Текила Санрайз" } },
                {"SecondMeal", new List<string>{ "Стейк", "Котлеты", "Рыба запеченная в духовке", "Жаркое", "Гуляш", "Курица табака", "Мясо по-французски", "Свинина в соусе", "Телятина с овощами", "Гриль" } },
                {"FirstMeal", new List<string>{ "Борщ", "Солянка", "Уха", "Грибной суп", "Щи", "Окрошка", "Рассольник", "Лапша по-флотски", "Французский луковый суп", "Куриный суп с лапшой" } },
                {"Salads", new List<string>{ "Цезарь", "Греческий", "Оливье", "Винегрет", "Салат нисуаз", "Мимоза", "Тушёнка", "Капустный", "Селёдочный", "Крабовый" } },
                {"Pizza", new List<string>{ "Маргарита", "Пепперони", "Гавайская пицца", "Пицца четыре сыра", "Вегетарианская пицца", "Барбекю", "Мексиканская пицца", "Мясная пицца", "Морская пицца", "Дьябло" } },
            };
    }
}

GeneratorService.cs

using DbManager.Data;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.Interfaces;
using DbManager.Services;
using Newtonsoft.Json;

namespace DbManager.Neo4j.DataGenerator
{
    public class GeneratorService
    {
        private readonly IRepositoryFactory _repoFactory;
        private readonly DataGenerator _dataGenerator;
        private readonly IPasswordService _pswService;

        public GeneratorService(IRepositoryFactory repositoryFactory, IPasswordService passwordService, DataGenerator dataGenerator)
        {
            _repoFactory = repositoryFactory;
            _dataGenerator = dataGenerator;
            _pswService = passwordService;
        }

        public async Task GenerateAll()
        {
            var mediumCountDishesInOrder = 3;
            var countRandomStateForOrders = 350;

            //генерируем узлы
            var orderStates = _dataGenerator.GenerateOrderStates();
            var admins = _dataGenerator.GenerateAdmins(2);

            var admin = admins[0];
            admin.Login = "admin@admin";
            admin.PasswordHash = _pswService.GetPasswordHash(admin.Login, "admin").ToList();

            var clients = _dataGenerator.GenerateClients(50);

            var client = clients[0];
            client.Login = "item@item";
            client.PasswordHash = _pswService.GetPasswordHash(client.Login, "item").ToList();

            var deliveryMen = _dataGenerator.GenerateDeliveryMen(7);

            var deliveryMan = deliveryMen[0];
            deliveryMan.Login = "deliveryMan@deliveryMan";
            deliveryMan.PasswordHash = _pswService.GetPasswordHash(deliveryMan.Login, "deliveryMan").ToList();

            var kitchenWorkers = _dataGenerator.GenerateKitchenWorkers(9);

            var kitchenWorker = kitchenWorkers[0];
            kitchenWorker.Login = "kitchenWorker@kitchenWorker";
            kitchenWorker.PasswordHash = _pswService.GetPasswordHash(kitchenWorker.Login, "kitchenWorker").ToList();

            var kitchens = _dataGenerator.GenerateKitchens(3);
            var orders = _dataGenerator.GenerateOrders(1000);
            var categories = new List<Category>();
            var dishes = new List<Dish>();
            //генерация категорий и блюд происходит в данном методе!
            var containsDishes = _dataGenerator.GenerateRelationsContainsDishWithNodes(30, 6, categories, dishes);

            //вставляем узлы в бд
            var orderRepo = _repoFactory.GetRepository<Order>();

            await orderRepo.AddNodesAsync(orders);
            await _repoFactory.GetRepository<Dish>().AddNodesAsync(dishes);
            await _repoFactory.GetRepository<Admin>().AddNodesAsync(admins);
            await _repoFactory.GetRepository<Client>().AddNodesAsync(clients);
            await _repoFactory.GetRepository<DeliveryMan>().AddNodesAsync(deliveryMen);
            await _repoFactory.GetRepository<KitchenWorker>().AddNodesAsync(kitchenWorkers);
            await _repoFactory.GetRepository<Kitchen>().AddNodesAsync(kitchens);
            await _repoFactory.GetRepository<OrderState>().AddNodesAsync(orderStates);
            await _repoFactory.GetRepository<Category>().AddNodesAsync(categories);

            //генерируем связи между узлами. Последовательность важна!
            //создаем новые списки, т.к. эти списки будут изменяться. 
            //так, при генерации связи Ordered будут удаляться заказы из списка, чтобы они не дублировались
            var workedIns = _dataGenerator.GenerateRelationsWorkedIn(kitchenWorkers.Count, kitchens, new List<KitchenWorker>(kitchenWorkers));
            var cookedBies = _dataGenerator.GenerateRelationsCookedBy(orders.Count, new List<Order>(orders), kitchens);
            var deliveredBies = _dataGenerator.GenerateRelationsDeliveredBy(orders.Count, new List<Order>(orders), deliveryMen);
            var hasOrderStates = _dataGenerator.GenerateRelationsHasOrderState(countRandomStateForOrders, new List<Order>(orders.GetRange(0, countRandomStateForOrders)), orderStates);
            hasOrderStates.AddRange(_dataGenerator.GenerateRelationsHasOrderState(orders.Count - countRandomStateForOrders, new List<Order>(orders.GetRange(countRandomStateForOrders, orders.Count - countRandomStateForOrders)), new List<OrderState>() { orderStates.First(h => h.NumberOfStage == (int)OrderStateEnum.Finished) }));
            var ordereds = _dataGenerator.GenerateRelationsOrdered(orders.Count, new List<Order>(orders), clients);
            
            //Генерируем связь OrderedDish. Количество связей будет меньше, т.к. удаляются дублируемые
            var orderedDishes = _dataGenerator.GenerateRelationsOrderedDish(orders.Count * mediumCountDishesInOrder, orders, dishes);
            
            //связываем узлы
            foreach (var item in workedIns)
                await _repoFactory.GetRepository<Kitchen>().RelateNodesAsync(item);

            //В цикле все, т.к. при генерации учитывается, что эти связи идут 1 к 2
            for (int i = 0; i < orders.Count; i++)
            {
                await orderRepo.RelateNodesAsync(cookedBies[i]);
                await orderRepo.RelateNodesAsync(deliveredBies[i]);
                await orderRepo.RelateNodesAsync(hasOrderStates[i]);
                await orderRepo.RelateNodesAsync(ordereds[i]);
            }
            //Создаем историю для заказов. Создаются рандомные связи с состояниями до последнего
            hasOrderStates = _dataGenerator.GenerateOrderStory(hasOrderStates, orderStates);

            for (int i = 0; i < orders.Count; i++)
            {
                //обновляем узлы Order, т.к. появились привязанные заказы
                await orderRepo.UpdateNodeAsync(orders[i]);
            }

            foreach (var item in orderedDishes)
                await orderRepo.RelateNodesAsync(item);

            //Создание отзыва в самом конце, т.к. время ее создания зависит от времени завершения заказа
            var reviewedBies = new List<ReviewedBy>();

            var finishedOrders = hasOrderStates.Where(h => ((OrderState)h.NodeTo).NumberOfStage == (int)OrderStateEnum.Finished).Select(h => (Order)h.NodeFrom).ToList();

            //Генерируем связь ReviewedBy между клиентами и ИХ заказами. Генерация только для завершенных заказов
            foreach (var item in clients)
            {
                var orderedOrders = ordereds
                    .Where(h => h.NodeFrom.Id == item.Id && finishedOrders.Contains((Order)h.NodeTo))
                    .Select(h => (Order)h.NodeTo)
                    .ToList();

                reviewedBies.AddRange(_dataGenerator
                    .GenerateRelationsReviewedBy(orderedOrders.Count, new List<Order>(orderedOrders), new List<Client>() { item }));
            }

            foreach (var item in reviewedBies)
                await orderRepo.RelateNodesAsync(item);

            foreach (var item in containsDishes)
                await _repoFactory.GetRepository<Dish>().RelateNodesAsync(item);

            //устанавливаем всем пользователям тип User
            foreach (var item in admins)
                await _repoFactory.GetRepository<Admin>().SetNewNodeType<User>(item.Id.ToString());
            foreach (var item in clients)
                await _repoFactory.GetRepository<Client>().SetNewNodeType<User>(item.Id.ToString());
            foreach (var item in kitchenWorkers)
                await _repoFactory.GetRepository<KitchenWorker>().SetNewNodeType<User>(item.Id.ToString());
            foreach (var item in deliveryMen)
                await _repoFactory.GetRepository<DeliveryMan>().SetNewNodeType<User>(item.Id.ToString());


        }
    }
}

ObjectGenerator.cs
using Bogus;
using DbManager.Data.Nodes;
using DbManager.Data;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using DbManager.Data.Relations;
using DbManager.Services;

namespace DbManager.Neo4j.DataGenerator
{
    internal static class ObjectGenerator
    {
        private static List<string> CategoryNames = new List<string>
        {
            "Роллы",
            "Напитки",
            "Вторые блюда",
            "Первые блюда",
            "Салаты",
            "Пицца",
        };

        private static Dictionary<string, string> CategoryLinks = new Dictionary<string, string>
        {
            { "Роллы", "Rolls" },
            { "Напитки", "Drinks" },
            { "Вторые блюда", "SecondMeal" },
            { "Первые блюда", "FirstMeal" },
            { "Салаты", "Salads" },
            { "Пицца", "Pizza" },
        };

        //----------------------------------------------GenerateNodes------------------------------------------------------------

        public static Faker<Dish> GenerateDish(List<string>? dishNames = null)
            => new Faker<Dish>("ru")
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.Name, g => dishNames == null ? g.Commerce.ProductName() : g.Random.ListItemWithRemove(dishNames))
                .RuleFor(h => h.Description, g => g.Lorem.Paragraph())
                .RuleFor(h => h.Price, g => g.Random.Number(100, 800))
                .RuleFor(h => h.Weight, g => g.Random.Number(150, 1000))
                .RuleFor(h => h.IsAvailableForUser, g => true);

        public static Faker<Category> GenerateCategory()
            => new Faker<Category>("ru")
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.Name, g => g.Random.ListItemWithRemove(CategoryNames))
                .RuleFor(h => h.LinkName, (g, o) => CategoryLinks[o.Name])
                .RuleFor(h => h.Description, g => g.Lorem.Paragraph());

        public static Faker<Order> GenerateOrder()
            => new Faker<Order>("ru") 
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.PhoneNumber, g => g.Phone.PhoneNumber("+7!!!!!!!!!!"))
                .RuleFor(h => h.DeliveryAddress, g => g.Address.StreetAddress());

        public static Faker<Kitchen> GenerateKitchen()
            => new Faker<Kitchen>("ru")
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.Address, g => g.Address.StreetAddress());

        public static Faker<Admin> GenerateAdmin(IPasswordService pswService)
            => new Faker<Admin>("ru")
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshToken, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshTokenCreated, g => g.Date.Soon())
                .RuleFor(h => h.Born, g => g.Date.Between(new DateTime(1980, 10, 10), new DateTime(2003, 10, 10)))
                .RuleFor(h => h.Name, g => g.Person.FullName)
                .RuleFor(h => h.Login, g => g.Internet.Email())
                .RuleFor(h => h.PhoneNumber, g => g.Phone.PhoneNumber("+7!!!!!!!!!!"))
                .RuleFor(h => h.Address, g => g.Address.StreetAddress())
                .RuleFor(h => h.PasswordHash, (g, o) => pswService.GetPasswordHash(o.Login, g.Internet.Password()).ToList());

        public static Faker<Client> GenerateClient(IPasswordService pswService)
            => new Faker<Client>("ru")
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshToken, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshTokenCreated, g => g.Date.Soon())
                .RuleFor(h => h.Born, g => g.Date.Between(new DateTime(1980, 10, 10), new DateTime(2003, 10, 10)))
                .RuleFor(h => h.Name, g => g.Person.FullName)
                .RuleFor(h => h.Login, g => g.Internet.Email())
                .RuleFor(h => h.Bonuses, g => Math.Round(g.Random.Double() + g.Random.Number(150, 1000), 2))
                .RuleFor(h => h.PhoneNumber, g => g.Phone.PhoneNumber("+7!!!!!!!!!!"))
                .RuleFor(h => h.Address, g => g.Address.StreetAddress())
                .RuleFor(h => h.PasswordHash, (g, o) => pswService.GetPasswordHash(o.Login, g.Internet.Password()).ToList());

        public static Faker<DeliveryMan> GenerateDeliveryMan(IPasswordService pswService)
            => new Faker<DeliveryMan>("ru")
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshToken, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshTokenCreated, g => g.Date.Soon())
                .RuleFor(h => h.Born, g => g.Date.Between(new DateTime(1980, 10, 10), new DateTime(2003, 10, 10)))
                .RuleFor(h => h.Name, g => g.Person.FullName)
                .RuleFor(h => h.Login, g => g.Internet.Email())
                .RuleFor(h => h.MaxWeight, g => g.Random.Number(4000, 50000))
                .RuleFor(h => h.PhoneNumber, g => g.Phone.PhoneNumber("+7!!!!!!!!!!"))
                .RuleFor(h => h.Address, g => g.Address.StreetAddress())
                .RuleFor(h => h.PasswordHash, (g, o) => pswService.GetPasswordHash(o.Login, g.Internet.Password()).ToList());

        public static Faker<KitchenWorker> GenerateKitchenWorker(IPasswordService pswService)
            => new Faker<KitchenWorker>("ru")
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshToken, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshTokenCreated, g => g.Date.Soon())
                .RuleFor(h => h.Born, g => g.Date.Between(new DateTime(1980, 10, 10), new DateTime(2003, 10, 10)))
                .RuleFor(h => h.Name, g => g.Person.FullName)
                .RuleFor(h => h.Login, g => g.Internet.Email())
                .RuleFor(h => h.JobTitle, g => g.Name.JobTitle())
                .RuleFor(h => h.PhoneNumber, g => g.Phone.PhoneNumber("+7!!!!!!!!!!"))
                .RuleFor(h => h.Address, g => g.Address.StreetAddress())
                .RuleFor(h => h.PasswordHash, (g, o) => pswService.GetPasswordHash(o.Login, g.Internet.Password()).ToList());

        //---------------------------------------------GenerateRelations-------------------------------------------------------------

        public static Faker<OrderedDish> GenerateOrderedDish(List<Order> orders, List<Dish> dishes)
            => new Faker<OrderedDish>("ru")
                .RuleFor(h => h.NodeTo, g => g.Random.ListItem(dishes))
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItem(orders))
                .RuleFor(h => h.Count, g => g.Random.Number(1, g.Random.Number(1,3)));

        public static Faker<CookedBy> GenerateCookedBy(List<Order> orders, List<Kitchen> kitchens)
            => new Faker<CookedBy>("ru")
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItem(kitchens))
                .RuleFor(h => h.NodeTo, g => g.Random.ListItemWithRemove(orders));

        public static Faker<ContainsDish> GenerateContainsDish(List<Category> categories, List<Dish> dishes)
            => new Faker<ContainsDish>("ru")
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItem(categories))
                .RuleFor(h => h.NodeTo, g => g.Random.ListItemWithRemove(dishes));

        public static Faker<DeliveredBy> GenerateDeliveredBy(List<Order> orders, List<DeliveryMan> deliveryMen)
            => new Faker<DeliveredBy>("ru")
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItem(deliveryMen))
                .RuleFor(h => h.NodeTo, g => g.Random.ListItemWithRemove(orders));

        public static Faker<HasOrderState> GenerateHasOrderState(List<Order> orders, List<OrderState> states)
            => new Faker<HasOrderState>("ru")
                .RuleFor(h => h.TimeStartState, g => g.Date.Between(new DateTime(2022, 10, 10), DateTime.Now))
                .RuleFor(h => h.Comment, g => g.Random.Bool() ? g.Lorem.Sentence() : null)
                .RuleFor(h => h.NodeTo, g => g.Random.ListItem(states))
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItemWithRemove(orders));

        public static Faker<Ordered> GenerateOrdered(List<Order> orders, List<Client> clients)
            => new Faker<Ordered>("ru")
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItem(clients))
                .RuleFor(h => h.NodeTo, g => g.Random.ListItemWithRemove(orders));

        /// <summary>
        /// Предпологается, что на вход идут только завершенные или отмененные заказы  
        /// </summary>
        /// <param name="orders"></param>
        /// <param name="reviewers"></param>
        /// <returns></returns>
        public static Faker<ReviewedBy> GenerateReviewedBy(List<Order> orders, List<Client> reviewers)
            => new Faker<ReviewedBy>("ru")
                .RuleFor(h => h.ClientRating, g => g.Random.Int(1, 10))
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItem(reviewers))
                .RuleFor(h => h.NodeTo, g => g.Random.ListItemWithRemove(orders))
                .RuleFor(h => h.TimeCreated, (g, o) => g.Date.Between(((Order)o.NodeTo).Story.Last().TimeStartState, ((Order)o.NodeTo).Story.Last().TimeStartState.AddHours(3)))
                .RuleFor(h => h.Review, g => g.Lorem.Paragraph());

        public static Faker<WorkedIn> GenerateWorkedIn(List<Kitchen> kitchens, List<KitchenWorker> kitchenWorkers)
            => new Faker<WorkedIn>("ru")
                .RuleFor(h => h.GotJob, g => g.Date.Between(new DateTime(2010, 10, 10), DateTime.Now))
                .RuleFor(h => h.NodeTo, g => g.Random.ListItem(kitchens))
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItemWithRemove(kitchenWorkers));
    }
}

ClientRepository.cs
using DbManager.Data;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.Interfaces;
using Neo4jClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Implementations
{
    public class ClientRepository : GeneralRepository<Client>, IClientRepository
    {
        public ClientRepository(IGraphClient DbContext) : base(DbContext)
        {
        }

        public async Task<List<(Client, double, int)>> GetTopClientBySumPriceOrderStatistic(int topCount)
        {
            /*match (c:Client)-[r:ORDERED]-(o:Order)
            with c, sum(o.Price) as sum, count(o) as count
            return c,sum,count order by sum limit 10*/

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(Client).Name})-[relation:{typeof(Ordered).Name.ToUpper()}]-(relatedNode:{typeof(Order).Name})")
                .With("node, sum(relatedNode.Price) as sum, count(relatedNode) as count")
                //.Where($"")
                .Return((node, sum, count) => new
                {
                    client = node.As<Client>(),
                    sum = sum.As<double>(),
                    count = count.As<int>(),
                })
                .ChangeQueryForPaginationAnonymousType(new[] { "sum DESC" }, limitCount: topCount)
                .ResultsAsync;

            return res.Select(h => (h.client, h.sum, h.count)).ToList();
        }
    }
}

DeliveryManRepository.cs
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.Interfaces;
using Neo4jClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Implementations
{
    public class DeliveryManRepository : GeneralRepository<DeliveryMan>, IDeliveryManRepository
    {
        public DeliveryManRepository(IGraphClient DbContext) : base(DbContext)
        {
        }

        public async Task<List<(DeliveryMan, int)>> GetTopDeliveryMenByCountOrder(int topCount)
        {
            /*match (c:DeliveryMan)-[r:DELIVEREDBY]-(o:Order)
            with c, count(o) as count
            return c,count order by COUNT desc limit 10*/

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(DeliveryMan).Name})-[relation:{typeof(DeliveredBy).Name.ToUpper()}]-(relatedNode:{typeof(Order).Name})")
                .With("node, count(relatedNode) as count")
                //.Where($"")
                .Return((node, count) => new
                {
                    delMan = node.As<DeliveryMan>(),
                    count = count.As<int>(),
                })
                .ChangeQueryForPaginationAnonymousType(new[] { "count DESC" }, limitCount: topCount)
                .ResultsAsync;

            return res.Select(h => (h.delMan, h.count)).ToList();
        }
    }
}

DishRepository.cs
using DbManager.Data;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.Interfaces;
using Neo4jClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Implementations
{
    public class DishRepository : GeneralRepository<Dish>, IDishRepository
    {
        public DishRepository(IGraphClient DbContext) : base(DbContext)
        {
        }

        public async Task<List<Dish>> SearchDishesByNameAndDescription(string searchText, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "node." + orderByProperty[i];

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(Dish).Name})")
                .Where($"toLower(node.Name) contains($searchText) or toLower(node.Description) contains($searchText)")
                .WithParams(new
                    {
                        searchText
                    })
                .Return((node) => node.As<Dish>())
                .ChangeQueryForPagination(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            return res.ToList();
        }

        public async Task<List<(Dish, int)>> GetTopDishByCountOrderedStatistic(int topCount)
        {
            /*match (o:Order)-[r:ORDEREDDISH]-(d:Dish) 
            with count(r) as countR, d
            return d, countR order by countR desc limit 10*/

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(Order).Name})-[relation:{typeof(OrderedDish).Name.ToUpper()}]-(relatedNode:{typeof(Dish).Name})")
                .With("relatedNode, count(relation) as countR")
                //where time > date("2022-11-01") and time < date("2023-03-01")
                .Return((relatedNode, countR) => new
                {
                    dish = relatedNode.As<Dish>(),
                    countOfOrdereds = countR.As<int>(),
                })
                .ChangeQueryForPaginationAnonymousType(new[] { "countR desc" }, limitCount: topCount)
                .ResultsAsync;

            return res.Select(h => (h.dish, h.countOfOrdereds)).ToList();
        }
    }
}

GeneralRepository.cs
using DbManager.Data;
using DbManager.Neo4j.Interfaces;
using Neo4jClient;
using Neo4jClient.Cypher;

namespace DbManager.Neo4j.Implementations
{
    public class GeneralRepository<TNode> : IGeneralRepository<TNode> 
        where TNode : INode
    {
        protected readonly IGraphClient dbContext;

        public GeneralRepository(IGraphClient DbContext)
        {
            dbContext = DbContext;
        }

        public async Task AddNodeAsync(TNode newNode)
        {
            if(newNode.Id == Guid.Empty)
                newNode.Id = Guid.NewGuid();
            await dbContext.Cypher
                .Merge($"(newNode:{typeof(TNode).Name} {{Id: $id}})")
                .OnCreate()
                .Set("newNode = $newEntity")
                .WithParams(new
                {
                    id = newNode.Id,
                    newEntity = newNode
                })  
                .ExecuteWithoutResultsAsync();
        }

        public async Task AddNodesAsync(List<TNode> newNodes)
        {
            foreach (var item in newNodes)
            {
                await AddNodeAsync(item);
            }
        }

        public async Task UpdateNodeAsync(TNode node)
        {
            await dbContext.Cypher
                .Match($"(updateNode:{typeof(TNode).Name} {{Id: $id}})")
                .Set("updateNode = $updatedEntity")
                .WithParams(new
                {
                    id = node.Id,
                    updatedEntity = node
                })
                .ExecuteWithoutResultsAsync();
        }

        public async Task UpdateNodesPropertiesAsync(TNode node)
        {
            var properties = typeof(TNode).GetProperties();
            var query = dbContext.Cypher
                .Match($"(updateNode:{typeof(TNode).Name} {{Id: $id}})");

            foreach (var property in properties)
            {
                query = query.Set($"updateNode.{property.Name} = $updatedEntity.{property.Name}");
            }

            await query.WithParams(new
            {
                id = node.Id,
                updatedEntity = node
            })
                .ExecuteWithoutResultsAsync();
        }

        public async Task<TNode> GetNodeAsync(string id)
            => await GetNodeAsync(Guid.Parse(id));

        public async Task<TNode> GetNodeAsync(Guid id)
        {
            var res = await dbContext.Cypher
                .Match($"(entity:{typeof(TNode).Name} {{Id: $id}})")
                .WithParams(new
                {
                    id,
                })
                .Return(entity => entity.As<TNode>())
                .ResultsAsync;

            if (res.Count() != 1)
                throw new Exception($"Count of nodes with such Id don't equels 1. Type: {typeof(TNode).Name}");

            return res.First();
        }

        public async Task<List<TNode>> GetNodesAsync(int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "entity." + orderByProperty[i];

            var query = dbContext.Cypher
                .Match($"(entity:{typeof(TNode).Name})")
                .Return(entity => entity.As<TNode>())
                .ChangeQueryForPagination(orderByProperty, skipCount, limitCount);

            var res = await query.ResultsAsync;

            return res.ToList();
        }

        public async Task DeleteNodeWithAllRelations(TNode node)
        {
            await dbContext.Cypher
                .Match($"(entity:{typeof(TNode).Name} {{Id: $id}})-[r]-()")
                .WithParams(new
                {
                    id = node.Id,
                })
                .Delete("r, entity")
                .ExecuteWithoutResultsAsync();
        }

        public async Task RelateNodesAsync<TRelation>(TRelation relation)
            where TRelation : IRelation
        {
            if(relation.NodeFromId == null || relation.NodeToId == null)
            { 
                throw new Exception("NodeFromId or NodeToId is null. Method RelateNodesAsync where TRelation is " + typeof(TRelation));
            }
            var typeNodeFrom = typeof(TRelation).BaseType.GenericTypeArguments[0];
            var direction = GetDirection(relation.GetType().Name, "relation", typeNodeFrom == typeof(TNode));

            if (relation.Id == Guid.Empty)
                relation.Id = Guid.NewGuid();

            await dbContext.Cypher
                .Match($"(node {{Id: $entityId}}), (otherNode {{Id: $otherNodeId}})")
                .Create($"(node){direction}(otherNode)")
                .Set("relation=$newRelation")
                .WithParams(new
                {
                    entityId = relation.NodeFromId,
                    otherNodeId = relation.NodeToId,
                    newRelation = relation
                })
                .ExecuteWithoutResultsAsync();
        }

        public async Task UpdateRelationNodesAsync<TRelation>(TRelation updatedRelation)
            where TRelation : IRelation
        {
            var typeNodeFrom = typeof(TRelation).BaseType.GenericTypeArguments[0];
            var direction = GetDirection(updatedRelation.GetType().Name, "relation", typeNodeFrom == typeof(TNode));

            await dbContext.Cypher
                .Match($"(node {{Id: $id}}){direction}(relatedNode {{Id: $relatedNodeId}})")
                .Set("relation=$updatedRelation")
                .WithParams(new
                {
                    id = updatedRelation.NodeFromId,
                    relatedNodeId = updatedRelation.NodeToId,
                    updatedRelation
                })
                .ExecuteWithoutResultsAsync();
        }

        public async Task<TRelation> GetRelationBetweenTwoNodesAsync<TRelation, TRelatedNode>(TNode node, TRelatedNode relatedNode, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TRelation : IRelation
            where TRelatedNode : INode
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "relation." + orderByProperty[i];

            var direction = GetDirection(typeof(TRelation).Name, "relation");

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name} {{Id: $id}}){direction}(relatedNode:{typeof(TRelatedNode).Name} {{Id: $relatedNodeId}})")
                .WithParams(new
                {
                    id = node.Id,
                    relatedNodeId = relatedNode.Id,
                })
                .Return(relation => relation.As<TRelation>())
                .ChangeQueryForPagination(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            if (res.Count() < 1)
                throw new Exception($"Nodes don't have relation ({typeof(TNode).Name})-[{typeof(TRelation).Name.ToUpper()})]-({typeof(TRelatedNode).Name})");

            return res.First();
        }

        public async Task<List<TRelation>> GetRelationsOfNodesAsync<TRelation, TRelatedNode>(TNode node, int? skipCount = null, int? limitCount = null, params string[] orderByProperty) 
            where TRelation: IRelation
            where TRelatedNode: INode
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "relatedNode." + orderByProperty[i];

            var direction = GetDirection(typeof(TRelation).Name, "relation");
            var typeNodeFrom = typeof(TRelation).BaseType.GenericTypeArguments[0];

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name} {{Id: $id}}){direction}(relatedNode:{typeof(TRelatedNode).Name})")
                .WithParams(new
                {
                    id = node.Id,
                })
                .Return((relation, relatedNode) => new
                {
                    nodeRelations = relation.As<TRelation>(),
                    relationNodes = relatedNode.As<TRelatedNode>()
                })
                .ChangeQueryForPaginationAnonymousType(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            var nodeIsNodeFrom = typeof(TNode) == typeNodeFrom;
            var relations = res.Select(h =>
            {
                h.nodeRelations.NodeFrom = nodeIsNodeFrom ? node : h.relationNodes;
                h.nodeRelations.NodeTo = nodeIsNodeFrom ? h.relationNodes : node;
                return h.nodeRelations;
            }).ToList();

            return relations;
        }

        public async Task<List<TRelation>> GetRelationsOfNodesAsync<TRelation, TRelatedNode>(string nodeId, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TRelation : IRelation
            where TRelatedNode : INode 
        {
            var node = await GetNodeAsync(nodeId);

            return await GetRelationsOfNodesAsync<TRelation, TRelatedNode>(node, skipCount, limitCount, orderByProperty);
        }

        public async Task DeleteRelationOfNodesAsync<TRelation, TRelatedNode>(TNode node, TRelatedNode relatedNode)
            where TRelation : IRelation
            where TRelatedNode : INode
        {
            var direction = GetDirection(typeof(TRelation).Name, "relation");

            await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name} {{Id: $id}}){direction}(relatedNode:{typeof(TRelatedNode).Name} {{Id: $relatedNodeId}})")
                .Delete("relation")
                .WithParams(new
                {
                    id = node.Id,
                    relatedNodeId = relatedNode.Id,
                })
                .ExecuteWithoutResultsAsync();
        }

        public async Task<List<TNode>> GetNodesWithoutRelation<TRelation>(int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "node." + orderByProperty[i];

            var directionIn = GetDirection(typeof(TRelation).Name); 
            var directionOut = GetDirection(typeof(TRelation).Name);

            var result = await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name})")
                .Where($"not (node){directionIn}() and not (node){directionOut}()")
                .Return(node => node.As<TNode>())
                .ChangeQueryForPagination(orderByProperty,skipCount,limitCount)
                .ResultsAsync;

            return result.ToList();
        }

        public async Task<List<TNode>> GetNodesByIdAsync(string[] ids, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "node." + orderByProperty[i];

            var result = await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name})")
                .Where($"node.Id in [\"{string.Join("\",\"", ids)}\"]")
                .Return(node => node.As<TNode>())
                .ChangeQueryForPagination(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            return result.ToList();
        }

        public async Task<List<TNode>> GetNodesByPropertyAsync(string nameOfProperty, string[] propertyValues, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "node." + orderByProperty[i];

            var result = await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name})")
                .Where($"node.{nameOfProperty} in [\"{string.Join("\",\"", propertyValues)}\"]")
                .Return(node => node.As<TNode>())
                .ChangeQueryForPagination(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            return result.ToList();
        }

        public async Task SetNewNodeType<TNewNodeType>(string nodeId)
            where TNewNodeType : INode
        {
            await SetNewNodeType(nodeId, typeof(TNewNodeType).Name);
        }

        public async Task SetNewNodeType(string nodeId, string nodeTypeName)
        {
            await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name} {{Id: $id}})")
                .Set($"node:{nodeTypeName}")
                .WithParams(new
                {
                    id = nodeId,
                })
                .ExecuteWithoutResultsAsync();
        }

        public async Task RemoveNodeType<TNodeType>(string nodeId)
            where TNodeType : INode
        {
            await RemoveNodeType(nodeId, typeof(TNodeType).Name);
        }

        public async Task RemoveNodeType(string nodeId, string nodeTypeName)
        {
            await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name} {{Id: $id}})")
                .Remove($"node:{nodeTypeName}")
                .WithParams(new
                {
                    id = nodeId,
                })
                .ExecuteWithoutResultsAsync();
        }

        public async Task<bool> HasNodeType<TNodeType>(string nodeId)
            where TNodeType : INode
        {
            return await HasNodeType(nodeId, typeof(TNodeType).Name);
        }

        public async Task<bool> HasNodeType(string nodeId, string nodeType)
        {
            var result = await dbContext.Cypher
                .Match($"(node:{typeof(User).Name} {{Id: $id}})")
                .WithParams(new
                {
                    id = nodeId,
                })
                .ReturnDistinct<List<string>>("labels(node)")
                .ResultsAsync;

            var clearResult = result.First().ToList();

            if (clearResult.Contains(nodeType))
                return true;

            return false;
        }

        /// <summary>
        /// Get string with directed relation. Relation has name type of "relation" + relationInstanceName
        /// </summary>
        /// <param name="nameRelation">Name of the relation in DB</param>
        /// <param name="relationInstanceName">Name of relation instance</param>
        /// <param name="relationInEntity">Relation input in node or output</param>
        /// <returns>String with directed relation</returns>
        protected string GetDirection(string nameRelation, string? relationInstanceName = "", bool? relationInEntity = null)
        {
            string direction = "-[]-";
            if(!string.IsNullOrEmpty(nameRelation))
                direction = $"-[{relationInstanceName}:{nameRelation.ToUpper()}]-";

            if (relationInEntity == null)
                return direction;

            return relationInEntity.Value ? "<" + direction: direction + ">";
        }
    }
}
OrderRepository.cs
using DbManager.Data;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.Interfaces;
using Neo4jClient;
using Neo4jClient.Cypher;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Implementations
{
    public class OrderRepository : GeneralRepository<Order>, IOrderRepository
    {
        public OrderRepository(IGraphClient DbContext) : base(DbContext)
        {
        }

        public async Task<List<Order>> GetOrdersByStateRelatedWithNode<TNode>(string nodeId, string nameOfState, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TNode : INode
        {
            return await GetOrdersByStateRelatedWithNode<TNode>(Guid.Parse(nodeId),OrderState.OrderStatesFromDb.Single(h=>h.NameOfState == nameOfState).Id, skipCount, limitCount, orderByProperty);
        }

        public async Task<List<Order>> GetOrdersByStateRelatedWithNode<TNode>(string nodeId, OrderStateEnum orderState, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TNode : INode
        {
            return await GetOrdersByStateRelatedWithNode<TNode>(Guid.Parse(nodeId), OrderState.OrderStatesFromDb.Single(h => (OrderStateEnum)h.NumberOfStage == orderState).Id, skipCount, limitCount, orderByProperty);
        }

        public async Task<List<Order>> GetOrdersByStateRelatedWithNode<TNode>(Guid nodeId, Guid orderStateId, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TNode : INode
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "orders." + orderByProperty[i];

            var directionInOrderCB = GetDirection("");
            var directionInOrderHOS = GetDirection(typeof(HasOrderState).Name, "rel");

            var res = await dbContext.Cypher
                .Match(
                    $"(node:{typeof(TNode).Name} {{Id: $nodeId}})" +
                    $"{directionInOrderCB}" +
                    $"(orders:{typeof(Order).Name})" +
                    $"{directionInOrderHOS}" +
                    $"(orderState:{typeof(OrderState).Name} {{Id: $orderStateId}})")
                .WithParams(new
                    {
                        nodeId,
                        orderStateId,
                    })
                .Return(orders => orders.As<Order>())
                .ChangeQueryForPagination(orderByProperty.Concat(new[] { "rel.TimeStartState desc" }).ToArray(), skipCount, limitCount)
                .ResultsAsync;

            return res.ToList();
        }

        public async Task<HasOrderState?> MoveOrderToNextStage(string orderId, string comment)
        {
            var order = await GetNodeAsync(Guid.Parse(orderId));
            var orderHasState = order.Story.Last();
            var orderState = OrderState.OrderStatesFromDb.Single(h => h.Id == orderHasState.NodeToId);
            //Если заказ был отменен или завершен, то ничего не произойдет
            if ((OrderStateEnum)orderState.NumberOfStage == OrderStateEnum.Cancelled || (OrderStateEnum)orderState.NumberOfStage == OrderStateEnum.Finished)
                return null;

            await DeleteRelationOfNodesAsync<HasOrderState, OrderState>(order, orderState);
            var newOrderState = new HasOrderState() 
            {
                Comment = comment, 
                NodeFromId = order.Id, 
                NodeToId = OrderState.OrderStatesFromDb.Single(h => h.NumberOfStage == orderState.NumberOfStage * 2).Id,
                TimeStartState = DateTime.Now 
            };

            order.Story.Add(newOrderState);
            await RelateNodesAsync(newOrderState);
            await UpdateNodeAsync(order);

            newOrderState.NodeTo = OrderState.OrderStatesFromDb.Single(h => h.NumberOfStage == orderState.NumberOfStage * 2);

            return newOrderState;
        }

        public async Task<bool> MoveOrderToPreviousStage(string orderId)
        {
            var order = await GetNodeAsync(Guid.Parse(orderId));
            var orderHasState = order.Story.Last();
            var orderState = OrderState.OrderStatesFromDb.Single(h => h.Id == orderHasState.NodeToId);
            //Если заказ только попал в очередь
            if ((OrderStateEnum)orderState.NumberOfStage == OrderStateEnum.InQueue)
                return false;
            
            await DeleteRelationOfNodesAsync<HasOrderState, OrderState>(order, orderState);
            order.Story.Remove(orderHasState);

            var newOrderState = order.Story.Last();

            await RelateNodesAsync(newOrderState);
            await UpdateNodeAsync(order);

            return true;
        }

        public async Task CreateOrderRelationInDB(Order order, string? userId, List<Dish> dishes, Kitchen kitchen, DeliveryMan deliveryMan, Dictionary<string, int> countOfDishes, string? comment)
        {
            if(userId != null)
                await RelateNodesAsync(new Ordered() { NodeFromId = Guid.Parse(userId), NodeTo = order });

            foreach (var dish in dishes)
            {
                await RelateNodesAsync(new OrderedDish() { NodeFrom = order, NodeTo = dish, Count = countOfDishes[dish.Id.ToString()] });
            }

            await RelateNodesAsync(new CookedBy() { NodeFrom = kitchen, NodeTo = order });

            await RelateNodesAsync(new DeliveredBy() { NodeFrom = deliveryMan, NodeTo = order });

            var firstState = OrderState.OrderStatesFromDb.First(h => h.NumberOfStage == (int)OrderStateEnum.InQueue);
            var relationCancel = new HasOrderState() { Comment = comment, NodeFromId = order.Id, NodeToId = firstState.Id, TimeStartState = DateTime.Now };

            order.Story.Add(relationCancel);
            await RelateNodesAsync(relationCancel);
            await UpdateNodeAsync(order);
        }

        public async Task<List<(string, double, int)>> GetOrderPriceAndCountStatistic()
        {
            /*MATCH (node:Order)-[relation:HASORDERSTATE]-(relatedNode:OrderState {NumberOfStage: 16}) 
            WITH date.truncate('month', datetime(relation.TimeStartState)) as time , sum(node.Price) as sum, count(relatedNode) as count 
            where time > date("2022-11-01") and time < date("2023-03-01")
            RETURN time, sum, count order by time*/

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(Order).Name})-[relation:{typeof(HasOrderState).Name.ToUpper()}]-(relatedNode:{typeof(OrderState).Name} {{NumberOfStage: $NumberOfFinishStage}})")
                .WithParams(new
                {
                    NumberOfFinishStage = (int)OrderStateEnum.Finished,
                })
                .With("date.truncate('month', datetime(relation.TimeStartState)) as time , sum(node.Price) as sum, count(relatedNode) as count")
                //where time > date("2022-11-01") and time < date("2023-03-01")
                .Return((time, sum, count) => new
                {
                    time = time.As<DateTime>(),
                    sum = sum.As<double>(),
                    count = count.As<int>(),
                })
                .ChangeQueryForPaginationAnonymousType(new[] { "time" })
                .ResultsAsync;

            return res.Select(h => (h.time.Month+"."+h.time.Year, h.sum, h.count)).ToList();
        }

        public async Task<List<(string, int, int)>> GetCountFinishedOrderAndClientsStatistic()
        {
            /*MATCH (node:Client)-[relation:ORDERED]-(relatedNode:Order)-[relation2:HASORDERSTATE]-(relatedNode2:OrderState {NumberOfStage: 16})
            with count(relatedNode) as countOfOrders, count(distinct node) as countOfClients, date.truncate('month', datetime(relation2.TimeStartState)) as time
            RETURN countOfOrders, countOfClients, time order by time */

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(Client).Name})-[relation:{typeof(Ordered).Name.ToUpper()}]-(relatedNode:{typeof(Order).Name})-[relation2:{typeof(HasOrderState).Name.ToUpper()}]-(relatedNode2:{typeof(OrderState).Name} {{NumberOfStage: $NumberOfFinishStage}})")
                .WithParams(new
                {
                    NumberOfFinishStage = (int)OrderStateEnum.Finished,
                })
                .With("count(relatedNode) as countOfOrders, count(distinct node) as countOfClients, date.truncate('month', datetime(relation2.TimeStartState)) as time")
                //where time > date("2022-11-01") and time < date("2023-03-01")
                .Return((time, countOfOrders, countOfClients) => new
                {
                    time = time.As<DateTime>(),
                    countOfOrders = countOfOrders.As<int>(),
                    countOfClients = countOfClients.As<int>(),
                })
                .ChangeQueryForPaginationAnonymousType(new[] { "time" })
                .ResultsAsync;

            return res.Select(h => (h.time.Month + "." + h.time.Year, h.countOfOrders, h.countOfClients)).ToList();
        }

        public async Task<List<(string, List<Order>)>> GetCancelledOrderGroupedByMonthStatistic()
        {
            /* MATCH(node:Order)-[relation: HASORDERSTATE]-(relatedNode:OrderState {NumberOfStage: 32})
            with node, date.truncate('month', datetime(relation.TimeStartState)) as time
            RETURN node, time order by time */

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(Order).Name})-[relation:{typeof(HasOrderState).Name.ToUpper()}]-(relatedNode:{typeof(OrderState).Name} {{NumberOfStage: $NumberOfFinishStage}})")
                .WithParams(new
                {
                    NumberOfFinishStage = (int)OrderStateEnum.Cancelled,
                })
                .With("node, date.truncate('month', datetime(relation.TimeStartState)) as time")
                //where time > date("2022-11-01") and time < date("2023-03-01")
                .Return((node, time) => new
                {
                    time = time.As<DateTime>(),
                    node = node.CollectAs<Order>(),
                })
                .ChangeQueryForPaginationAnonymousType(new[] { "time" })
                .ResultsAsync;

            return res.Select(h => (h.time.Month + "." + h.time.Year, h.node.ToList())).ToList();
        }

        public async Task<List<(Kitchen, int, int)>> GetCountOrdersAndOrderedDishesForEveryKitchenStatistic()
        {
            /*match(k:Kitchen)-[]-(o:Order)-[r:ORDEREDDISH]-(d:Dish)
            with k, count(distinct o) as countO, sum(r.Count) as sumD
            return k,countO, sumD */

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(Kitchen).Name})-[relation:{typeof(CookedBy).Name.ToUpper()}]-(relatedNode:{typeof(Order).Name})-[relation2:{typeof(OrderedDish).Name.ToUpper()}]-(relatedNode2:{typeof(Dish).Name})")
                .With("node, count(distinct relatedNode) as countO, sum(relation2.Count) as sumD")
                //where time > date("2022-11-01") and time < date("2023-03-01")
                .Return((node, countO, sumD) => new
                {
                    kitchen = node.As<Kitchen>(),
                    countOfOrders = countO.As<int>(),
                    sumOfDishes = sumD.As<int>(),
                })
                .ChangeQueryForPaginationAnonymousType(new string[0])
                .ResultsAsync;

            return res.Select(h => (h.kitchen, h.countOfOrders, h.sumOfDishes)).ToList();
        }
    }
}

RepositoryFactory.cs
using DbManager.Data;
using DbManager.Neo4j.Interfaces;
using Microsoft.Extensions.DependencyInjection;
using Neo4jClient;

namespace DbManager.Neo4j.Implementations
{
    public class RepositoryFactory: IRepositoryFactory
    {
        private readonly IGraphClient dbContext;
        private readonly IServiceProvider services;
        private readonly Dictionary<Type, object> repositories = new Dictionary<Type, object>();

        public IGraphClient DbContext => dbContext;

        public RepositoryFactory(IGraphClient neo4jData, IServiceProvider serviceProvider)
        {
            dbContext = neo4jData;
            services = serviceProvider;

            var res = neo4jData.JsonConverters;
            var count = res.Count;
        }

        public IGeneralRepository<TEntity> GetRepository<TEntity>(bool hasCustomRepository = false) where TEntity : INode
        {
            if (hasCustomRepository)
            {
                var repo = services.GetService<IGeneralRepository<TEntity>>();
                if(repo != null)
                {
                    return repo;
                }
            }

            var typeEntity = typeof(TEntity);
            if (!repositories.ContainsKey(typeEntity)) 
            { 
                var generalRepo = new GeneralRepository<TEntity>(DbContext);
                repositories.Add(typeEntity, generalRepo);
            }

            return (IGeneralRepository<TEntity>)repositories[typeEntity];
        }
    }
}

UserRepository.cs
using DbManager.Data;
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using DbManager.Neo4j.Interfaces;
using Neo4jClient;
using Neo4jClient.Cypher;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Implementations
{
    public class UserRepository : GeneralRepository<User>, IUserRepository
    {
        public UserRepository(IGraphClient DbContext) : base(DbContext)
        {
        }

        public Dictionary<string, byte> UserRolePriority { get; } = new Dictionary<string, byte>
        {
            {"User", 0},
            {"Client", 1},
            {"KitchenWorker", 2},
            {"Admin", 100},
        };

        private string GetMaxPriorityRole(List<string> roles)
        {
            var maxPriRole = UserRolePriority.First(h=>h.Value == 0).Key;

            foreach (var role in roles)
            {
                if(UserRolePriority.TryGetValue(role, out _))
                {
                    if (UserRolePriority[role] > UserRolePriority[maxPriRole])
                    {
                        maxPriRole = role;
                    }
                }
                else
                {
                    break;
                }
            }

            return maxPriRole;
        }

        public async Task<List<string>> GetUserRoles(string userId)
        {
            var result = await dbContext.Cypher
                .Match($"(node:{typeof(User).Name} {{Id: $id}})")
                .WithParams(new
                {
                    id = userId,
                })
                .ReturnDistinct<List<string>>("labels(node)")
                .ResultsAsync;

            var clearResult = result.First().ToList();

            return clearResult;
        }

        public async Task<List<(User, List<string>)>> GetUsersForAdmin(int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "node." + orderByProperty[i];

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(User).Name})")
                .With("node, labels(node) as roles")
                .Return((node, roles) => new
                {
                    user = node.As<User>(),
                    userRoles = roles.As<List<string>>()
                })
                .ChangeQueryForPaginationAnonymousType(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            return res.Select(h=>(h.user, h.userRoles)).ToList();
        }

        public async Task<List<(User, List<string>)>> SearchUsersByIdAndLoginForAdmin(string searchText, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "node." + orderByProperty[i];

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(User).Name})")
                .Where($"toLower(node.Id) contains($searchText) or toLower(node.Login) contains($searchText)")
                .WithParams(new
                {
                    searchText
                })
                .With("node, labels(node) as roles")
                .Return((node, roles) => new
                {
                    user = node.As<User>(),
                    userRoles = roles.As<List<string>>()
                })
                .ChangeQueryForPaginationAnonymousType(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            return res.Select(h => (h.user, h.userRoles)).ToList();
        }

        public async Task<List<User>> SearchUsersByIdAndLogin(string searchText, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "node." + orderByProperty[i];

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(User).Name})")
                .Where($"toLower(node.Id) contains($searchText) or toLower(node.Login) contains($searchText)")
                .WithParams(new
                {
                    searchText
                })
                .Return((node) => node.As<User>())
                .ChangeQueryForPagination(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            return res.ToList();
        }
    }
}

IClientRepository.cs
using DbManager.Data.Nodes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Interfaces
{
    public interface IClientRepository : IGeneralRepository<Client>
    {
        public Task<List<(Client, double, int)>> GetTopClientBySumPriceOrderStatistic(int topCount);
    }
}

IDeliveryManRepository.cs
using DbManager.Data.Nodes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Interfaces
{
    public interface IDeliveryManRepository : IGeneralRepository<DeliveryMan>
    {
        Task<List<(DeliveryMan, int)>> GetTopDeliveryMenByCountOrder(int topCount);
    }
}

IDishRepository.cs
using DbManager.Data.Nodes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Interfaces
{
    public interface IDishRepository : IGeneralRepository<Dish>
    {
        Task<List<Dish>> SearchDishesByNameAndDescription(string searchText, int? skipCount = null, int? limitCount = null, params string[] orderByProperty);
        Task<List<(Dish, int)>> GetTopDishByCountOrderedStatistic(int topCount);
    }
}

IGeneralRepository.cs
 using DbManager.Data;

namespace DbManager.Neo4j.Interfaces
{
    /// <summary>
    /// General interface for repository
    /// </summary>
    /// <typeparam name="TNode"></typeparam>
    public interface IGeneralRepository<TNode> where TNode : INode
    {
        /// <summary>
        /// Add node with properties to DB. Generate new Id. If node with such id already exist in DB, then node won't added to DB
        /// </summary>
        /// <param name="node">New node</param>
        /// <returns></returns>
        Task AddNodeAsync(TNode node);

        /// <summary>
        /// Add nodes with properties to DB. Generate new Id for each nodes. If node with such id already exist in DB, then node won't added to DB
        /// </summary>
        /// <param name="newNodes">List of new nodes</param>
        /// <returns></returns>
        Task AddNodesAsync(List<TNode> newNodes);

        /// <summary>
        /// Replace existing node
        /// </summary>
        /// <param name="node">The node, which will be replaced</param>
        /// <returns></returns>
        Task UpdateNodeAsync(TNode node);

        /// <summary>
        /// Update existing node properties
        /// </summary>
        /// <param name="node">The node, which will be updated</param>
        /// <returns></returns>
        Task UpdateNodesPropertiesAsync(TNode node);

        /// <summary>
        /// Get the node with the specified id. If DB return count of nodes < 1, then function throw Exception
        /// </summary>
        /// <param name="id">Node id</param>
        /// <returns>Node with specified id</returns>
        /// <exception cref="Exception">Count of items with specified id less 1.</exception>
        Task<TNode> GetNodeAsync(string id);

        /// <summary>
        /// Get the node with the specified id. If DB return count of nodes != 1, then function throw Exception
        /// </summary>
        /// <param name="id">Node id</param>
        /// <returns>Node with specified id</returns>
        /// <exception cref="Exception">Count of items with specified id don't equels 1.</exception>
        Task<TNode> GetNodeAsync(Guid id);

        /// <summary>
        /// Get all nodes TModel type
        /// </summary>
        /// <param name="skipCount">Count of nodes will skip</param>
        /// <param name="limitCount">Count of nodes will returner after skip</param>
        /// <param name="orderByProperty">Property names by which to sort. ONLY properties of TNode</param>
        /// <returns>List of TModel type</returns>
        Task<List<TNode>> GetNodesAsync(int? skipCount = null, int? limitCount = null, params string[] orderByProperty);

        /// <summary>
        /// Delete existing node
        /// </summary>
        /// <param name="node">The node, which will be deleted</param>
        /// <returns></returns>
        Task DeleteNodeWithAllRelations(TNode node);

        /// <summary>
        /// Get relation between two nodes
        /// </summary>
        /// <typeparam name="TRelation">The type of relation</typeparam>
        /// <typeparam name="TRelatedNode">Type of related nodes</typeparam>
        /// <param name="node">The first node</param>
        /// <param name="relatedNode">The second node</param>
        /// <param name="skipCount">Count of nodes will skip</param>
        /// <param name="limitCount">Count of nodes will returner after skip</param>
        /// <param name="orderByProperty">Property names by which to sort. ONLY properties of TRelation</param>
        /// <returns></returns>
        Task<TRelation> GetRelationBetweenTwoNodesAsync<TRelation, TRelatedNode>(TNode node, TRelatedNode relatedNode, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TRelation : IRelation
            where TRelatedNode : INode;

        /// <summary>
        /// Update realtion of two existing nodes
        /// </summary>
        /// <typeparam name="TRelation">The type of updated relation</typeparam>
        /// <param name="updatedRelation">The relation, which will be used for update data</param>
        /// <returns></returns>
        Task UpdateRelationNodesAsync<TRelation>(TRelation updatedRelation)
            where TRelation : IRelation;

        /// <summary>
        /// Delete relation between two nodes
        /// </summary>
        /// <typeparam name="TRelation">The type of relation</typeparam>
        /// <typeparam name="TRelatedNode">Type of related nodes</typeparam>
        /// <param name="node">The first node</param>
        /// <param name="relatedNode">The second node</param>
        /// <returns></returns>
        Task DeleteRelationOfNodesAsync<TRelation, TRelatedNode>(TNode node, TRelatedNode relatedNode)
            where TRelation : IRelation
            where TRelatedNode : INode;

        /// <summary>
        /// Get related nodes as List
        /// </summary>
        /// <typeparam name="TRelation">The type of searched relation</typeparam>
        /// <typeparam name="TRelatedNode">The type of related nodes</typeparam>
        /// <param name="node">Node, which have related nodes</param>
        /// <param name="skipCount">Count of nodes will skip</param>
        /// <param name="limitCount">Count of nodes will returner after skip</param>
        /// <param name="orderByProperty">Property names by which to sort. ONLY properties of TRelatedNode</param>
        /// <returns>If target node don't have related nodes, will be returned empty lists</returns>
        Task<List<TRelation>> GetRelationsOfNodesAsync<TRelation, TRelatedNode> (TNode node, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TRelation : IRelation
            where TRelatedNode : INode;

        /// <summary>
        /// Get related nodes as List
        /// </summary>
        /// <typeparam name="TRelation">The type of searched relation</typeparam>
        /// <typeparam name="TRelatedNode">The type of related nodes</typeparam>
        /// <param name="nodeId">Node id, which have related nodes</param>
        /// <param name="skipCount">Count of nodes will skip</param>
        /// <param name="limitCount">Count of nodes will returner after skip</param>
        /// <param name="orderByProperty">Property names by which to sort. ONLY properties of TRelatedNode</param>
        /// <returns>If target node don't have related nodes, will be returned empty lists</returns>
        Task<List<TRelation>> GetRelationsOfNodesAsync<TRelation, TRelatedNode>(string nodeId, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TRelation : IRelation
            where TRelatedNode : INode;

        /// <summary>
        /// Relate two existing nodes
        /// </summary>
        /// <typeparam name="TRelation">The type of added relation</typeparam>
        /// <param name="relation">The relation, which will be related nodes</param>
        /// <returns></returns>
        Task RelateNodesAsync<TRelation>(TRelation relation)
            where TRelation : IRelation;

        /// <summary>
        /// Get all nodes, which haven't specified relation
        /// </summary>
        /// <typeparam name="TRelation">The type of relation, which nodes haven't to use</typeparam>
        /// <param name="skipCount">Count of nodes will skip</param>
        /// <param name="limitCount">Count of nodes will returner after skip</param>
        /// <param name="orderByProperty">Property names by which to sort. ONLY properties of TNode</param>
        /// <returns>Nodes, which haven't related using specified relation</returns>
        Task<List<TNode>> GetNodesWithoutRelation<TRelation>(int? skipCount = null, int? limitCount = null, params string[] orderByProperty);

        /// <summary>
        /// Get nodes by property from params
        /// </summary>
        /// <param name="nameOfProperty">Name of property, which will be use for search</param>
        /// <param name="propertyValues">Values of property</param>
        /// <param name="skipCount">Count of nodes will skip</param>
        /// <param name="limitCount">Count of nodes will returner after skip</param>
        /// <param name="orderByProperty">Property names by which to sort. ONLY properties of TNode</param>
        /// <returns></returns>
        Task<List<TNode>> GetNodesByPropertyAsync(string nameOfProperty, string[] propertyValues, int? skipCount = null, int? limitCount = null, params string[] orderByProperty);

        /// <summary>
        /// Set new type to node
        /// </summary>
        /// <typeparam name="TNewNodeType">New node type</typeparam>
        /// <param name="nodeId">Id of node</param>
        /// <returns></returns>
        Task SetNewNodeType<TNewNodeType>(string nodeId)
            where TNewNodeType : INode;

        /// <summary>
        /// Set new type to node
        /// </summary>
        /// <param name="nodeId">Id of node</param>
        /// <param name="nodeTypeName">Node type which will be new</param>
        /// <returns></returns>
        Task SetNewNodeType(string nodeId, string nodeTypeName);

        /// <summary>
        /// Remove new type to node. If the node doesn't implement this type, then nothing will happen.
        /// </summary>
        /// <typeparam name="TNodeType">Node type which will be removed</typeparam>
        /// <param name="nodeId">Id of node</param>
        /// <returns></returns>
        Task RemoveNodeType<TNodeType>(string nodeId)
            where TNodeType : INode;

        /// <summary>
        /// Remove new type to node. If the node doesn't implement this type, then nothing will happen.
        /// </summary>
        /// <param name="nodeId">Id of node</param>
        /// <param name="nodeTypeName">Node type which will be removed</param>
        /// <returns></returns>
        Task RemoveNodeType(string nodeId, string nodeTypeName);

        /// <summary>
        /// Return true if node is node type "TNodeType", false if not.
        /// </summary>
        /// <typeparam name="TNodeType">Node type which will searched</typeparam>
        /// <param name="nodeId">Id of node</param>
        /// <returns></returns>
        Task<bool> HasNodeType<TNodeType>(string nodeId)
            where TNodeType : INode;

        /// <summary>
        /// Return true if node is node type "TNodeType", false if not.
        /// </summary>
        /// <param name="nodeId">Id of node</param>
        /// <param name="nodeTypeName">Node type which will searched</param>
        /// <returns></returns>
        Task<bool> HasNodeType(string nodeId, string nodeTypeName);
    }
}

IOrderRepository.cs
using DbManager.Data;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Interfaces
{
    /// <summary>
    /// Interface for repository, which work with nodes Order
    /// </summary>
    public interface IOrderRepository : IGeneralRepository<Order>
    {
        Task<List<Order>> GetOrdersByStateRelatedWithNode<TNode>(string nodeId, string nameOfState, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TNode : INode;
        Task<List<Order>> GetOrdersByStateRelatedWithNode<TNode>(string nodeId, OrderStateEnum orderState, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TNode : INode;
        Task<List<Order>> GetOrdersByStateRelatedWithNode<TNode>(Guid nodeId, Guid orderStateId, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TNode : INode;
        Task<HasOrderState?> MoveOrderToNextStage(string orderId, string comment);
        Task<bool> MoveOrderToPreviousStage(string orderId);
        Task<List<(string, double, int)>> GetOrderPriceAndCountStatistic();
        Task<List<(string, int, int)>> GetCountFinishedOrderAndClientsStatistic();
        Task<List<(string, List<Order>)>> GetCancelledOrderGroupedByMonthStatistic();
        Task<List<(Kitchen, int, int)>> GetCountOrdersAndOrderedDishesForEveryKitchenStatistic();
        Task CreateOrderRelationInDB(Order order, string? userId, List<Dish> dishes, Kitchen kitchen, DeliveryMan deliveryMan, Dictionary<string, int> countOfDishes, string? comment);
    }
}

IRepositoryFactory.cs
using DbManager.Data;

namespace DbManager.Neo4j.Interfaces
{
    /// <summary>
    /// Factory for IGeneralRepository, it uses for work with neo4j database
    /// </summary>
    public interface IRepositoryFactory
    {
        /// <summary>
        /// Get repository for work with database nodes
        /// </summary>
        /// <typeparam name="TEntity">Type node from database</typeparam>
        /// <param name="hasCustomRepository">Return custom repository if it register as service</param>
        /// <returns>IGeneralRepository for work with database</returns>
        IGeneralRepository<TEntity> GetRepository<TEntity>(bool hasCustomRepository = false) where TEntity : INode;
    }
}

IUserRepository.cs
using DbManager.Data;
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Interfaces
{
    public interface IUserRepository : IGeneralRepository<User>
    {
        Dictionary<string, byte> UserRolePriority { get; }
        /// <summary>
        /// Return max priority role of user. For example, if user has Client and Admin roles, then it return Admin
        /// </summary>
        /// <param name="userId">Id of user</param>
        /// <returns>string Role</returns>
        Task<List<string>> GetUserRoles(string userId);

        Task<List<(User, List<string>)>> GetUsersForAdmin(int? skipCount, int? limitCount, params string[] orderByProperty);

        Task<List<User>> SearchUsersByIdAndLogin(string searchText, int? skipCount = null, int? limitCount = null, params string[] orderByProperty);

        Task<List<(User, List<string>)>> SearchUsersByIdAndLoginForAdmin(string searchText, int? skipCount = null, int? limitCount = null, params string[] orderByProperty);
    }
}


IPasswordService.cs

namespace DbManager.Services
{
    /// <summary>
    /// Service for generate argon2i hash
    /// </summary>
    public interface IPasswordService
    {
        /// <summary>
        /// Get Argon2i hash from password
        /// </summary>
        /// <param name="salt">string, which will be used as salt</param>
        /// <param name="password">string, which will be hashed</param>
        /// <returns></returns>
        byte[] GetPasswordHash(string salt, string password);
        /// <summary>
        /// Equels hash password with old hash from Db
        /// </summary>
        /// <param name="salt">string, which will be used as salt</param>
        /// <param name="password">string, which will be hashed</param>
        /// <param name="hashFromDb">hash old password</param>
        /// <returns></returns>
        bool CheckPassword(string salt, string password, byte[] hashFromDb);
    }
}

PasswordService.cs
using Konscious.Security.Cryptography;

namespace DbManager.Services
{
    public class PasswordService : IPasswordService
    {
        public byte[] GetPasswordHash(string salt, string password)
        {
            var argon2 = new Argon2i(password.Select(h => ((byte)h)).ToArray());
            argon2.Salt = salt.Select(h => ((byte)h)).ToArray();
            argon2.DegreeOfParallelism = 16;
            argon2.MemorySize = 4096;
            argon2.Iterations = 40;

            var hash = argon2.GetBytes(128);

            return hash;
        }

        public bool CheckPassword(string salt, string password, byte[] hashFromDb)
        {
            var passBytes = GetPasswordHash(salt, password);

            return hashFromDb.SequenceEqual(passBytes);
        }
    }
}

