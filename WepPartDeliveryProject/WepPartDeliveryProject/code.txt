ApplicationSettings.cs
namespace WepPartDeliveryProject
{
    public class ApplicationSettings
    {
        public int CountOfItemsOnWebPage { get; set; }
        public string JwtSecretKey { get; set; }
        public bool GenerateData { get; set; }
    }
}

Program.cs
using DbManager;
using DbManager.Mapper;
using DbManager.Neo4j.DataGenerator;
using Microsoft.AspNetCore.Authentication.Cookies;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.DataProtection.KeyManagement;
using Microsoft.AspNetCore.Http.HttpResults;
using Microsoft.AspNetCore.SpaServices.ReactDevelopmentServer;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.IdentityModel.Tokens;
using Microsoft.Net.Http.Headers;
using Neo4jClient;
using Neo4jClient.Execution;
using Newtonsoft.Json;
using System.Text;
using WepPartDeliveryProject;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
var services = builder.Services;
var configuration = builder.Configuration;

services.AddLogging(loggingBuilder => {
    var loggingSection = configuration.GetSection("Logging");
    loggingBuilder.AddFile(loggingSection);
});

services.AddAutoMapper(typeof(MapperProfile));
services.AddSingleton<JwtService>();

builder.Services.AddCors(options =>
{
    options.AddDefaultPolicy(
        policy =>
        {
            policy
                .WithOrigins(configuration.GetSection("ClientAppSettings:ClientAppApi").Value)
                .WithOrigins("https://e9eb-176-124-28-223.ngrok-free.app")
                //.WithHeaders(HeaderNames.ContentType, HeaderNames.Cookie)
                .AllowAnyHeader()
                .AllowAnyMethod()
                .AllowCredentials();

            /*            policy
                            .AllowAnyOrigin()
                            .AllowAnyHeader()
                            .AllowAnyMethod();*/
        });
});

services.AddControllers().AddNewtonsoftJson(options =>
        {
            options.SerializerSettings.MaxDepth = 3;
            options.SerializerSettings.Formatting = Newtonsoft.Json.Formatting.Indented;
        }
    ); 
//services.AddEndpointsApiExplorer();
services.AddSwaggerGen();

// Register application setting
services.Configure<Neo4jSettings>(configuration.GetSection("Neo4jSettings"));
services.Configure<ApplicationSettings>(configuration.GetSection("ApplicationSettings"));

services.AddDbInfrastructure(configuration);
services.AddHealthChecks().AddCheck<GraphHealthCheck>("GraphHealthCheck");

services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;

})
    .AddJwtBearer(options =>
    {
        options.RequireHttpsMetadata = false;
        options.SaveToken = true;
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(configuration.GetSection("ApplicationSettings:JwtSecretKey").Value)),
            ValidateIssuer = false,
            ValidateAudience = false,
            ValidateLifetime = true,
        };
    });


var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

var appSetting = new ApplicationSettings();
configuration.GetSection("ApplicationSettings").Bind(appSetting);

if (appSetting.GenerateData)
    await app.Services.GetService<GeneratorService>().GenerateAll();

//               
var graphClient = app.Services.GetService<IGraphClient>();
graphClient.OperationCompleted += (sender, e) => app.Logger.LogInformation(e.QueryText.Replace("\r\n", " "));

app.UseSwagger();
app.UseSwaggerUI(options =>
{
    options.SwaggerEndpoint("/swagger/v1/swagger.json", "v1");
    options.RoutePrefix = string.Empty;
});

app.UseCors();

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseHealthChecks("/healthcheck");

app.UseAuthentication();
app.UseRouting();
app.UseAuthorization();

app.MapControllers();

app.Run();
AdminController.cs
using AutoMapper;
using DbManager;
using DbManager.Data;
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.Interfaces;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Components.Forms;
using Microsoft.AspNetCore.Mvc;


namespace WepPartDeliveryProject.Controllers
{
    [Authorize(Roles = "Admin")]
    [Route("[controller]")]
    [ApiController]
    public class AdminController : Controller
    {
        private readonly IRepositoryFactory _repositoryFactory;
        private readonly ApplicationSettings _appSettings;
        private readonly IConfiguration _configuration;
        private readonly IMapper _mapper;

        public AdminController(IRepositoryFactory repositoryFactory, IConfiguration configuration, IMapper mapper)
        {
            // Fetch settings object from configuration
            _appSettings = new ApplicationSettings();
            configuration.GetSection("ApplicationSettings").Bind(_appSettings);

            _configuration = configuration;
            _repositoryFactory = repositoryFactory;
            _mapper = mapper;
        }

        [HttpGet("getOrders")]
        public async Task<IActionResult> GetOrders(int page = 0, int numberOfState = 1)
        {
            var orderRelations = await _repositoryFactory.GetRepository<OrderState>().GetRelationsOfNodesAsync<HasOrderState, Order>(OrderState.OrderStatesFromDb.First(h=>h.NumberOfStage == numberOfState), _appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1, "TimeStartState");

            var orders = orderRelations.Select(h => (Order)h.NodeFrom).ToList();

            var ordersDTOs = _mapper.Map<List<OrderOutDTO>>(orders);

            var pageEnded = ordersDTOs.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            return Ok(new { orders = ordersDTOs.GetRange(0, ordersDTOs.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage : ordersDTOs.Count), pageEnded });
        }

        [HttpGet("getDishes")]
        public async Task<IActionResult> GetDishes(string searchText = "", int page = 0)
        {
            var dishes = await ((IDishRepository)_repositoryFactory.GetRepository<Dish>(true))
                .SearchDishesByNameAndDescription(searchText, _appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1, "Name");

            var pageEnded = dishes.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            return Ok(new { dishes = dishes.GetRange(0, dishes.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage : dishes.Count), pageEnded });
        }

        [HttpGet("getDish/{id}")]
        public async Task<IActionResult> GetDish(Guid id)
        {
            var dish = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(id);
            var dishCategory = await _repositoryFactory.GetRepository<Dish>().GetRelationsOfNodesAsync<ContainsDish, Category>(dish);

            return Ok(new { dish, category = dishCategory.First().NodeFrom });
        }

        [HttpGet("getUsers")]
        public async Task<IActionResult> GetUsers(string searchText = "", int page = 0)
        {
            var usersAsTuples = await ((IUserRepository)_repositoryFactory.GetRepository<User>(true)).SearchUsersByIdAndLoginForAdmin(searchText, _appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1);

            var rightUsers = usersAsTuples.Select(h => _mapper.Map(h.Item2, _mapper.Map<UserForAdminOutDTO>(h.Item1))).ToList();
            
            var pageEnded = rightUsers.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            return Ok(new { users = rightUsers.GetRange(0, rightUsers.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage : rightUsers.Count), pageEnded });
        }

        [HttpGet("getRoles")]   
        public IActionResult GetRoles()
        {
            return Ok(((IUserRepository)_repositoryFactory.GetRepository<User>(true)).UserRolePriority.Keys.ToList().Except(new List<String>() { "User"}));
        }

        [HttpPost("addUserRole")]
        public async Task<IActionResult> AddUserRole(List<ManipulateUserDataInDTO> inputData)
        {
            var userRepo = (IUserRepository)_repositoryFactory.GetRepository<User>(true);
            var usersDicrionary = (await userRepo.GetNodesByPropertyAsync("Id", inputData.Select(h => h.UserId).ToArray())).ToDictionary(h => h.Id.ToString());

            foreach (var manipulateUsersData in inputData)
            {
                //на тот случай, если не все id верно переданы
                if (usersDicrionary.TryGetValue(manipulateUsersData.UserId, out var user))
                {
                    await _repositoryFactory.GetRepository<User>().SetNewNodeType(user.Id.ToString(), manipulateUsersData.ChangeRole);
                }

            }

            return Ok();
        }

        [HttpPost("removeUserRole")]
        public async Task<IActionResult> RemoveUserRole(List<ManipulateUserDataInDTO> inputData)
        {
            var userRepo = (IUserRepository)_repositoryFactory.GetRepository<User>(true);
            var usersDicrionary = (await userRepo.GetNodesByPropertyAsync("Id", inputData.Select(h => h.UserId).ToArray())).ToDictionary(h=>h.Id.ToString());

            foreach (var manipulateUsersData in inputData)
            {
                //на тот случай, если не все id верно переданы
                if(usersDicrionary.TryGetValue(manipulateUsersData.UserId, out var user))
                {
                    await _repositoryFactory.GetRepository<User>().RemoveNodeType(user.Id.ToString(), manipulateUsersData.ChangeRole);
                }

            }

            return Ok();
        }

        [HttpPost("blockUsers")]
        public async Task<IActionResult> BlockUsers(List<ManipulateUserDataInDTO> inputData)
        {
            var userRepo = (IUserRepository)_repositoryFactory.GetRepository<User>(true);
            var users = await userRepo.GetNodesByPropertyAsync("Id", inputData.Select(h=>h.UserId).ToArray());
            foreach (var user in users)
            {
                user.IsBlocked = true;
                await userRepo.UpdateNodeAsync(user);
            }

            return Ok();
        }

        [HttpPost("unblockUsers")]
        public async Task<IActionResult> UnblockUsers(List<ManipulateUserDataInDTO> inputData)
        {
            var userRepo = (IUserRepository)_repositoryFactory.GetRepository<User>(true);
            var users = await userRepo.GetNodesByPropertyAsync("Id", inputData.Select(h => h.UserId).ToArray());
            foreach (var user in users)
            {
                user.IsBlocked = false;
                await userRepo.UpdateNodeAsync(user);
            }

            return Ok();
        }

        [HttpPost("changeDeleteStatusOfDish")]
        public async Task<IActionResult> ChangeDeleteStatusOfDish(ManipulateDishDataInDTO inputData)
        {
            var dish = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(inputData.Id.ToString());
            if (dish == null)
            {
                return BadRequest("Данные о блюде не обнаружены");
            }

            dish.IsDeleted = !dish.IsDeleted;
            await _repositoryFactory.GetRepository<Dish>().UpdateNodeAsync(dish);

            return Ok(dish.IsDeleted);
        }

        [HttpPost("changeVisibleStatusOfDish")]
        public async Task<IActionResult> ChangeVisibleStatusOfDish(ManipulateDishDataInDTO inputData)
        {
            var dish = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(inputData.Id.ToString());
            if (dish == null)
            {
                return BadRequest("Данные о блюде не обнаружены");
            }

            dish.IsAvailableForUser = !dish.IsAvailableForUser;
            await _repositoryFactory.GetRepository<Dish>().UpdateNodeAsync(dish);

            return Ok(dish.IsAvailableForUser);
        }

        [HttpPatch("changeDish")]
        public async Task<IActionResult> ChangeDish([FromForm] ManipulateDishDataInDTO inputData)
        {
            var dishRepo = _repositoryFactory.GetRepository<Dish>();
            var dishToChange = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(inputData.Id.ToString());
            if(dishToChange == null)
            {
                return BadRequest("Данные о блюде не обнаружены");
            }

            var category = Category.CategoriesFromDb.SingleOrDefault(h => h.Id.ToString() == inputData.CategoryId);

            var curDishCategory = await dishRepo.GetRelationsOfNodesAsync<ContainsDish, Category>(dishToChange);

            if(curDishCategory != null && curDishCategory.Count !=0 && curDishCategory.First().NodeFromId != category.Id)
            {
                await dishRepo.DeleteRelationOfNodesAsync<ContainsDish, Category>(dishToChange, (Category)curDishCategory.First().NodeFrom);

                await dishRepo.RelateNodesAsync(new ContainsDish() { NodeFrom = category, NodeTo = dishToChange });
            }

            _mapper.Map(inputData, dishToChange);

            var newImages = await LoadImagesToDir(inputData.ImagesFiles, category.LinkName, dishToChange.Id.ToString());
            if(newImages.Count != 0)
            {
                dishToChange.Images = newImages;
            }

            await _repositoryFactory.GetRepository<Dish>().UpdateNodeAsync(dishToChange);

            return Ok(dishToChange.Id);
        }

        [HttpPost("createDish")]
        public async Task<IActionResult> CreateDish([FromForm] ManipulateDishDataInDTO inputData)
        {
            var dishRepo = _repositoryFactory.GetRepository<Dish>();
            var dish = _mapper.Map<Dish>(inputData);
            dish.Images = new List<string>();
            var category = Category.CategoriesFromDb.SingleOrDefault(h => h.Id.ToString() == inputData.CategoryId);

            await dishRepo.AddNodeAsync(dish);
            await dishRepo.RelateNodesAsync(new ContainsDish() { NodeFrom = category, NodeTo = dish});

            dish.Images = await LoadImagesToDir(inputData.ImagesFiles, category.LinkName, dish.Id.ToString());
            if(dish.Images.Count != 0)
            {
                await dishRepo.UpdateNodeAsync(dish);
            }

            return Ok(dish.Id);
        }

        private async Task<List<string>> LoadImagesToDir(IFormFileCollection? files, string categoryLinkName, string dishId)
        {
            var images = new List<string>();

            var pathToPublicClientAppDirectory = _configuration.GetSection("ClientAppSettings:PathToPublicSourceDirecroty").Value;
            var dirWithDishImages = _configuration.GetSection("ClientAppSettings:DirectoryWithDishImages").Value;

            var pathToDishDir = ServiceRegistration.PathToDirWithDish(pathToPublicClientAppDirectory, dirWithDishImages, categoryLinkName, dishId);

            if (!Directory.Exists(pathToDishDir))
                Directory.CreateDirectory(pathToDishDir);

            if (files != null)
            {
                foreach (var imageFile in files)
                {
                    var pathToImage = Path.Combine(pathToDishDir, imageFile.FileName);
                    using var fileStream = new FileStream(pathToImage, FileMode.Create);
                    await imageFile.CopyToAsync(fileStream);

                    images.Add(ServiceRegistration.ConvertFromIOPathToInternetPath_DirWithDish(pathToPublicClientAppDirectory, pathToImage));
                }
            }

            return images;
        }
    }
}

AuthController.cs
using DbManager.Data;
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using DbManager.Neo4j.Interfaces;
using DbManager.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace WepPartDeliveryProject.Controllers
{
    [Route("[controller]")]
    [ApiController]
    public class AuthController : ControllerBase
    {
        private readonly IRepositoryFactory _repositoryFactory;
        private readonly IPasswordService _pswService;
        private readonly JwtService _jwtService;

        public AuthController(IRepositoryFactory repositoryFactory, IPasswordService passwordService, JwtService jwtService)
        {
            _repositoryFactory = repositoryFactory;
            _pswService = passwordService;
            _jwtService = jwtService;
        }

        private void AddCookieDataToResponse(string RefreshToken, string? userId = null)
        {
            if(userId != null) 
            {
                Response.Cookies.Append("X-UserId", userId,
                            new CookieOptions() { HttpOnly = true, Secure = true, Expires = DateTime.Now.AddDays(60), SameSite = SameSiteMode.None });
            }

            Response.Cookies.Append("X-Refresh-Token", RefreshToken,
                        new CookieOptions() { HttpOnly = true, Secure = true, Expires = DateTime.Now.AddDays(60), SameSite = SameSiteMode.None });

        }

        [HttpPost("login")]
        public async Task<IActionResult> Login(UserLoginInDTO data)
        {
            var users = await _repositoryFactory.GetRepository<User>().GetNodesByPropertyAsync("Login", new[] { data.Login });
            if(users.Count != 1)
            {
                return BadRequest("Вы ввели не верный логин");
            }

            var user = users[0];

            if (user.IsBlocked)
            {
                return BadRequest("Ваш аккаунт был заблокирован!");
            }

            if(_pswService.CheckPassword(data.Login, data.Password, user.PasswordHash.ToArray()))
            {
                user.RefreshToken = Guid.NewGuid();
                user.RefreshTokenCreated = DateTime.Now;

                await _repositoryFactory.GetRepository<User>().UpdateNodesPropertiesAsync(user);

                AddCookieDataToResponse(user.RefreshToken.ToString(), user.Id.ToString());

                return Ok();
            }

            return Unauthorized("Вы ввели не верный логин или пароль");
        }

        [HttpPost("refreshAccessToken")]
        public async Task<IActionResult> RefreshAccessToken()
        {
            var userRepo = (IUserRepository)_repositoryFactory.GetRepository<User>(true);

            var userId = Request.Cookies["X-UserId"];
            if (userId == null)
                return BadRequest("У вас отсутсвует refresh token. Вам необходимо авторизоваться или зарегистрироваться.");

            var inputRefreshToken = Request.Cookies["X-Refresh-Token"];

            var userNode = await userRepo.GetNodeAsync(userId);

            if (userNode.IsBlocked)
                return BadRequest("Ваш аккаунт был заблокирован!");

            if (inputRefreshToken == userNode.RefreshToken.ToString() && userNode.RefreshTokenCreated.AddDays(60) > DateTime.Now)
            {
                var userRoles = await userRepo.GetUserRoles(userId);

                var jwtTokenInfo = _jwtService.GenerateAccessJwtToken(userId, userRoles);

                userNode.RefreshTokenCreated = DateTime.Now;

                await userRepo.UpdateNodesPropertiesAsync(userNode);

                AddCookieDataToResponse(userNode.RefreshToken.ToString());
                
                return Ok(jwtTokenInfo);
            }

            return BadRequest("You refresh token don't work. You need to login or signup to system");
        }

        [HttpPost("signup")]
        public async Task<IActionResult> Signup(UserSignupInDTO data)
        {
            var user = new User() { 
                Login = data.Login, 
                Name = data.Name,
                Born = data.Born,
                Address = data.Address,
                PhoneNumber = data.PhoneNumber,
                RefreshToken = Guid.NewGuid(), 
                RefreshTokenCreated = DateTime.Now, 
                PasswordHash = _pswService.GetPasswordHash(data.Login, data.Password).ToList(), 
            };

            await _repositoryFactory.GetRepository<User>().AddNodeAsync(user);
            await _repositoryFactory.GetRepository<User>().SetNewNodeType<Client>(user.Id.ToString());

            AddCookieDataToResponse(user.RefreshToken.ToString(), user.Id.ToString());

            return Ok();
        }

        [Authorize]
        [HttpPost("logout")]
        public async Task<IActionResult> Logout()
        {
            Response.Cookies.Delete("X-UserId",
                        new CookieOptions() { HttpOnly = true, Secure = true, Expires = DateTime.Now.AddDays(60), SameSite = SameSiteMode.None });
            Response.Cookies.Delete("X-Refresh-Token",
                        new CookieOptions() { HttpOnly = true, Secure = true, Expires = DateTime.Now.AddDays(60), SameSite = SameSiteMode.None });

            return Ok();
        }
    }
}

DeliveryManController.cs
using AutoMapper;
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Data;
using DbManager.Neo4j.Interfaces;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace WepPartDeliveryProject.Controllers
{
    [Authorize(Roles = "DeliveryMan")]
    [Route("[controller]")]
    [ApiController]
    public class DeliveryManController : Controller
    {
        private readonly IRepositoryFactory _repositoryFactory;
        private readonly ApplicationSettings _appSettings;
        private readonly IMapper _mapper;

        public DeliveryManController(IRepositoryFactory repositoryFactory, IConfiguration configuration, IMapper mapper)
        {
            // Fetch settings object from configuration
            _appSettings = new ApplicationSettings();
            configuration.GetSection("ApplicationSettings").Bind(_appSettings);

            _repositoryFactory = repositoryFactory;
            _mapper = mapper;
        }

        [HttpGet("getOrders")]
        public async Task<IActionResult> GetOrderQueue(int page = 0, int numberOfState = 1)
        {
            var userId = Request.Cookies["X-UserId"];
            if (userId == null)
            {
                return BadRequest("You don't have refresh token. You need to login or signup to system");
            }

            var orderRepo = (IOrderRepository)_repositoryFactory.GetRepository<Order>(true);

            var delMan = await _repositoryFactory.GetRepository<DeliveryMan>().GetNodeAsync(userId);

            var orders = await orderRepo.GetOrdersByStateRelatedWithNode<DeliveryMan>(delMan.Id.ToString(), (OrderStateEnum)numberOfState, _appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1);

            var ordersOut = _mapper.Map<List<OrderOutDTO>>(orders);

            var pageEnded = ordersOut.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            return Ok(new { orders = ordersOut.GetRange(0, ordersOut.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage : ordersOut.Count), pageEnded });
        }
    }
}

KitchenController.cs
using AutoMapper;
using DbManager.Data;
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.Interfaces;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace WepPartDeliveryProject.Controllers
{
    [Authorize(Roles = "KitchenWorker")]
    [Route("[controller]")]
    [ApiController]
    public class KitchenController : Controller
    {
        private readonly IRepositoryFactory _repositoryFactory;
        private readonly ApplicationSettings _appSettings;
        private readonly IMapper _mapper;

        public KitchenController(IRepositoryFactory repositoryFactory, IConfiguration configuration, IMapper mapper)
        {
            // Fetch settings object from configuration
            _appSettings = new ApplicationSettings();
            configuration.GetSection("ApplicationSettings").Bind(_appSettings);

            _repositoryFactory = repositoryFactory;
            _mapper = mapper;
        }

        [HttpGet("getOrders")]
        public async Task<IActionResult> GetOrderQueue(int page = 0, int numberOfState = 1)
        {
            var userId = Request.Cookies["X-UserId"];
            if (userId == null)
            {
                return BadRequest("You don't have refresh token. You need to login or signup to system");
            }

            var orderRepo = (IOrderRepository)_repositoryFactory.GetRepository<Order>(true);

            var workedIns = await _repositoryFactory.GetRepository<KitchenWorker>().GetRelationsOfNodesAsync<WorkedIn, Kitchen>(userId);
            var kitchen = (Kitchen)workedIns.FirstOrDefault().NodeTo;

            var orders = await orderRepo.GetOrdersByStateRelatedWithNode<Kitchen>(kitchen.Id.ToString(), (OrderStateEnum)numberOfState, _appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1);

            var ordersOut = _mapper.Map<List<OrderOutDTO>>(orders);

            var pageEnded = ordersOut.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            return Ok(new { orders = ordersOut.GetRange(0, ordersOut.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage : ordersOut.Count), pageEnded });
        }

        [HttpGet("getWorkers")]
        public async Task<IActionResult> GeWorkers()
        {
            var userId = Request.Cookies["X-UserId"];
            if (userId == null)
            {
                return BadRequest("You don't have refresh token. You need to login or signup to system");
            }

            var workedIns = await _repositoryFactory.GetRepository<KitchenWorker>().GetRelationsOfNodesAsync<WorkedIn, Kitchen>(userId);
            var kitchen = (Kitchen)workedIns.FirstOrDefault().NodeTo;

            var kitchenWorkers = await _repositoryFactory.GetRepository<Kitchen>().GetRelationsOfNodesAsync<WorkedIn, KitchenWorker>(kitchen);

            var kitchenWorkersOut = _mapper.Map<List<KitchenWorkerOutDTO>>(kitchenWorkers.Select(h=>(KitchenWorker)h.NodeFrom).ToList());

            for (int i = 0; i < kitchenWorkersOut.Count; i++)
            {
                if(kitchenWorkersOut[i].Id == kitchenWorkers[i].NodeFromId)
                {
                    kitchenWorkersOut[i].GotJob = kitchenWorkers[i].GotJob;
                }
            }

            return Ok(kitchenWorkersOut);
        }
    }
}

MainController.cs
using AutoMapper;
using DbManager;
using DbManager.Data;
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.DataGenerator;
using DbManager.Neo4j.Implementations;
using DbManager.Neo4j.Interfaces;
using DbManager.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;
using Swashbuckle.AspNetCore.SwaggerGen;

namespace WepPartDeliveryProject.Controllers
{
    [Route("[controller]")]
    [ApiController]
    public class MainController : ControllerBase
    {
        private readonly IRepositoryFactory _repositoryFactory;
        private readonly ApplicationSettings _appSettings;
        private readonly IMapper _mapper;
        private readonly int countCharInDishDescription = 160;

        public MainController(IRepositoryFactory repositoryFactory, IConfiguration configuration, IMapper mapper)
        {
            // Fetch settings object from configuration
            _appSettings = new ApplicationSettings();
            configuration.GetSection("ApplicationSettings").Bind(_appSettings);

            _repositoryFactory = repositoryFactory;
            _mapper = mapper;
        }

        [HttpGet("getDishesForMainPage")]
        public async Task<IActionResult> GetDishesForMainPage(int page = 0)
        {
            //обычному пользователю не должен быть доступен удаленный или недоступный продукт
            var dishes = await _repositoryFactory.GetRepository<Dish>().GetNodesAsync(_appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1, "Name");

            var pageEnded = dishes.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            PrepareDish(dishes);

            return Ok(new { dishes = dishes.GetRange(0, dishes.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage : dishes.Count), pageEnded });
        }

        [HttpGet("getOrderStates")]
        public async Task<IActionResult> GetOrderStates()
        {
            var states = _mapper.Map<List<OrderStateItemOutDTO>>(OrderState.OrderStatesFromDb);

            return Ok(states);
        }

        [HttpGet("getCategoriesList")]
        public IActionResult GetCategoriesList()
        {
            var categories = Category.CategoriesFromDb;
            return Ok(categories);
        }

        [HttpGet("getDishIds")]
        public async Task<IActionResult> GetDishIds()
        {
            var dishIds = (await _repositoryFactory.GetRepository<Dish>().GetNodesAsync()).Select(h=>h.Id).ToList();
            return Ok(dishIds);
        }

        [HttpGet("getDish/{id}")]
        public async Task<IActionResult> GetDish(Guid id)
        {
            var dish = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(id);

            var userId = Request.Cookies["X-UserId"];
            if (userId != null)
            {
                if (dish.IsDeleted || !dish.IsAvailableForUser)
                {
                    return BadRequest("Данный продукт был скрыт или удален");
                }
            }

            return Ok(dish);
        }

        [HttpGet("getDishAbilityInfo/{id}")]
        public async Task<IActionResult> GetDishAbilityInfo(Guid id)
        {
            var dish = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(id);

            var userCanAbilityToViewDish = !dish.IsDeleted && dish.IsAvailableForUser;

            return Ok(userCanAbilityToViewDish);
        }

        [HttpGet("getDishesList/{category}")]
        public async Task<IActionResult> GetDishesList(string category)
        {
            var choicedCategory = Category.CategoriesFromDb.Single(h=>h.LinkName == category);
            var categoryDishes = await _repositoryFactory.GetRepository<Category>().GetRelationsOfNodesAsync<ContainsDish, Dish>(choicedCategory, orderByProperty: "Name");

            var dishes = categoryDishes.Select(h => (Dish)h.NodeTo).ToList();

            PrepareDish(dishes);

            return Ok(dishes);
        }

        [HttpGet("getSearchedDishes")]
        public async Task<IActionResult> GetCart(string searchText, int page = 0)
        {
            //обычному пользователю не должен быть доступен удаленный или недоступный продукт
            var dishes = await ((IDishRepository)_repositoryFactory.GetRepository<Dish>(true))
                .SearchDishesByNameAndDescription(searchText, _appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1, "Name");

            var pageEnded = dishes.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            PrepareDish(dishes);

            return Ok(new { dishes = dishes.GetRange(0, dishes.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage: dishes.Count), pageEnded});
        }

        [Authorize]
        [HttpGet("getProfileInfo")]
        public async Task<IActionResult> GetProfileInfo()
        {
            var userId = Request.Cookies["X-UserId"];
            if (userId == null)
            {
                return BadRequest("You don't have refresh token. You need to login or signup to system");
            }

            var user = _mapper.Map<ProfileUserOutDTO>(await _repositoryFactory.GetRepository<User>().GetNodeAsync(userId));

            return Ok(user);
        }

        private void PrepareDish(List<Dish> dishes)
        {
            for (int i = 0; i < dishes.Count; i++)
            {
                var dish = dishes[i];
                if (dish.IsDeleted || !dish.IsAvailableForUser)
                {
                    dishes.Remove(dish);
                    i--;
                }
                else if (dish.Description.Length > countCharInDishDescription)
                    dish.Description = dish.Description.Substring(0, countCharInDishDescription - 3) + "...";
            }
        }
    }
}
 
OrderController.cs
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using DbManager.Neo4j.Interfaces;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using DbManager.Data.Relations;
using AutoMapper;
using DbManager.Data;
using System.Xml.Linq;

namespace WepPartDeliveryProject.Controllers
{
    [Authorize]
    [Route("[controller]")]
    [ApiController]
    public class OrderController : Controller
    {
        private readonly IRepositoryFactory _repositoryFactory;
        private readonly ApplicationSettings _appSettings;
        private readonly IMapper _mapper;
        private readonly JwtService _jwtService;

        public OrderController(IRepositoryFactory repositoryFactory, IConfiguration configuration, IMapper mapper, JwtService jwtService)
        {
            // Fetch settings object from configuration
            _appSettings = new ApplicationSettings();
            configuration.GetSection("ApplicationSettings").Bind(_appSettings);

            _repositoryFactory = repositoryFactory;
            _mapper = mapper;
            _jwtService = jwtService;
        }

        [AllowAnonymous]
        [HttpGet("getCart")]
        public async Task<IActionResult> GetCart()
        {
            var jsonData = Request.Cookies["cartDishes"];

            var res = jsonData != null ? JsonConvert.DeserializeObject<Dictionary<string, int>>(jsonData) : new Dictionary<string, int>();

            var dishes = await _repositoryFactory.GetRepository<Dish>().GetNodesByPropertyAsync("Id", res.Keys.ToArray());

            return Ok(dishes);
        }

        [AllowAnonymous]
        [HttpPost("placeAnOrder")]
        public async Task<IActionResult> PlaceAnOrder(PlaceAnOrderInDTO inputData)
        {
            var jsonData = Request.Cookies["cartDishes"];
            var userId = Request.Cookies["X-UserId"];

            var res = jsonData != null ? JsonConvert.DeserializeObject<Dictionary<string, int>>(jsonData) : new Dictionary<string, int>();
            if (res.Count == 0)
                return BadRequest("При оформлении заказа, в корзине отсутсвовали продукты");

            var dishes = await _repositoryFactory.GetRepository<Dish>().GetNodesByPropertyAsync("Id", res.Keys.ToArray());

            var order = new Order() { 
                SumWeight = dishes.Sum(h=>h.Weight), 
                Price = dishes.Sum(h => h.Price), 
                DeliveryAddress = inputData.DeliveryAddress, 
                PhoneNumber = inputData.PhoneNumber };

            var orderRepo = (IOrderRepository)_repositoryFactory.GetRepository<Order>(true);

            await orderRepo.AddNodeAsync(order);

            var kitchens = await _repositoryFactory.GetRepository<Kitchen>().GetNodesAsync();
            var randomKitchen = kitchens[new Random().Next(0, kitchens.Count)];

            var deliveryMen = await _repositoryFactory.GetRepository<DeliveryMan>().GetNodesAsync();
            var randomdelMan = deliveryMen[new Random().Next(0, deliveryMen.Count)];

            await orderRepo.CreateOrderRelationInDB(order, userId, dishes, randomKitchen, randomdelMan, res, inputData.Comment);

            return Ok();
        }

        [Authorize(Roles = "Admin")]
        [HttpPost("changeCountOrderedDish")]
        public async Task<IActionResult> ChangeCountOrderedDish(ManipulateOrderDataInDTO inputData)
        {
            var order = await _repositoryFactory.GetRepository<Order>().GetNodeAsync(inputData.OrderId);

            var dish = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(inputData.DishId);

            var orderedDish = await _repositoryFactory.GetRepository<Dish>().GetRelationBetweenTwoNodesAsync<OrderedDish, Order>(dish, order);

            order.Price -= orderedDish.Count * dish.Price;

            orderedDish.Count = (int)inputData.NewCount;

            order.Price += orderedDish.Count * dish.Price;

            await _repositoryFactory.GetRepository<Order>().UpdateNodeAsync(order);

            await _repositoryFactory.GetRepository<Order>().UpdateRelationNodesAsync(orderedDish);

            return Ok();
        }

        [HttpGet("getClientOrders")]
        public async Task<IActionResult> GetClientOrders(int page = 0, int numberOfState = 1)
        {
            var userId = Request.Cookies["X-UserId"];
            if (userId == null)
            {
                return BadRequest("You don't have refresh token. You need to login or signup to system");
            }

            var orderRepo = (IOrderRepository)_repositoryFactory.GetRepository<Order>(true);

            var orders = await orderRepo.GetOrdersByStateRelatedWithNode<Client>(userId, (OrderStateEnum)numberOfState, _appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1);

            var ordersOut = _mapper.Map<List<OrderOutDTO>>(orders);

            var pageEnded = ordersOut.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            return Ok(new { orders = ordersOut.GetRange(0, ordersOut.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage : ordersOut.Count), pageEnded });
        }

        [HttpGet("getOrder/{orderId}")]
        public async Task<IActionResult> GetOrder(string orderId)
        {
            Order? searchedOrder;
            if (_jwtService.UserHasRole(Request.Headers.Authorization.FirstOrDefault(), "Admin") 
                || _jwtService.UserHasRole(Request.Headers.Authorization.FirstOrDefault(), "KitchenWorker")
                || _jwtService.UserHasRole(Request.Headers.Authorization.FirstOrDefault(), "DeliveryMan"))
            {
                searchedOrder = await _repositoryFactory.GetRepository<Order>().GetNodeAsync(orderId);
            }
            else
            {
                var userId = Request.Cookies["X-UserId"];

                if (userId == null)
                {
                    return BadRequest("You don't have refresh token. You need to login or signup to system");
                }

                var ordereds = await _repositoryFactory.GetRepository<Client>().GetRelationsOfNodesAsync<Ordered, Order>(userId);
                searchedOrder = (Order)ordereds.SingleOrDefault(h => h.NodeToId.ToString() == orderId)?.NodeTo;
            }

            if (searchedOrder != null)
            {
                var reviewedOrder = await _repositoryFactory.GetRepository<Order>().GetRelationsOfNodesAsync<ReviewedBy, Client>(searchedOrder);
                var orderedDishes = await _repositoryFactory.GetRepository<Order>().GetRelationsOfNodesAsync<OrderedDish, Dish>(searchedOrder);

                var preparedOrder = _mapper.Map<OrderOutDTO>(searchedOrder);
                if(reviewedOrder.Count != 0)
                    _mapper.Map(reviewedOrder[0], preparedOrder);
                preparedOrder.Story = _mapper.Map<List<OrderStateItemOutDTO>>(searchedOrder.Story);

                return Ok(new { order = preparedOrder, orderedDishes = orderedDishes.Select(h=> new {count = h.Count, dishInfo = h.NodeTo}) });
            }

            return BadRequest("Запрашиваемый заказ не доступен данному пользователю или не существует");
        }

        [Authorize(Roles = "Admin")]
        [HttpPost("cancelOrderedDish")]
        public async Task<IActionResult> CancelOrderedDish(ManipulateOrderDataInDTO inputData)
        {
            var order = await _repositoryFactory.GetRepository<Order>().GetNodeAsync(inputData.OrderId);

            var dish = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(inputData.DishId);

            var orderedDish = await _repositoryFactory.GetRepository<Dish>().GetRelationBetweenTwoNodesAsync<OrderedDish, Order>(dish, order);

            order.Price -= orderedDish.Count * dish.Price;

            await _repositoryFactory.GetRepository<Order>().UpdateNodeAsync(order);

            await _repositoryFactory.GetRepository<Order>().DeleteRelationOfNodesAsync<OrderedDish, Dish>(order, dish);

            return Ok();
        }

        [Authorize(Roles = "Admin, Client")]
        [HttpPost("cancelOrder")]
        public async Task<IActionResult> CancelOrder(ManipulateOrderDataInDTO inputData)
        {
            var orderRepo = _repositoryFactory.GetRepository<Order>();

            var order = await orderRepo.GetNodeAsync(inputData.OrderId);
            var orderHasState = order.Story.Last();
            var orderState = OrderState.OrderStatesFromDb.Single(h => h.Id == orderHasState.NodeToId);

            await orderRepo.DeleteRelationOfNodesAsync<HasOrderState, OrderState>(order, orderState);

            var cancelState = OrderState.OrderStatesFromDb.First(h => h.NumberOfStage == (int)OrderStateEnum.Cancelled);
            var relationCancel = new HasOrderState() { Comment = inputData.ReasonOfCancel, NodeFromId = order.Id, NodeToId = cancelState.Id, TimeStartState = DateTime.Now };

            order.Story.Add(relationCancel);
            await orderRepo.RelateNodesAsync(relationCancel);
            await orderRepo.UpdateNodeAsync(order);

            return Ok();
        }

        [Authorize(Roles = "Admin, KitchenWorker, DeliveryMan")]
        [HttpPost("moveToNextStage")]
        public async Task<IActionResult> MoveToNextStage(ManipulateOrderDataInDTO inputData)
        {
            var orderRepo = (IOrderRepository) _repositoryFactory.GetRepository<Order>(true);
            var newHasOrderState = await orderRepo.MoveOrderToNextStage(inputData.OrderId, "Изменено администрацией");

            if(newHasOrderState != null){
                return Ok(_mapper.Map<OrderStateItemOutDTO>(newHasOrderState));
            }
            return BadRequest("Заказ находится на финальной стадии и его состояние не может перейти на следующую стадию");
        }

        [Authorize(Roles = "Admin, KitchenWorker")]
        [HttpPost("moveToPreviousStage")]
        public async Task<IActionResult> MoveToPreviousStage(ManipulateOrderDataInDTO inputData)
        {
            var orderRepo = (IOrderRepository)_repositoryFactory.GetRepository<Order>(true);
            if (await orderRepo.MoveOrderToPreviousStage(inputData.OrderId))
                return Ok();
            return BadRequest("Заказ находится на начальной стадии и его состояние не может перейти на предыдущую стадию");
        }

        [Authorize(Roles = "Client")]
        [HttpPost("reviewOrder")]
        public async Task<IActionResult> ReviewOrder(ReviewOrderInDTO inputData)
        {
            var userId = Request.Cookies["X-UserId"];
            if (userId == null)
            {
                return BadRequest("You don't have refresh token. You need to login or signup to system");
            }

            var orderRepo = _repositoryFactory.GetRepository<Order>();

            var reviews = await orderRepo.GetRelationBetweenTwoNodesAsync<ReviewedBy, Client>(new Order() { Id = Guid.Parse(inputData.OrderId) }, new Client() { Id = Guid.Parse(userId) });
            if(reviews != null)
            {
                return BadRequest("Вы уже оставили отзыв о данном заказе");
            }

            var reviewRelation = new ReviewedBy()
            {
                NodeFromId = Guid.Parse(userId),
                NodeToId = Guid.Parse(inputData.OrderId),
                Review = inputData.Review,
                ClientRating = inputData.ClientRating,
                TimeCreated = DateTime.Now,
            };

            await orderRepo.RelateNodesAsync(reviewRelation);

            return Ok();
        }
    }
}

StatisticController.cs
using DbManager.Data.DTOs;
using DbManager.Data;
using DbManager.Neo4j.Interfaces;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using DbManager.Data.Nodes;
using AutoMapper;
using DbManager.Data.Relations;

namespace WepPartDeliveryProject.Controllers
{
    [Authorize(Roles = "Admin")]
    [Route("[controller]")]
    [ApiController]
    public class StatisticController : Controller
    {
        private readonly IRepositoryFactory _repositoryFactory;
        private readonly ApplicationSettings _appSettings;
        private readonly IMapper _mapper;

        public StatisticController(IRepositoryFactory repositoryFactory, IConfiguration configuration, IMapper mapper)
        {
            // Fetch settings object from configuration
            _appSettings = new ApplicationSettings();
            configuration.GetSection("ApplicationSettings").Bind(_appSettings);

            _repositoryFactory = repositoryFactory;
            _mapper = mapper;
        }

        public static List<StatisticQueryInfoOutDTO> Statistics { get; } = new List<StatisticQueryInfoOutDTO>()
        {
            new StatisticQueryInfoOutDTO(){ NameQuery = "Количество и суммарная стоимость заказов по месяцам",                      LinkToQuery = "query1", ChartName = "line", NeedDataRange = true, NameDatasets = new List<string>(){ "Стоимость заказов", "Количество заказов" } },
            new StatisticQueryInfoOutDTO(){ NameQuery = "Топ-10 клиентов по стоимости заказов",                                     LinkToQuery = "query2", ChartName = "line", NeedDataRange = true, NameDatasets = new List<string>(){ "Стоимость заказов", "Количество заказов" } },
            new StatisticQueryInfoOutDTO(){ NameQuery = "Топ доставщиков по количеству заказов",                                    LinkToQuery = "query3", ChartName = "line", NeedDataRange = true},
            new StatisticQueryInfoOutDTO(){ NameQuery = "Количество отмененных заказов на каждой стадии",                           LinkToQuery = "query4", ChartName = "radar",NeedDataRange = true},
            new StatisticQueryInfoOutDTO(){ NameQuery = "Сколько в среднем клиенты оформляют заказов, если оформляют",              LinkToQuery = "query5", ChartName = "bar",  NeedDataRange = true, NameDatasets = new List<string>(){ "Количество заказов", "Количество клиентов, оформивших заказы" } },
            new StatisticQueryInfoOutDTO(){ NameQuery = "Средняя продолжительность пребывания заказа в стадии",                     LinkToQuery = "query6", ChartName = "line", NeedDataRange = true},
            new StatisticQueryInfoOutDTO(){ NameQuery = "Количество выполненных заказов и приготовленных блюд в каждой из кухонь",  LinkToQuery = "query7", ChartName = "bar",  NeedDataRange = true, NameDatasets = new List<string>(){ "Количество выполненных заказов", "Количество приготовленных блюд" } },
            new StatisticQueryInfoOutDTO(){ NameQuery = "Топ-10 самых популярных блюд",                                             LinkToQuery = "query8", ChartName = "line", NeedDataRange = true},
        };

        [AllowAnonymous]
        [HttpGet("getStatisticQueries")]
        public IActionResult GetStatisticQueries()
        {
            return Ok(Statistics);
        }

        [HttpGet("query1")]
        public async Task<IActionResult> GetQuery1()
        {
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var resData = await ((IOrderRepository)_repositoryFactory.GetRepository<Order>(true)).GetOrderPriceAndCountStatistic();

            foreach (var item in resData)
            {
                resQueryData.Add(new StatisticQueryDataItemOutDTO() { Y = new List<double>() { item.Item2, item.Item3 }, X = item.Item1 });
            }

            return Ok(resQueryData);
        }

        [HttpGet("query2")]
        public async Task<IActionResult> GetQuery2()
        {
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var clientRepo = (IClientRepository)_repositoryFactory.GetRepository<Client>(true);

            var topClients = await clientRepo.GetTopClientBySumPriceOrderStatistic(10);
            topClients.Reverse();

            foreach (var item in topClients)
            {
                resQueryData.Add(new StatisticQueryDataItemOutDTO() { Y = new List<double>() { item.Item2, item.Item3 }, X = item.Item1.Login });
            }

            return Ok(resQueryData);
        }

        [HttpGet("query3")]
        public async Task<IActionResult> GetQuery3()
        {
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var delManRepo = (IDeliveryManRepository)_repositoryFactory.GetRepository<DeliveryMan>(true);

            var topDelMen = await delManRepo.GetTopDeliveryMenByCountOrder(10);
            topDelMen.Reverse();

            foreach (var item in topDelMen)
            {
                resQueryData.Add(new StatisticQueryDataItemOutDTO() { Y = new List<double>() { item.Item2 }, X = item.Item1.Name });
            }

            return Ok(resQueryData);
        }

        [HttpGet("query4")]
        public async Task<IActionResult> GetQuery4()
        {
            //месяц только для диапазона, выводиться будет как название dataset
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var resData = await ((IOrderRepository)_repositoryFactory.GetRepository<Order>(true)).GetCancelledOrderGroupedByMonthStatistic();

            var nameDatasets = new List<string>();

            for (int i = 0; i < resData.Count; i++)
            {
                nameDatasets.Add(resData[i].Item1);

                foreach (var order in resData[i].Item2)
                {
                    var previousHasOrderState = order.Story[order.Story.Count - 2];
                    previousHasOrderState.NodeTo = OrderState.OrderStatesFromDb.Find(el => el.Id == previousHasOrderState.NodeToId);
                    var previousNameOfState = ((OrderState)previousHasOrderState.NodeTo).NameOfState;
                    var dataItem = resQueryData.Find(el => el.X == previousNameOfState);

                    if(dataItem == null)
                    {
                        dataItem = new StatisticQueryDataItemOutDTO() { Y = new List<double>(), X = previousNameOfState };
                        resQueryData.Add(dataItem);
                    }

                    foreach (var item in resQueryData)
                    {
                        while (item.Y.Count != i + 1)
                            item.Y.Add(0);
                    }

                    dataItem.Y[i]++;
                }

                
            }

            return Ok(new { queryData = resQueryData, nameDatasets });
        }

        [HttpGet("query5")]
        public async Task<IActionResult> GetQuery5()
        {
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var resData = await ((IOrderRepository)_repositoryFactory.GetRepository<Order>(true)).GetCountFinishedOrderAndClientsStatistic();

            foreach (var item in resData)
            {
                resQueryData.Add(new StatisticQueryDataItemOutDTO() { Y = new List<double>() { item.Item2, item.Item3 }, X = item.Item1 });
            }

            return Ok(resQueryData);
        }

        [HttpGet("query6")]
        public async Task<IActionResult> GetQuery6()
        {
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var resData = await ((IOrderRepository)_repositoryFactory.GetRepository<Order>(true)).GetNodesAsync(limitCount:100);

            for (int i = 0, j = 1; i < OrderState.OrderStatesFromDb.Count; i++, j *= 2)
            {
                if (j == (int)OrderStateEnum.Cancelled || j == (int)OrderStateEnum.Finished)
                {
                    break;
                }
                var curState = OrderState.OrderStatesFromDb.First(h => h.NumberOfStage == j);

                var orderMinutesBetweenCurStateAndNext = new List<int>();
                var needRemoveOrders = new List<Order>();
                foreach (var order in resData)
                {
                    //количество состояний в истории должно быть на одну больше чем нужно, чтобы было ОТ и ДО
                    if(order.Story.Count > i + 1)
                    {
                        orderMinutesBetweenCurStateAndNext.Add((order.Story[i+1].TimeStartState - order.Story[i].TimeStartState).Minutes);
                    }
                    else
                    {
                        //удаляем потому что нам известно, что эти заказы закончились на текущей стадии
                        needRemoveOrders.Add(order);
                    }
                }

                resData = resData.Except(needRemoveOrders).ToList();

                resQueryData.Add(new StatisticQueryDataItemOutDTO() { Y = new List<double>() { orderMinutesBetweenCurStateAndNext.Sum()/ orderMinutesBetweenCurStateAndNext.Count }, X = curState.NameOfState });
            }

            return Ok(resQueryData);
        }

        [HttpGet("query7")]
        public async Task<IActionResult> GetQuery7()
        {
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var resData = await ((IOrderRepository)_repositoryFactory.GetRepository<Order>(true)).GetCountOrdersAndOrderedDishesForEveryKitchenStatistic();

            foreach (var item in resData)
            {
                resQueryData.Add(new StatisticQueryDataItemOutDTO() { Y = new List<double>() { item.Item2, item.Item3 }, X = item.Item1.Address });
            }

            return Ok(resQueryData);
        }

        [HttpGet("query8")]
        public async Task<IActionResult> GetQuery8()
        {
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var dishRepo = (IDishRepository)_repositoryFactory.GetRepository<Dish>(true);

            var topDish = await dishRepo.GetTopDishByCountOrderedStatistic(10);
            topDish.Reverse();

            foreach (var item in topDish)
            {
                resQueryData.Add(new StatisticQueryDataItemOutDTO() { Y = new List<double>() { item.Item2 }, X = item.Item1.Name });
            }

            return Ok(resQueryData);
        }
    }
}

JwtService.cs
using AutoMapper.Configuration.Annotations;
using DbManager.Data.DTOs;
using DbManager.Neo4j.Interfaces;
using Microsoft.IdentityModel.Tokens;
using Newtonsoft.Json.Linq;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using WepPartDeliveryProject;

public class JwtService
{
    private readonly ApplicationSettings _appSettings;

    public JwtService(IConfiguration configuration)
    {
        // Fetch settings object from configuration
        _appSettings = new ApplicationSettings();
        configuration.GetSection("ApplicationSettings").Bind(_appSettings);
    }

    public JwtTokenInfoOutDTO GenerateAccessJwtToken(string userId, List<string> roles)
    {
        var secretKey = Encoding.ASCII.GetBytes(_appSettings.JwtSecretKey);

        var tokenHandler = new JwtSecurityTokenHandler();
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new Claim[]
            {
                new Claim(ClaimTypes.Sid, userId),
            }),
            Expires = DateTime.Now.AddMinutes(30), // Время истечения токена
            SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(secretKey), SecurityAlgorithms.HmacSha256Signature)
        };
        foreach (var role in roles)
        {
            tokenDescriptor.Subject.AddClaim(new Claim(ClaimTypes.Role, role));
        }

        var token = tokenHandler.CreateToken(tokenDescriptor);
        var tokenString = tokenHandler.WriteToken(token);

        return new JwtTokenInfoOutDTO { JwtToken = tokenString, ValidTo = token.ValidTo, RoleNames = roles };
    }

    public bool UserHasRole(string? jwtToken, string roleName)
    {
        if(jwtToken== null)
            return false;

        var clearJwtToken = jwtToken.Replace("Bearer ", "");
        var tokenHandler = new JwtSecurityTokenHandler();
        var token = tokenHandler.ReadJwtToken(clearJwtToken);

        var userRolesName = token.Claims.Where(h => h.Type == "role").ToList();

        if (userRolesName.Any(h=>h.Value == roleName))
        {
            return true;
        }

        return false;
    }
}

cart.tsx
import Head from 'next/head'
import { FC, useEffect, useState } from "react"
import ClientLayout from '@/components/structure/ClientLayout'
import { GetStaticProps } from 'next'
import DishCartCard from '@/components/cards/DishCartCard'
import { useCookies } from 'react-cookie'
import PlaceAnOrderModal from '@/components/models/PlaceAnOrderModal'
import { stringify } from 'querystring'

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories
        }
    }
}

const Cart: FC<{ categories: categoryItem[] }> = ({ categories }) => {
    const [dishes, setDishes] = useState<dishClientInfo[]>([]);
    const [cookies, setCookie, removeCookie] = useCookies(['cartDishes']);

    const [show, setShow] = useState(false);

    const handleShowModal = () =>{
        setShow(true);
    }

    const handleCloseModal = () =>{
        setShow(false);
    }

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/getCart`, {
                credentials: 'include',
            });
            if(resp.ok){
                const cartDishes = await resp.json() as dishClientInfo[];
                setDishes(cartDishes);
            }
            else{
                alert(await resp.text());
            }

        }
        fetchData();
    }, []);

    const handleDeleteItem = (dishId: string): void => {
        setDishes(prevState => prevState.filter(el => el.id != dishId));
    }

    const clearList = (): void => {
        setDishes([]);
        removeCookie('cartDishes');
    }

    const handlePlaceAnOrder = async (userAddress: string, userPhoneNumber: string, comment: string) => {

        const response = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/placeAnOrder`, {
            method: "POST",
            credentials: "include",
            headers: {
                'Content-Type': 'application/json;charset=utf-8',
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            },
            body: JSON.stringify({deliveryAddress: userAddress, phoneNumber: userPhoneNumber, comment})
        });

        if (response.ok) {
            clearList();
            setShow(false);
        }
        else {
            alert(await response.text());
        }
    }

    return (
        <ClientLayout categories={categories}>
            <main className='mb-2'>
                <div>
                    {dishes.map((dish, i) => <DishCartCard key={i} {...dish} DeleteCardFromList={handleDeleteItem} />)}
                </div>
                {dishes.length != 0 ?
                    (<div>
                        <button className='btn btn-primary w-100 mt-2' onClick={handleShowModal}>
                            Оформить заказ
                        </button>
                    </div>)
                    : (
                        <div className='d-flex justify-content-center mt-5'>
                            <h2>
                                Ваша корзина пуста
                            </h2>
                        </div>
                    )
                }
            </main>
            {show && <PlaceAnOrderModal show={show} closeModel={handleCloseModal} commitAction={handlePlaceAnOrder}/>}
        </ClientLayout>
    )
}

export default Cart;
index.tsx
import Head from 'next/head'
import { FC, useState } from "react"
import ClientLayout from '@/components/structure/ClientLayout'
import { GetStaticProps } from 'next'
import DishMainCard from '@/components/cards/DishMainCard'

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const data = await resp.json() as categoryItem[];

    const resp2 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getDishesForMainPage`);
    const dishListInfo = await resp2.json() as { dishes: dishClientInfo[], pageEnded: boolean };

    return {
        props: {
            categories: data,
            dishesProps: dishListInfo.dishes,
            pageEndedProps: dishListInfo.pageEnded,
        }
    }
}

type homePageProps = {
    categories: categoryItem[],
    dishesProps: dishClientInfo[],
    pageEndedProps: boolean,
}

const Home: FC<homePageProps> = ({ categories, dishesProps, pageEndedProps }) => {
    const [dishesState, setDishesState] = useState<dishClientInfo[]>(dishesProps);
    //нулевая страница загружается при переходе на страницу
    const [page, setPage] = useState(1);
    const [pageEnded, setPageEnded] = useState(pageEndedProps);

    const handleShowMoreDishes = async () => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getDishesForMainPage?page=${page}`);

        if (resp.ok) {
            const loadedData = await resp.json() as { dishes: dishClientInfo[], pageEnded: boolean };
            setPage(page + 1);
            setDishesState(dishesState.concat(loadedData.dishes));
            setPageEnded(loadedData.pageEnded);
        }
        else {
            setPageEnded(true);
            alert(await resp.text());
        }
    }

    return (
        <ClientLayout categories={categories}>
            <Head>
                <title>Create Next App</title>
                <meta name="viewport" content="width=device-width, initial-scale=1" />
                <link rel="icon" href="/favicon.ico" />
            </Head>
            <main>
                <div>
                    {dishesState.map((dish, i) => <DishMainCard key={i} {...dish} />)}
                </div>
                {!pageEnded && (<div>
                    <button className='btn btn-primary w-100 mt-2' onClick={handleShowMoreDishes}>
                        Показать больше
                    </button>
                </div>)
                }
            </main>
        </ClientLayout>
    )
}

export default Home;
login.tsx
import { ChangeEvent, Component, FormEvent } from "react"
import Link from 'next/link'
import { Col, Form, Row, Container, Button } from "react-bootstrap";
import { NextRouter, withRouter } from "next/router";
import { AuthContext } from "@/components/contexts/AuthContext";

type LoginState = {
    login: string,
    password: string,
    success: boolean,
    errors: string[],
}

type WithRouterProps = {
    router: NextRouter
  }

class Login extends Component<WithRouterProps, LoginState> {
    declare context: React.ContextType<typeof AuthContext>
    static contextType = AuthContext; 

    state = {
        login: '',
        password: '',
        success: false,
        errors: [],
    }

    handleInputLogin = (e:ChangeEvent<HTMLInputElement>):void => {
        const inputText = e.target.value;
        this.setState({login:inputText});
    }

    handleInputPassword = (e:ChangeEvent<HTMLInputElement>):void => {
        const inputText = e.target.value;
        this.setState({password:inputText});
    }

    handleSubmit = async (e:FormEvent) => {
        e.preventDefault();

        const response = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/auth/login`, {
            method: "POST",
            credentials: "include",
            headers: {
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({login:this.state.login, password:this.state.password})
        });

        if(response.ok){
            this.context.toggleIsAuthed();
            this.props.router.push('/');
        }
        else{
            alert(await response.text());
        }
    }

    render() {
        return (
            <Container fluid={'xl'} className='mt-5 mb-5'>
                <h1>Войти</h1>
                <Form onSubmit={this.handleSubmit}>
                    <h3>Используйте данные от аккаунта dot Food для входа</h3>
                    <div className="text-danger"></div>
                    {/* {this.state.errors.map((error, i) => <p key={i}>{error}</p>)} */}
                    <Row>
                        <Col sm={10} md={6} lg={4}>
                            <Form.Group className={`mb-2`}>
                                <Form.Label>Email</Form.Label>
                                <Form.Control type="email" placeholder="Введите логин" value={this.state.login} onChange={this.handleInputLogin}/>
                                <span className="text-danger"></span>
                            </Form.Group>
                            <Form.Group className={`mb-3`}>
                                <Form.Label>Пароль</Form.Label>
                                <Form.Control type="password" placeholder="Введите пароль" value={this.state.password} onChange={this.handleInputPassword}/>
                                <span className="text-danger"></span>
                            </Form.Group>
                            <Row>
                                <Col xs={6} className="g-0 pe-1 ps-2">
                                    <Button variant="primary" type="submit" className="w-100">
                                        Войти
                                    </Button>
                                </Col>
                                <Col xs={6} className="g-0 ps-1 pe-2">
                                    <Link href={'/signup'} className="w-100">
                                        <Button variant="primary" className="w-100">
                                            Регистрация
                                        </Button>
                                    </Link>
                                </Col>
                            </Row>
                        </Col>
                    </Row>
                </Form>
            </Container>)
    }
};

export default withRouter(Login);
search.tsx
import Head from 'next/head'
import { FC, useEffect, useState } from "react"
import ClientLayout from '@/components/structure/ClientLayout'
import { GetStaticProps } from 'next'
import DishMainCard from '@/components/cards/DishMainCard'
import { useRouter } from 'next/router'

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories
        }
    }
}

const Search: FC<{ categories: categoryItem[] }> = ({ categories }) => {
    const [dishes, setDishes] = useState<dishClientInfo[]>([]);
    //нулевая страница загружается при переходе на страницу
    const [page, setPage] = useState(1);
    const [pageEnded, setPageEnded] = useState(false);

    const router = useRouter();
    const searchTextFromParam = router.query.searchText;

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getSearchedDishes?searchText=${searchTextFromParam}`);
            if (resp.ok) {
                const loadedData = await resp.json() as { dishes: dishClientInfo[], pageEnded: boolean };

                setDishes(loadedData.dishes);

                setPageEnded(loadedData.pageEnded);
            }
            else {
                alert(await resp.text());
            }
        }
        fetchData();
    }, [searchTextFromParam])

    const handleShowMoreDishes = async () => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getSearchedDishes?searchText=${searchTextFromParam}&page=${page}`);

        if (resp.ok) {
            const loadedData = await resp.json() as { dishes: dishClientInfo[], pageEnded: boolean };
            setPage(page + 1);
            setDishes(dishes.concat(loadedData.dishes));
            setPageEnded(loadedData.pageEnded);
        }
        else {
            setPageEnded(true);
            alert(await resp.text());
        }
    }

    return (
        <ClientLayout categories={categories}>
            <Head>
                <title>Create Next App</title>
                <meta name="viewport" content="width=device-width, initial-scale=1" />
                <link rel="icon" href="/favicon.ico" />
            </Head>
            <main className='mb-2'>
                <div>
                    {dishes.map((dish, i) => <DishMainCard key={i} {...dish} />)}
                </div>
                {dishes.length != 0 ?
                    (!pageEnded && (<div>
                        <button className='btn btn-primary w-100 mt-2' onClick={handleShowMoreDishes}>
                            Показать больше
                        </button>
                    </div>))
                    : (
                        <div className='d-flex justify-content-center mt-5'>
                            <h2>
                                В результате поиска не нашлось ни одного подходящего блюда
                            </h2>
                        </div>
                    )
                }
            </main>
        </ClientLayout>
    )
}

export default Search;
signup.tsx
import { ChangeEvent, Component, FormEvent } from "react"
import Link from 'next/link'
import { Col, Form, Row, Container, Button } from "react-bootstrap";
import { NextRouter, withRouter } from "next/router";
import { AuthContext } from "@/components/contexts/AuthContext";

type SignupState = {
    login: string,
    password: string,
    name: string,
    born: string,
    address: string,
    phoneNumber: string,
    secondPassword: string,
    success: boolean,
    errors: string[],
}

type WithRouterProps = {
    router: NextRouter,
}

function isValidDate(dateString:string) : boolean {
    const date:number = Date.parse(dateString);
    return !isNaN(date);
}

class Signup extends Component<WithRouterProps, SignupState> {
    declare context: React.ContextType<typeof AuthContext>
    static contextType = AuthContext; 

    state = {
        login: '',
        password: '',
        name: '',
        born: '',
        address: '',
        phoneNumber: '',
        secondPassword: '',
        success: false,
        errors: [],
    }

    handleInputData = (e: ChangeEvent<HTMLInputElement>): void => {
        const value:string = e.target.value;
        const name:string = e.target.name;
        
        this.setState(prevState => ({ ...prevState, [name]: value }));
    }

    handleSubmit = async (e:FormEvent) => {
        if(this.state.password == "" || this.state.login == "" || this.state.name == ""|| this.state.born == "" ){
            alert("Вы не заполнили все обязательные поля. Пожалуйста, заполните поля, отмеченные звездочкой")
            return;
        }
        if(this.state.password != this.state.secondPassword){
            alert("Вы ввели два разных пароля, пожалуйста, проверьте введенные пароли")
            return;
        }
        if(!isValidDate(this.state.born)){
            alert("Вы ввели не верную дату рождения, пожалуйста, проверьте введенные данные")
            return;
        }

        e.preventDefault();
        const response = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/auth/signup`, {
            method: "POST",
            credentials: "include",
            body: JSON.stringify({login:this.state.login, 
                                password:this.state.password, 
                                name: this.state.name,
                                phoneNumber: this.state.phoneNumber, 
                                address: this.state.address, 
                                born: this.state.born })
        });

        if(response.ok){
            this.context.toggleIsAuthed();
            this.props.router.push('/');
        }
        else{
            alert(await response.text());
        }
    }

    render() {
        return (
            <Container fluid={'xl'} className='mt-5 mb-5'>
                <h1>Регистрация</h1>
                <Form onSubmit={this.handleSubmit}>
                    <h3>Введите данные для аккаунта dot Food</h3>
                    <div className="text-danger">
                        {/* {this.state.errors.map((error, i) => <p key={i}>{error}</p>)} */}
                    </div>
                    <Row>
                        <Col sm={10} md={6} lg={4}>
                            <Form.Group className={`mb-2`}>
                                <Form.Label>Ваше имя<div className="text-danger d-inline">*</div></Form.Label>
                                <Form.Control type="text" placeholder="Введите свое имя" name="name" value={this.state.name} onChange={this.handleInputData}/>
                            </Form.Group>
                            <Form.Group className={`mb-2`}>
                                <Form.Label>Дата рождения<div className="text-danger d-inline">*</div></Form.Label>
                                <Form.Control type="text" placeholder="Введите свою дату рождения" name="born" value={this.state.born} onChange={this.handleInputData}/>
                            </Form.Group>
                            <Form.Group className={`mb-2`}>
                                <Form.Label>Ваш адрес</Form.Label>
                                <Form.Control type="text" placeholder="Введите свой адрес" name="address" value={this.state.address} onChange={this.handleInputData}/>
                            </Form.Group>
                            <Form.Group className={`mb-2`}>
                                <Form.Label>Ваш номер телефона</Form.Label>
                                <Form.Control type="tel" placeholder="+7" maxLength={12} name="phoneNumber" value={this.state.phoneNumber} onChange={this.handleInputData}/>
                            </Form.Group>
                            <Form.Group className={`mb-2`}>
                                <Form.Label>Email<div className="text-danger d-inline">*</div></Form.Label>
                                <Form.Control type="email" placeholder="Введите логин" name="login" value={this.state.login} onChange={this.handleInputData}/>
                            </Form.Group>
                            <Form.Group className={`mb-3`}>
                                <Form.Label>Пароль<div className="text-danger d-inline">*</div></Form.Label>
                                <Form.Control type="password" placeholder="Введите пароль" name="password" value={this.state.password} onChange={this.handleInputData}/>
                            </Form.Group>
                            <Form.Group className={`mb-3`}>
                                <Form.Label>Введите пароль еще раз<div className="text-danger d-inline">*</div></Form.Label>
                                <Form.Control type="password" placeholder="Введите пароль" name="secondePassword" value={this.state.password} onChange={this.handleInputData}/>
                            </Form.Group>
                            <Row>
                                <Col xs={6} className="g-0 pe-1 ps-2">
                                    <Button variant="primary" type="submit" className="w-100">
                                        Зарегестрироваться
                                    </Button>
                                </Col>
                                <Col xs={6} className="g-0 ps-1 pe-2">
                                    <Link href={'/login'} className="w-100">
                                        <Button variant="primary" className="w-100">
                                            Войти
                                        </Button>
                                    </Link>
                                </Col>
                            </Row>
                        </Col>
                    </Row>
                </Form>
            </Container>)
    }
};

export default withRouter(Signup);
_app.tsx
import '@/styles/globals.css'
import type { AppProps } from 'next/app'
import 'bootstrap/dist/css/bootstrap.min.css';
import { SSRProvider } from 'react-bootstrap';
import { CookiesProvider } from 'react-cookie';
import Layout from '@/components/structure/Layout';

const App = ({ Component, pageProps }: AppProps) => {

  return (
    <SSRProvider>
        <Layout>
          <CookiesProvider>
            <Component {...pageProps} />
          </CookiesProvider>
        </Layout>
    </SSRProvider>
    )
}

export default App;
_document.tsx
import { Html, Head, Main, NextScript } from 'next/document'

export default function Document() {
  return (
    <Html lang="en">
      <Head>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="" />
        <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;700&family=Work+Sans:wght@400;700&display=swap" rel="stylesheet"/>
      </Head>
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  )
}

changeDish.tsx
import { ChangeEvent, FC, useState, FormEvent, useEffect } from "react"
import ClientLayout from '@/components/structure/ClientLayout'
import { GetStaticProps } from 'next'
import { Row, Col, Form, InputGroup, Button, DropdownButton, Dropdown } from 'react-bootstrap'
import { useRouter } from "next/router"

export const getStaticProps: GetStaticProps = async () => {
    const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categoryList = await resp1.json() as categoryItem[];

    return {
        props: {
            categories: categoryList,
        }
    }
}

const ChangeDish: FC<{ categories: categoryItem[], }> = ({ categories }) => {
    const router = useRouter();
    const dishId = router.query["dishId"];
    const [dish, setDish] = useState<dishAdminInfo>({ id: "", description: "", images: [], isAvailableForUser: true, isDeleted: false, name: "", price: 0, weight: 0 });
    const [selectedCategory, setSelectedCategory] = useState<categoryItem | undefined>();
    const [loadedFilesName, setLoadedFilesName] = useState<string[]>([]);
    const [loadedFiles, setLoadedFiles] = useState<FileList | null>(null);

    useEffect(() => {
        if(dishId == undefined || dishId == null)
            return;
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/getDish/${dishId}`, {
                credentials: 'include',
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                }, 
            });
            
            if(resp.ok){
                const dishInfo = await resp.json() as {dish: dishAdminInfo, category: categoryItem};
                setDish(dishInfo.dish);
                setSelectedCategory(dishInfo.category);
            }
            else{
                alert(await resp.text());
            }
        }
        fetchData();
    }, [dishId, router]);

    const handleInputData = (e: ChangeEvent<HTMLInputElement>): void => {
        const value:string|boolean = e.target.type === 'checkbox' ? e.target.checked : e.target.value;
        const name:string = e.target.name;
        
        setDish(prevDish => ({ ...prevDish, [name]: value }));
    }

    const handleLoadFiles = (e: ChangeEvent<HTMLInputElement>): void => {
        const value:string[] = [];

        for(let i = 0; i < (e.target.files?.length ?? 0); i++){
            if(e.target.files != null)
                value.push(e.target.files[i].name);
        }

        const name:string = e.target.name;

        setLoadedFiles(e.target.files);
        setLoadedFilesName(value);
    }

    const handleSelectCategory = (eventKey:string|null): void => {
        setSelectedCategory(categories.find(el=>el.id == eventKey));
    }

    const handleSubmitForm = async (e:FormEvent) => {
        e.preventDefault();

        const formData:FormData = new FormData();
        const body:any = {...dish, categoryId: selectedCategory?.id};

        if(loadedFiles != null){
            for(let i = 0; i < loadedFiles.length; i++){
                formData.append('imagesFiles', loadedFiles[i]);
            }
        };

        for(let key in body){
            formData.append(key, body[key]);
        }

        const response = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/changeDish`, {
            method: "PATCH",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            },
            body: formData,
        });

        if(response.ok){
            router.push("/dishes/"+ await response.json());
        }
        else{
            alert(await response.text());
        }
    }

    return (
        <ClientLayout categories={categories}>
            <h3 className="text-center mb-5 mt-2">Изменение блюда</h3>
            <Form onSubmit={handleSubmitForm} >
                <Row className="mx-2">
                    <Col xs={12} lg={5}>
                        <div className="text-danger">Если вы загрузите изображения, то предыдущие будут удалены</div>
                        <InputGroup className="mb-3">
                            <Form.Control type="file" multiple name="images" onChange={handleLoadFiles}/>
                        </InputGroup>
                        {loadedFilesName.length != 0 && <div>Выбранные файлы: </div>}
                        {loadedFilesName.map((value, i)=> <InputGroup.Text className="mt-1" key={i}>{value}</InputGroup.Text>)}
                    </Col>
                    <Col xs={12} lg={7} className="mt-3 mt-lg-0">
                        <Row>
                            <Col md={12} className="mb-3 flex-grow-1 w-100">
                                <InputGroup >
                                    <InputGroup.Text className="">Название блюда</InputGroup.Text>
                                    <Form.Control type="text" name="name" value={dish.name} onChange={handleInputData} />
                                </InputGroup>
                            </Col>
                            <Col md={4} className="mb-3 pe-0">
                                <InputGroup>
                                    <DropdownButton variant="outline-secondary" title={selectedCategory == undefined ? "Категория" : selectedCategory.name} onSelect={handleSelectCategory}>
                                        {categories.map((value,i) => <Dropdown.Item eventKey={value.id} key={i}>{value.name}</Dropdown.Item>)}
                                    </DropdownButton>
                                </InputGroup>
                            </Col>
                            <Col md={4} className="mb-3 pe-0">
                                <InputGroup>
                                    <Form.Control className="ms-1" type="text" name="weight" value={dish.weight} onChange={handleInputData} />
                                    <InputGroup.Text className="">Грамм</InputGroup.Text>
                                </InputGroup>
                            </Col>
                            <Col md={4} className="mb-3">
                                <InputGroup >
                                    <Form.Control type="text" name="price" value={dish.price} onChange={handleInputData} />
                                    <InputGroup.Text className="">Р</InputGroup.Text>
                                </InputGroup>
                            </Col>
                            <InputGroup className="mb-3">
                                <InputGroup.Text className="">Описание блюда:</InputGroup.Text>
                                <Form.Control as="textarea" type="textarea" name="description" value={dish.description} onChange={handleInputData} />
                            </InputGroup>
                            <Col md={6} className="pe-0">
                                <Form.Switch label="Отметить как удаленное?" name="isDeleted" checked={dish.isDeleted} onChange={handleInputData} />
                            </Col>
                            <Col md={6}>
                                <Form.Switch label="Доступно пользователю?" name="isAvailableForUser" checked={dish.isAvailableForUser} onChange={handleInputData} />
                            </Col>
                        </Row>
                    </Col>
                </Row>
                <Row className="m-2 d-flex justify-content-end">
                    <Col xs={12} md={4}>
                        <Button type="submit" className="w-100">Изменить блюдо</Button>
                    </Col>

                </Row>

            </Form>
        </ClientLayout>
    )
}

export default ChangeDish;
createDish.tsx
import { ChangeEvent, MouseEvent, FC, useState, FormEvent } from "react"
import ClientLayout from '@/components/structure/ClientLayout'
import { GetStaticProps } from 'next'
import { Carousel, Row, Image, Col, Card, Form, InputGroup, Button, DropdownButton, Dropdown } from 'react-bootstrap'
import styles from '@/styles/Home.module.css'
import CounterMainDish from "@/components/cards/components/CounterMainDish"
import { useRouter } from "next/router"

export const getStaticProps: GetStaticProps = async () => {
    const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categoryList = await resp1.json() as categoryItem[];

    return {
        props: {
            categories: categoryList,
        }
    }
}

const CreateDish: FC<{ categories: categoryItem[], }> = ({ categories }) => {
    const router = useRouter();
    const [dish, setDish] = useState<dishAdminInfo>({ id: "", description: "", images: [], isAvailableForUser: true, isDeleted: false, name: "", price: 0, weight: 0 });
    const [selectedCategory, setSelectedCategory] = useState<categoryItem | undefined>();
    const [loadedFilesName, setLoadedFilesName] = useState<string[]>([]);
    const [loadedFiles, setLoadedFiles] = useState<FileList | null>(null);

    const handleInputData = (e: ChangeEvent<HTMLInputElement>): void => {
        const value:string|boolean = e.target.type === 'checkbox' ? e.target.checked : e.target.value;
        const name:string = e.target.name;
        
        setDish(prevDish => ({ ...prevDish, [name]: value }));
    }

    const handleLoadFiles = (e: ChangeEvent<HTMLInputElement>): void => {
        const value:string[] = [];

        for(let i = 0; i < (e.target.files?.length ?? 0); i++){
            if(e.target.files != null)
                value.push(e.target.files[i].name);
        }

        const name:string = e.target.name;

        setLoadedFiles(e.target.files);
        setLoadedFilesName(value);
    }

    const handleSelectCategory = (eventKey:string|null): void => {
        setSelectedCategory(categories.find(el=>el.id == eventKey));
    }

    const handleSubmitForm = async (e:FormEvent) => {
        e.preventDefault();

        const formData:FormData = new FormData();
        const body:any = {...dish, categoryId: selectedCategory?.id};

        if(loadedFiles != null){
            for(let i = 0; i < loadedFiles.length; i++){
                formData.append('imagesFiles', loadedFiles[i]);
            }
        };

        for(let key in body){
            formData.append(key, body[key]);
        }

        const response = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/createDish`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            },
            body: formData,
        });

        if(response.ok){
            router.push("/dishes/"+ await response.json());
        }
        else{
            alert(await response.text());
        }
    }

    return (
        <ClientLayout categories={categories}>
            <h3 className="text-center mb-5 mt-2">Создание блюда</h3>
            <Form onSubmit={handleSubmitForm} >
                <Row className="mx-2">
                    <Col xs={12} lg={5}>
                        <InputGroup className="mb-3">
                            <Form.Control type="file" multiple name="images" onChange={handleLoadFiles}/>
                            {/* <Button>Загрузить</Button> */}
                        </InputGroup>
                        {loadedFilesName.length != 0 && <div>Выбранные файлы: </div>}
                        {loadedFilesName.map((value, i)=> <InputGroup.Text className="mt-1" key={i}>{value}</InputGroup.Text>)}
                    </Col>
                    <Col xs={12} lg={7} className="mt-3 mt-lg-0">
                        <Row>
                            <Col md={12} className="mb-3 flex-grow-1 w-100">
                                <InputGroup >
                                    <InputGroup.Text className="">Название блюда</InputGroup.Text>
                                    <Form.Control type="text" name="name" value={dish.name} onChange={handleInputData} />
                                </InputGroup>
                            </Col>
                            <Col md={4} className="mb-3 pe-0">
                                <InputGroup>
                                    <DropdownButton variant="outline-secondary" title={selectedCategory == undefined ? "Категория" : selectedCategory.name} onSelect={handleSelectCategory}>
                                        {categories.map((value,i) => <Dropdown.Item eventKey={value.id} key={i}>{value.name}</Dropdown.Item>)}
                                    </DropdownButton>
                                </InputGroup>
                            </Col>
                            <Col md={4} className="mb-3 pe-0">
                                <InputGroup>
                                    <Form.Control className="ms-1" type="text" name="weight" value={dish.weight} onChange={handleInputData} />
                                    <InputGroup.Text className="">Грамм</InputGroup.Text>
                                </InputGroup>
                            </Col>
                            <Col md={4} className="mb-3">
                                <InputGroup >
                                    <Form.Control type="text" name="price" value={dish.price} onChange={handleInputData} />
                                    <InputGroup.Text className="">Р</InputGroup.Text>
                                </InputGroup>
                            </Col>
                            <InputGroup className="mb-3">
                                <InputGroup.Text className="">Описание блюда:</InputGroup.Text>
                                <Form.Control as="textarea" type="textarea" name="description" value={dish.description} onChange={handleInputData} />
                            </InputGroup>
                            <Col md={6} className="pe-0">
                                <Form.Switch label="Отметить как удаленное?" name="isDeleted" checked={dish.isDeleted} onChange={handleInputData} />
                            </Col>
                            <Col md={6}>
                                <Form.Switch label="Доступно пользователю?" name="isAvailableForUser" checked={dish.isAvailableForUser} onChange={handleInputData} />
                            </Col>
                        </Row>
                    </Col>
                </Row>
                <Row className="m-2 d-flex justify-content-end">
                    <Col xs={12} md={4}>
                        <Button type="submit" className="w-100">Создать блюдо</Button>
                    </Col>

                </Row>

            </Form>
        </ClientLayout>
    )
}

export default CreateDish;
dishes.tsx
import DishAdminCard from "@/components/cards/DishAdminCard";
import UserCard from "@/components/cards/UserCard";
import PanelToHandleDishes from "@/components/PanelToHandleDishes";
import PanelToHandleUsers from "@/components/PanelToHandleUsers";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { FC, useEffect, useState } from "react";
import { Button } from "react-bootstrap";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories,
        }
    }
}

const Dishes: FC<{categories:categoryItem[]}> = ({ categories}) => {
    const [dishes, setDishes] = useState<dishAdminInfo[]>([]);

    //нулевая страница загружается при переходе на страницу
    const [page, setPage] = useState(0);
    const [pageEnded, setPageEnded] = useState(true);

    const [searchText, setSearchText] = useState<string>("");
    
    const handleChangeSearchedText = (searchedText:string) => {
        setSearchText(searchedText);
        setPage(0);
        setDishes([]);
    }

    const handleShowMoreDishes = async () => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/getDishes?${searchText != "" ? "searchText=" + searchText + "&" : ""}page=${page}`, {
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            }
        });
    
        if(resp.ok){
            const loadedData = await resp.json() as {dishes: dishAdminInfo[], pageEnded: boolean};

            setPage(page + 1);
            setDishes(dishes.concat(loadedData.dishes));
            setPageEnded(loadedData.pageEnded);
        }
        else{
            setPageEnded(true);
            alert(await resp.text());
        }
    }

    const handleChangeDeleteStatusOfDish = async (dishId:string) => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/changeDeleteStatusOfDish`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({id: dishId})
        });
        if(resp1.ok){
            const respData = await resp1.json() as boolean;

            setDishes(prevDishes => {
                const changedDish:dishAdminInfo | undefined = prevDishes.find(el => el.id == dishId );
                if(changedDish != undefined)
                    changedDish.isDeleted = respData;

                return prevDishes.slice();
            });
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleChangeVisibleStatusOfDish = async (dishId:string) => {
        console.log(dishId);
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/changeVisibleStatusOfDish`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({id: dishId})
        });
        if(resp1.ok){
            const respData = await resp1.json() as boolean;

            setDishes(prevDishes => {
                const changedDish:dishAdminInfo | undefined = prevDishes.find(el => el.id == dishId );
                if(changedDish != undefined)
                    changedDish.isAvailableForUser = respData;

                return prevDishes.slice();
            });
        }
        else{
            alert(await resp1.text());
        }
    }

    useEffect(()=>{
        if(page == 0){
            handleShowMoreDishes();
        }
    },[page, searchText]);

    return (
        <ClientLayout categories={categories}>
            <PanelToHandleDishes changeSearchedText={handleChangeSearchedText}/>
            {dishes.map((dish, i)=> <DishAdminCard key={i} {...dish} changeDeletedState={handleChangeDeleteStatusOfDish} changeVisibleState={handleChangeVisibleStatusOfDish}/>)}
            {!pageEnded && (
                <div>
                    <Button className='btn btn-primary w-100 mt-2' onClick={handleShowMoreDishes}>
                        Показать больше
                    </Button>
                </div>)
            }
        </ClientLayout>
    );
}

export default Dishes;
map.tsx
import { GetStaticProps } from "next";
import ClientLayout from "@/components/structure/ClientLayout";
import { FC, useState } from "react";
import CustomMap from "@/components/mapComponents/customMap";
import { fromLonLat } from "ol/proj";
import Layers from "@/components/mapComponents/mapLayers/Layers";
import TileLayer from "@/components/mapComponents/mapLayers/TitleLayer";
import * as olSource from "ol/source";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories,
        }
    }
}


const MapPage: FC<{ categories: categoryItem[]}> = ({ categories}) => {
    const [center, setCenter] = useState([48.003456, 37.802683]);
    const [zoom, setZoom] = useState(9);

    return (
        <ClientLayout categories={categories}>
            <CustomMap zoom={zoom} center={fromLonLat(center)}>
            <Layers>
                <TileLayer
                    source={new olSource.OSM()}
                    zIndex={0}
                />
            </Layers>
            </CustomMap>
        </ClientLayout>
    )
}



export default MapPage;
order.tsx
import DishOrderCard from "@/components/cards/DishOrderCard";
import OrderCard from "@/components/cards/OrderCard";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { useRouter } from "next/router";
import { FC, useEffect, useState } from "react";
import { Col, Row } from "react-bootstrap";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories
        }
    }
}

const Order: FC<{ categories: categoryItem[]}> = ({ categories }) => {
    const router = useRouter();
    const [orderInfo, setOrderInfo] = useState<orderInfo>({ order: {id:"", deliveryAddress: "", phoneNumber:'', price:0, sumWeight:0, DeleteOrder: ()=>{}, MoveOrderToNextStage: ()=>{}, MoveOrderToPreviousStage: ()=>{} }, orderedDishes: []});
    const orderId = router.query["orderId"];

    const handleDeleteOrder = async () => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/cancelOrder`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({ orderId })
        });

        if (resp1.ok) {
            router.push("/profile/orderStory");
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleDeleteItemDish = async (dishId: string) => {
        const dishWillDelete = orderInfo.orderedDishes.find(el => el.dishInfo.id == dishId)
        if (dishWillDelete != null) {
            setOrderInfo(prevOrderInfo => {
                prevOrderInfo.orderedDishes = prevOrderInfo.orderedDishes.filter(el => el.dishInfo.id != dishId);
                prevOrderInfo.order.price -= dishWillDelete.count*dishWillDelete.dishInfo.price;
                return { ...prevOrderInfo };
            });

            const response = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/cancelOrderedDish`, {
                method: "POST",
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                    'Content-Type': 'application/json;charset=utf-8',
                },
                body: JSON.stringify({ orderId, dishId })
            });

            if(!response.ok){
                alert(await response.text());
            }

            if (orderInfo.orderedDishes.length == 0) {
                await handleDeleteOrder();
            }
        }
    }

    useEffect(() => {
        if(orderId == undefined || orderId == null)
            return;
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/getOrder/${orderId}`, {
                credentials: 'include',
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                }, 
            });
            
            if(resp.ok){
                const orderInfo = await resp.json() as orderInfo;
                setOrderInfo(orderInfo);
            }
            else{
                alert(await resp.text())
            }
        }
        fetchData();
    }, [orderId, router]);

    return (
        <>
            <ClientLayout categories={categories}>
                <OrderCard {...orderInfo.order} DeleteOrder={handleDeleteOrder} canWriteReview={false}/>
                {orderInfo.order.clientRating != null && <h3>Оценка клиента: {orderInfo.order.clientRating}</h3>}
                {orderInfo.order.review != null && <h3>Отзыв клиента: {orderInfo.order.review}</h3>}
                <Row className="mt-3 ">
                    <Col >
                        <h3>Список блюд из заказа: </h3>
                    </Col>
                </Row>
                {orderInfo.orderedDishes.map((dish, i) => {
                    dish.dishInfo.DeleteCardFromList = handleDeleteItemDish
                    return (<DishOrderCard key={i} {...dish} orderId={orderInfo.order.id} />)
                })}
                
            </ClientLayout>
        </>
    );
}

export default Order;
orders.tsx
import PanelToHandleOrders from "@/components/PanelToHandleOrders";
import OrderCard from "@/components/cards/OrderCard";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { FC, useEffect, useState } from "react";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getOrderStates`);
    const states = await resp1.json() as orderState[];

    return {
        props: {
            categories,
            states,
        }
    }
}

const AdminOrders: FC<{categories:categoryItem[], states:orderState[]}> = ({ categories, states }) => {
    const [orders, setOrders] = useState<orderCardInfo[]>([]);
    const [page, setPage] = useState(0);
    const [pageEnded, setPageEnded] = useState(true);
    const [selectedState, setSelectedState] = useState<orderState>(states[0]);

    const handleMoveOrderToPreviousStage = async (orderId:string, orderStateId:string) => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/moveToPreviousStage`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({ orderId })
        });

        if (resp1.ok) {
            const changedOrderIndex = orders.findIndex(el => el.id == orderId);
            const updatedOrders = [...orders];
            const deletedStage = updatedOrders[changedOrderIndex].story?.pop();

            if(deletedStage?.orderStateId == orderStateId)
                setOrders(updatedOrders);
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleMoveOrderToNextStage = async (orderId:string, orderStateId:string) => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/moveToNextStage`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({ orderId })
        });

        if (resp1.ok) {
            const newOrderState = await resp1.json() as orderState;
            const changedOrderIndex = orders.findIndex(el => el.id == orderId);
            const updatedOrders = [...orders];
            updatedOrders[changedOrderIndex].story?.push(newOrderState);

            if (newOrderState.orderStateId != orderStateId)
                setOrders(updatedOrders);
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleShowMoreOrders = async  () => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/getOrders?page=${page}&numberOfState=${selectedState.numberOfStage}`, {
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            }
        });
    
        if(resp.ok){
            const loadedData = await resp.json() as {orders: orderCardInfo[], pageEnded: boolean};
            setPage(page + 1);
            setOrders(orders.concat(loadedData.orders));
            setPageEnded(loadedData.pageEnded);
        }
        else{
            setPageEnded(true);
            alert(await resp.text());
        }
    }

    const handleDeleteItem = async (orderId:string) => {
        setOrders(prevOrders => prevOrders.filter(el => el.id != orderId ));

        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/cancelOrder`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({orderId})
        });

        if(!resp1.ok){
            alert(await resp1.text());
        }
    }

    const handleSelectState = (selectState: orderState) => {
        setSelectedState(selectState);
        setOrders([]);
        setPage(0);
    }

    useEffect(()=>{
        if(page == 0){
            handleShowMoreOrders();
        }
    }, [page]);

    return (
        <ClientLayout categories={categories}>
            <PanelToHandleOrders orderStates={states} selectState={handleSelectState}/>
            {orders.map((order, i)=> <OrderCard key={i} {...order} DeleteOrder={handleDeleteItem} MoveOrderToPreviousStage={handleMoveOrderToPreviousStage} MoveOrderToNextStage={handleMoveOrderToNextStage}/>)}
            {!pageEnded && (<div>
                    <button className='btn btn-primary w-100 mt-2' onClick={handleShowMoreOrders}>
                        Показать больше
                    </button>
                </div>)
            }
        </ClientLayout>
    );
}

export default AdminOrders;
statistics.tsx
import PanelToHandleStatistics from "@/components/PanelToHandleStatistics";
import BarChart from "@/components/statisticsCharts/BarChart";
import LineChart from "@/components/statisticsCharts/LineChart";
import RadarChart from "@/components/statisticsCharts/RadarChart";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { FC, useEffect, useState } from "react";
import { Col, Row } from "react-bootstrap";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories,
        }
    }
}

const Statistics: FC<{ categories: categoryItem[] }> = ({ categories }) => {
    const [statisticQueries, setStatisticQueries] = useState<statisticQueryInfo[]>([]);
    const [selectedQuery, setSelectecQuery] = useState<statisticQueryInfo>();
    
    const handleGetQueryDataFromServer = async (query:statisticQueryInfo) => {
        setSelectecQuery(query);
    };

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/statistic/getStatisticQueries`, {
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                },
            });
            if(resp.ok){
                const resInfo = await resp.json() as statisticQueryInfo[];
                setStatisticQueries(resInfo);
            }
            else{
                alert(await resp.text());
            }

        }
        fetchData();
    }, []);

    const drawChart:any = {
        "line": <LineChart query={selectedQuery as statisticQueryInfo}/>,
        "bar": <BarChart query={selectedQuery as statisticQueryInfo}/>,
        "radar": <RadarChart query={selectedQuery as statisticQueryInfo}/>,
    }

    return (
        <ClientLayout categories={categories}>
            <PanelToHandleStatistics statisticQueries={statisticQueries} buildChart={handleGetQueryDataFromServer} />
            <Row className="d-flex justify-content-center mt-3 mb-3">
                <Col md={9}>
                    {selectedQuery != undefined && drawChart[selectedQuery.chartName]}
                </Col>
            </Row>
        </ClientLayout>
    );
}

export default Statistics;
users.tsx
import UserCard from "@/components/cards/UserCard";
import PanelToHandleUsers from "@/components/PanelToHandleUsers";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { FC, useEffect, useState } from "react";
import { Button } from "react-bootstrap";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories,
        }
    }
}

const Users: FC<{categories:categoryItem[]}> = ({ categories}) => {
    const [users, setUsers] = useState<profileInfo[]>([]);
    const [roles, setRoles] = useState<string[]>([]);

    const [markedUsers, setMarkedUsers] = useState<string[]>([]);

    //нулевая страница загружается при переходе на страницу
    const [page, setPage] = useState(0);
    const [pageEnded, setPageEnded] = useState(true);

    const [searchText, setSearchText] = useState<string>("");
    
    const handleChangeSearchedText = (searchedText:string) => {
        setSearchText(searchedText);
        setPage(0);
        setUsers([]);
    }

    const handleMarkUser = async (userId:string) => {
        setMarkedUsers(prevMarkedUsers => prevMarkedUsers.concat(userId));
    }

    const handleUnmarkUser = async (userId:string) => {
        setMarkedUsers(prevMarkedUsers => prevMarkedUsers.filter(h => h != userId));
    }

    const handleShowMoreUsers = async () => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/getUsers?${searchText != "" ? "searchText=" + searchText + "&" : ""}page=${page}`, {
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            }
        });
    
        if(resp.ok){
            const loadedData = await resp.json() as {users: profileInfo[], pageEnded: boolean};
            setPage(page + 1);
            setUsers(users.concat(loadedData.users));
            setPageEnded(loadedData.pageEnded);
        }
        else{
            setPageEnded(true);
            alert(await resp.text());
        }
    }

    const handleBlockUser = async () => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/blockUsers`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify(markedUsers.map<{userId: string}>((value) => { return {userId: value} }))
        });

        if(resp1.ok){
            setUsers(prevUsers => prevUsers.map((value)=> {
                if(markedUsers.includes(value.id as string))
                    value.isBlocked = true; 
                return value;
            }))
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleUnblockUser = async () => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/unblockUsers`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify(markedUsers.map<{userId: string}>((value) => { return {userId: value} }))
        });

        if(resp1.ok){
            setUsers(prevUsers => prevUsers.map((value)=> {
                if(markedUsers.includes(value.id as string))
                    value.isBlocked = false; 
                return value;
            }))
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleAddRoleTokUser = async (newRole:string) => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/addUserRole`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify(markedUsers.map<{userId: string}>((value) => { return {userId: value, changeRole: newRole} }))
        });

        if(resp1.ok){
            setUsers(prevUsers => prevUsers.map((value)=> {
                if(markedUsers.includes(value.id as string) && !value.roles?.includes(newRole)) {
                    value.roles += ", " + newRole;
                }
                return value;
            }))
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleRemoveRoleTokUser = async (oldRole:string) => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/removeUserRole`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify(markedUsers.map<{userId: string}>((value) => { return {userId: value, changeRole: oldRole} }))
        });

        if(resp1.ok){
            setUsers(prevUsers => prevUsers.map((value)=> {
                if(markedUsers.includes(value.id as string)  && value.roles?.includes(oldRole)){
                    value.roles = (value.roles as string).replaceAll(", " + oldRole, "");
                }
                return value;
            }))
        }
        else{
            alert(await resp1.text());
        }
    }

    useEffect(()=>{
        if(page == 0){
            handleShowMoreUsers();

            const fetchData = async () => {
                const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/getRoles`, {
                    headers: {
                        'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                    }
                });
            
                if(resp.ok){
                    const loadedData = await resp.json() as string[];
                    setRoles(loadedData);
                }
                else{
                    alert(await resp.text());
                }
            }
            fetchData();
        }
    },[page, searchText]);

    return (
        <ClientLayout categories={categories}>
            <PanelToHandleUsers roles={roles} changeSearchedText={handleChangeSearchedText} blockUsers={handleBlockUser} unblockUsers={handleUnblockUser} addRole={handleAddRoleTokUser} removeRole={handleRemoveRoleTokUser}/>
            {users.map((user, i)=> <UserCard key={i} userInfo={user} markUser={handleMarkUser} unmarkUser={handleUnmarkUser}/>)}
            {!pageEnded && (
                <div>
                    <Button className='btn btn-primary w-100 mt-2' onClick={handleShowMoreUsers}>
                        Показать больше
                    </Button>
                </div>)
            }
        </ClientLayout>
    );
}

export default Users;
[category].tsx
import Head from 'next/head'
import { FC } from "react"
import ClientLayout from '@/components/structure/ClientLayout'
import { GetStaticPaths, GetStaticProps } from 'next'
import DishMainCard from '@/components/cards/DishMainCard'

export const getStaticPaths:GetStaticPaths = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];
    const paths = categories.map((value)=> ({params: {category: value.linkName}}))

  return {
    paths,
    fallback: false, // can also be true or 'blocking'
  }
}

export const getStaticProps:GetStaticProps = async (context) => {
    const category = context.params?.category;
    const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categoryList = await resp1.json() as categoryItem[];

    const resp2 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getDishesList/${category}`);
    const dishList = await resp2.json() as dishClientInfo[];

    return {
        props:{
            categories: categoryList,
            dishes: dishList,
        }
    }
}

type categoryPageProps = {
  categories:categoryItem[], 
  dishes: dishClientInfo[],
}

const Category: FC<categoryPageProps> = ({categories, dishes}) => {
  return (
    <ClientLayout categories={categories}>
      <Head>
        <title>Create Next App</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main>
        <div>
          {dishes.map((dish, i) => <DishMainCard key={i} {...dish}/>)}
        </div>
      </main>
    </ClientLayout>
  )
}

export default Category;
[id].tsx
import { FC, useEffect, useState } from "react"
import ClientLayout from '@/components/structure/ClientLayout'
import { GetStaticPaths, GetStaticProps } from 'next'
import { Carousel, Row, Image, Col } from 'react-bootstrap'
import Head from 'next/head'
import styles from '@/styles/Home.module.css'
import CounterMainDish from "@/components/cards/components/CounterMainDish"
import { useRouter } from "next/router"

export const getStaticPaths: GetStaticPaths = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getDishIds`);
    const dishIds = await resp.json() as string[];
    const paths = dishIds.map((value) => ({ params: { id: value } }))

    return {
        paths,
        fallback: false, // can also be true or 'blocking'
    }
}

export const getStaticProps: GetStaticProps = async (context) => {
    const id = context.params?.id;
    const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categoryList = await resp1.json() as categoryItem[];

    const resp2 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getDish/${id}`);
    const dish = await resp2.json() as dishClientInfo;

    return {
        props: {
            categories: categoryList,
            dish,
        }
    }
}

type dishPageProps = {
    categories: categoryItem[],
    dish: dishClientInfo,
}

const Dish: FC<dishPageProps> = ({ categories, dish }) => {
    const [index, setIndex] = useState(0);
    const router = useRouter();
    const [ability, setAbility] = useState(true);

    const handleSelect = (selectedIndex: number): void => {
        setIndex(selectedIndex);
    };

    useEffect(() => {
        const fetchData = async () => {
            const { id } = router.query;
            const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getDishAbilityInfo/${id}`);
            if (resp1.ok) {
                const abilityRes = await resp1.json() as boolean;
                setAbility(abilityRes);
            }
            else {
                alert(await resp1.text());
            }
        }
        fetchData();
    }, [router]);

    if (!ability)
        router.push("/")

    return (
        <ClientLayout categories={categories}>
            <main>
                <div>
                    <Row className="justify-content-center">
                        <Col xs={12} sm={10} md={8} lg={6}>
                            <Carousel activeIndex={index} onSelect={handleSelect}>
                                {dish.images?.map((value, i) =>
                                    <Carousel.Item key={i} >
                                        <Image className="d-block w-100" src={value} alt="No image" />
                                    </Carousel.Item>
                                )}
                            </Carousel>
                        </Col>
                    </Row>
                    <Row className="justify-content-center mb-3">
                        <Col xs={12} sm={11} md={10} lg={9}>
                            <div>
                                <div className="d-flex mb-3 mt-2">
                                    <h5 className="flex-grow-1">{dish.name}</h5>
                                    <h5 className=""><b>{dish.price}Р</b></h5>
                                </div>
                                <p className="text-justify">{dish.description}</p>
                            </div>
                            <CounterMainDish dishId={dish.id} />
                        </Col>
                    </Row>
                </div>
            </main>
        </ClientLayout>
    )
}

export default Dish;
orders.tsx
import PanelToHandleOrders from "@/components/PanelToHandleOrders";
import OrderCard from "@/components/cards/OrderCard";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { FC, useEffect, useState } from "react";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getOrderStates`);
    const states = await resp1.json() as orderState[];

    return {
        props: {
            categories,
            states,
        }
    }
}

const KitchenOrders: FC<{categories:categoryItem[], states:orderState[]}> = ({ categories, states }) => {
    const [orders, setOrders] = useState<orderCardInfo[]>([]);
    const [page, setPage] = useState(0);
    const [pageEnded, setPageEnded] = useState(true);
    const [selectedState, setSelectedState] = useState<orderState>(states[0]);

    const handleMoveOrderToPreviousStage = async (orderId:string, orderStateId:string) => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/moveToPreviousStage`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({ orderId })
        });

        if (resp1.ok) {
            setOrders(prevOrders => prevOrders.filter(el => el.id != orderId ));
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleMoveOrderToNextStage = async (orderId:string, orderStateId:string) => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/moveToNextStage`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({ orderId })
        });

        if (resp1.ok) {
            setOrders(prevOrders => prevOrders.filter(el => el.id != orderId ));
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleSelectState = (selectState: orderState) => {
        setSelectedState(selectState);
        setOrders([]);
        setPage(0);
    }

    const handleShowMoreOrders = async  () => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/kitchen/getOrders?page=${page}&numberOfState=${selectedState.numberOfStage}`, {
            credentials: "include",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            }
        });
    
        if(resp.ok){
            const loadedData = await resp.json() as {orders: orderCardInfo[], pageEnded: boolean};
            setPage(page + 1);
            setOrders(orders.concat(loadedData.orders));
            setPageEnded(loadedData.pageEnded);
        }
        else{
            setPageEnded(true);
            alert(await resp.text());
        }
    }

    useEffect(()=>{
        if(page == 0){
            handleShowMoreOrders();
        }
    }, [page]);

    return (
        <ClientLayout categories={categories}>
            <PanelToHandleOrders orderStates={states} selectState={handleSelectState}/>
            {orders.map((order, i)=> <OrderCard key={i} {...order} DeleteOrder={()=>{}} MoveOrderToPreviousStage={handleMoveOrderToPreviousStage} MoveOrderToNextStage={handleMoveOrderToNextStage}/>)}
            {!pageEnded && (<div>
                    <button className='btn btn-primary w-100 mt-2' onClick={handleShowMoreOrders}>
                        Показать больше
                    </button>
                </div>)
            }
        </ClientLayout>
    );
}

export default KitchenOrders;
workers.tsx
import WorkerCard from "@/components/cards/WorkerCard";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { FC, useEffect, useState } from "react";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories,
        }
    }
}

const Workers: FC<{categories:categoryItem[]}> = ({ categories}) => {
    const [workers, setWorkers] = useState<profileInfo[]>([]);

    useEffect(()=>{
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/kitchen/getWorkers`, {
                credentials: "include",
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                }
            });
        
            if(resp.ok){
                const loadedData = await resp.json() as profileInfo[];
                setWorkers(loadedData);
            }
            else{
                alert(await resp.text());
            }
        }
        fetchData();
    },[]);

    return (
        <ClientLayout categories={categories}>
            {workers.map((user, i)=> <WorkerCard key={i} userInfo={user}/>)}
        </ClientLayout>
    );
}

export default Workers;
index.tsx
import { AuthContext } from "@/components/contexts/AuthContext";
import Link from "next/link";
import { FC, useContext, useEffect, useState } from "react";
import { Card, Col, Container, Row } from "react-bootstrap";

const ProfileInfo: FC = () => {
    const [profile, setProfileInfo] = useState<profileInfo>({ id: null, login: "", name: "", isBlocked:null, bonuses: null, born: null, jobTitle: null, phoneNumber: null, roles: null, gotJob: null, address: null });
    const authContextData = useContext<authContextProps>(AuthContext);

    const orderStoryButtonVisibility:boolean = !(authContextData.isAdmin || authContextData.isKitchenWorker || authContextData.isDeliveryMan);

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getProfileInfo`, {
                credentials: 'include',
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                }, 
            });
            if(resp.ok){
                const profileInfo = await resp.json() as profileInfo;
                setProfileInfo(profileInfo);
            }
            else{
                alert(await resp.text());
            }
        }
        fetchData();
    }, []);

    return (
        <Container className="mt-5">
            <Row className="d-flex justify-content-center">
                <Col md={8}>
                    <Card className="p-3 py-4">
                        <div className="text-center">
                            <img src="https://i.imgur.com/bDLhJiP.jpg" width="100" className="rounded-circle" alt=""/>
                        </div>
                        <div className="text-center mt-3">
                            {/* <span className="bg-secondary p-1 px-4 rounded text-white">{profile.jobTitle}</span> */}
                            <h5 className="mt-2 mb-0">{profile.name}</h5>
                            <span>{profile.login}</span>
                            <div className="px-2 px-md-4 mt-1">
                                <p className="fonts">Consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. </p>
                            </div>
                            <div className="buttons">
                                {orderStoryButtonVisibility && <Link href="/profile/orderStory" className="btn btn-outline-primary px-4">История заказов</Link>}
                                <button className="btn btn-primary px-4 ms-3">Contacts</button>
                            </div>
                        </div>
                    </Card>
                </Col>
            </Row>
        </Container>
    );
}

export default ProfileInfo;
order.tsx
import DishOrderCard from "@/components/cards/DishOrderCard";
import OrderCard from "@/components/cards/OrderCard";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { useRouter } from "next/router";
import { FC, useEffect, useState } from "react";
import { Col, Row } from "react-bootstrap";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories
        }
    }
}

const Order: FC<{ categories: categoryItem[]}> = ({ categories }) => {
    const router = useRouter();
    const [orderInfo, setOrderInfo] = useState<orderInfo>({ order: {id:"", deliveryAddress: "", price:0, sumWeight:0, phoneNumber: '', DeleteOrder: ()=>{}, MoveOrderToNextStage: ()=>{}, MoveOrderToPreviousStage: ()=>{} }, orderedDishes: []});
    const orderId = router.query["orderId"];

    useEffect(() => {
        if(orderId == undefined || orderId == null)
            return;
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/getOrder/${orderId}`, {
                credentials: 'include',
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                }, 
            });

            if(resp.ok){
                const orderInfo = await resp.json() as orderInfo;
                setOrderInfo(orderInfo);
            }
            else{
                router.push("/profile/orderStory");
                //alert(await resp.text());
            }
        }
        fetchData();
    }, [orderId, router]);

    return (
        <>
            <ClientLayout categories={categories}>
                <OrderCard {...orderInfo.order} canWriteReview={orderInfo.order.clientRating == null}/>
                {orderInfo.order.clientRating != null && <h3>Оценка клиента: {orderInfo.order.clientRating}</h3>}
                {orderInfo.order.review != null && <h3>Отзыв клиента: {orderInfo.order.review}</h3>}
                <Row className="mt-3 ">
                    <Col >
                        <h3>Список блюд из заказа: </h3>
                    </Col>
                </Row>
                {orderInfo.orderedDishes.map((dish, i) => {
                    return (<DishOrderCard key={i} {...dish} orderId={orderInfo.order.id} />)
                })}
                
            </ClientLayout>
        </>
    );
}

export default Order;
orderStory.tsx
import PanelToHandleOrders from "@/components/PanelToHandleOrders";
import OrderCard from "@/components/cards/OrderCard";
import CancelOrderModal from "@/components/models/CancelOrderModal";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { FC, useEffect, useState } from "react";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getOrderStates`);
    const states = await resp1.json() as orderState[];

    return {
        props: {
            categories,
            states,
        }
    }
}

const OrderStory: FC<{categories:categoryItem[], states:orderState[]}> = ({ categories, states }) => {
    const [orders, setOrders] = useState<orderCardInfo[]>([]);
    const [selectedState, setSelectedState] = useState<orderState>(states[0]);
    const [page, setPage] = useState(0);
    const [pageEnded, setPageEnded] = useState(true);

    const handleDeleteItem = async (orderId:string, reasonOfCancel:string) => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/cancelOrder`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({orderId, reasonOfCancel})
        });

        if(resp.ok){
            setOrders(prevOrders => prevOrders.filter(el => el.id != orderId ));
        }
        else{
            alert(await resp.text())
        }
    }

    const handleSelectState = (selectState: orderState) => {
        setSelectedState(selectState);
        setOrders([]);
        setPage(0);
    }

    const handleShowMoreOrders = async  () => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/getClientOrders?page=${page}&numberOfState=${selectedState.numberOfStage}`, {
            credentials: "include",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            }
        });
    
        if(resp.ok){
            const loadedData = await resp.json() as {orders: orderCardInfo[], pageEnded: boolean};

            setPage(page + 1);
            setOrders(orders.concat(loadedData.orders));
            setPageEnded(loadedData.pageEnded);
        }
        else{
            setPageEnded(true);
            alert(await resp.text())
        }
    }

    useEffect(()=>{
        if(page == 0){
            handleShowMoreOrders();
        }
    }, [page, selectedState]);

    return (
        <ClientLayout categories={categories}>
            <PanelToHandleOrders orderStates={states} selectState={handleSelectState}/>
            {orders.map((order, i)=> <OrderCard key={i} {...order} DeleteOrder={handleDeleteItem} canWriteReview={false}/>)}
            {!pageEnded && (<div>
                    <button className='btn btn-primary w-100 mt-2' onClick={handleShowMoreOrders}>
                        Показать больше
                    </button>
                </div>)
            }
        </ClientLayout>
    );
}

export default OrderStory;
FooterPanelItem.tsx
import Link from "next/link";
import { FC } from "react"
import { Nav, Container, Navbar } from "react-bootstrap";

const FooterPanelItem : FC<footerPanelInfo> = (contentPanel:footerPanelInfo) =>{
    return (
        <Navbar bg="light" expand="md">
            <Container fluid="xl" className="g-0" >
                <Navbar.Toggle aria-controls="basic-navbar-nav" className="w-100">{contentPanel.panelName}</Navbar.Toggle>
                <Navbar.Collapse id="basic-navbar-nav">
                    <Nav className="me-auto flex-column w-100">
                        <Nav.Item className='w-100 d-none d-md-block text-center'>
                            <b>{contentPanel.panelName}</b>
                        </Nav.Item>

                        {contentPanel.panelItems.map((value, i) =>
                            (<Nav.Item className="w-100" key={i}>
                                <Link className="nav-link" href={value.itemHref}>
                                        {value.itemName}
                                </Link>
                            </Nav.Item>)
                        )}
                    </Nav>
                </Navbar.Collapse>
            </Container>
        </Navbar>
    );
}

export default FooterPanelItem;
PanelToHandleDishes.tsx
import Link from 'next/link';
import React, { ChangeEvent, FC, useState } from 'react';
import { Button, Col, Dropdown, Form, Image, Row } from 'react-bootstrap';

interface PanelToHandleUsersProps {
    changeSearchedText: (newSearchedText:string) => void, 
}

const PanelToHandleDishes: FC<PanelToHandleUsersProps> = ({ changeSearchedText }) => {
    const [searchValue, setSearchValue] = useState("");

    const changeSearchValue = (e: ChangeEvent<HTMLInputElement>): void => {
        e.preventDefault();
        setSearchValue(e.target.value);
    }

    const handleSearchClick = ():void =>{
        changeSearchedText(searchValue);
    }

    return (
        <>
            <Row className='pe-md-3'>
                <Col xs={12} md='auto' className='mt-2 flex-grow-1'>
                    <Form className="d-flex w-100">
                        <Form.Control className='w-100' placeholder="Поиск по названию и описанию" aria-describedby="basic-addon2" value={searchValue} onChange={changeSearchValue} />
                        <Button variant="outline-secondary" className='ms-1' onClick={handleSearchClick}>
                            <Image src="\loupe.svg" width="20" height="20" alt="Поиск по Id и логину" />
                        </Button>
                    </Form>
                </Col>
                <Col xs={12} md='auto' className='mt-2 g-0'>
                    <Row className='ms-1 d-flex justify-content-center'>
                        <Col xs='auto' className='mt-1 mt-xxl-0'>
                            <Link href={"/admin/createDish"} className={`btn btn-secondary`}>
                                Создать новое блюдо
                            </Link>
                        </Col>
                    </Row>
                </Col>
            </Row>
        </>
    );
}

export default PanelToHandleDishes;


PanelToHandleOrders.tsx
import React, {  FC, useState } from 'react';
import { Col, Dropdown, Row } from 'react-bootstrap';

interface PanelToHandleUsersProps {
    orderStates: orderState[],
    selectState: (selectedState: orderState) => void;
}

const PanelToHandleOrders: FC<PanelToHandleUsersProps> = ({ orderStates, selectState }) => {
    const [selectedState, setSelectedState] = useState<orderState>(orderStates[0]);

    const handleSelectState = (eventKey: string | null): void => {
        if(eventKey != null)
        {
            const selState = orderStates.find(el => el.numberOfStage == Number.parseInt(eventKey));
        
            if(selState != undefined){
                setSelectedState(selState);
                selectState(selState);
            }
        }

    }

    return (
        <>
            <Row className='g-0 m-1'>
                <Col xs='auto' className='g-0 me-1'>
                    <Dropdown onSelect={handleSelectState}>
                        <Dropdown.Toggle variant="success" id="dropdown-basic">
                            {selectedState.nameOfState}
                        </Dropdown.Toggle>
                        <Dropdown.Menu >
                            {orderStates.map((value, i) => <Dropdown.Item eventKey={value.numberOfStage} key={i}>{value.nameOfState}</Dropdown.Item>)}
                        </Dropdown.Menu>
                    </Dropdown>
                </Col>
            </Row>
        </>
    );
}

export default PanelToHandleOrders;


PanelToHandleStatistics.tsx
import React, {  FC, useState } from 'react';
import { Col, Dropdown, Row } from 'react-bootstrap';

interface PanelToHandleUsersProps {
    statisticQueries: statisticQueryInfo[],
    buildChart: (linkQuery: statisticQueryInfo) => void;
}

const PanelToHandleStatistics: FC<PanelToHandleUsersProps> = ({ statisticQueries, buildChart }) => {
    const [selectedQuery, setSelectedQuery] = useState<statisticQueryInfo>();

    const handleSelectQuery = (eventKey: string | null): void => {
        const selQuery = statisticQueries.find(el => el.nameQuery == eventKey);
        setSelectedQuery(selQuery);
        
        if(selQuery != undefined){
            buildChart(selQuery);
        }
    }

    return (
        <>
            <Row className='g-0 m-1'>
                <Col xs='auto' className='g-0 me-1'>
                    <Dropdown onSelect={handleSelectQuery}>
                        <Dropdown.Toggle variant="success" id="dropdown-basic">
                            {selectedQuery == undefined ? "Выберете аналитический запрос" : selectedQuery.nameQuery}
                        </Dropdown.Toggle>
                        <Dropdown.Menu >
                            {statisticQueries.map((value, i) => <Dropdown.Item eventKey={value.nameQuery} key={i}>{value.nameQuery}</Dropdown.Item>)}
                        </Dropdown.Menu>
                    </Dropdown>
                </Col>
            </Row>
        </>
    );
}

export default PanelToHandleStatistics;


PanelToHandleUsers.tsx
import React, { ChangeEvent, FC, MouseEvent, SyntheticEvent, useState } from 'react';
import { Button, Col, Dropdown, Form, Image, Row } from 'react-bootstrap';
import Link from 'next/link';

interface PanelToHandleUsersProps {
    roles: string[], 
    blockUsers: () => void, 
    unblockUsers: () => void,
    addRole: (role:string) => void, 
    removeRole: (role: string) => void,
    changeSearchedText: (newSearchedText:string) => void, 
}

const PanelToHandleUsers: FC<PanelToHandleUsersProps> = ({ roles, blockUsers, unblockUsers, addRole, removeRole, changeSearchedText }) => {
    const [searchValue, setSearchValue] = useState("");
    const [selectedRole, setSelectedRole] = useState("Роль");

    const changeSearchValue = (e: ChangeEvent<HTMLInputElement>): void => {
        e.preventDefault();
        setSearchValue(e.target.value);
    }

    const handleSearchClick = ():void =>{
        changeSearchedText(searchValue);
    }

    const handleAddRole = (): void => {
        if(selectedRole != "Роль")
            addRole(selectedRole);
        else
            alert("Вы не выбрали новую роль для пользователей")
    }

    const handleRemoveRole = (): void => {
        if(selectedRole != "Роль")
            removeRole(selectedRole);
        else
            alert("Вы не выбрали старую роль пользователей")
    }

    const handleSelectRole = (eventKey:string|null): void => {
        setSelectedRole(eventKey ?? "Роль");
    }

    const handleBlockUsers = (): void => {
        blockUsers()
    }

    const handleUnblockUsers = (): void => {
        unblockUsers()
    }

    return (
        <>
            <Row className='pe-md-3'>
                <Col xs={12} md='auto' className='mt-2 flex-grow-1'>
                    <Form className="d-flex w-100">
                        <Form.Control className='w-100' placeholder="Поиск по Id и логину" aria-describedby="basic-addon2" value={searchValue} onChange={changeSearchValue} />
                        <Button variant="outline-secondary" className='ms-1' onClick={handleSearchClick}>
                            <Image src="\loupe.svg" width="20" height="20" alt="Поиск по Id и логину" />
                        </Button>
                    </Form>
                </Col>
                <Col xs={12} md='auto' className='mt-2 g-0'>
                    <Row className='ms-1 d-flex justify-content-center'>
                        <Col xs='auto'  className='mt-1 mt-xxl-0'>
                            <Row className='g-0 me-1'>
                                <Col xs='auto' className='g-0 me-1'>
                                    <Dropdown onSelect={handleSelectRole}>
                                        <Dropdown.Toggle variant="success" id="dropdown-basic">
                                            {selectedRole}
                                        </Dropdown.Toggle>
                                        <Dropdown.Menu >
                                            {roles.map((value, i) => <Dropdown.Item eventKey={value} key={i}>{value}</Dropdown.Item>)}
                                        </Dropdown.Menu>
                                    </Dropdown>
                                </Col>
                                <Col xs='auto' className='g-0 me-1'>
                                    <Button onClick={handleAddRole} className={`btn btn-danger`}>
                                        Добавить роль
                                    </Button>
                                </Col>
                                <Col xs='auto' className='g-0 me-1'>
                                    <Button onClick={handleRemoveRole} className={`btn btn-danger`}>
                                        Удалить роль
                                    </Button>
                                </Col>
                            </Row>
                        </Col>

                        <Col xs='auto' className='mt-1 mt-xxl-0'>
                            <Row className='g-0 me-1 d-flex justify-content-center'>
                                <Col xs='auto' className='g-0 me-1'>
                                    <Button onClick={handleBlockUsers} className={`btn btn-danger`}>
                                        Заблокировать
                                    </Button>
                                </Col>
                                <Col xs='auto' className='g-0 me-1'>
                                    <Button onClick={handleUnblockUsers} className={`btn btn-danger`}>
                                        Разблокировать
                                    </Button>
                                </Col>
                            </Row>
                        </Col>
                    </Row>
                </Col>
            </Row>
        </>
    );
}

export default PanelToHandleUsers;


DishAdminCard.tsx
import React, { FC } from 'react';
import DishStandartLayout from '../structure/DishStandartLayout';
import HandlerAdminDish from './components/HandlerAdminDish';

interface DishAdminCard extends dishAdminInfo {
    changeVisibleState: (dishId:string)=>void, 
    changeDeletedState: (dishId:string)=>void
}

const DishAdminCard: FC<DishAdminCard> = (dishInfo) => {
    return (
        <DishStandartLayout dishInfo={dishInfo}>
            <HandlerAdminDish 
                dishId={dishInfo.id}
                dishDeleted={dishInfo.isDeleted} 
                isVisibleForUsers={dishInfo.isAvailableForUser} 
                changeDeleteStateDish={dishInfo.changeDeletedState}
                changeVisibleStateDish={dishInfo.changeVisibleState}/>
        </DishStandartLayout>
    );
}

export default DishAdminCard;


DishCartCard.tsx
import React, { FC } from 'react';
import CounterCartDish from './components/CounterCartDish';
import DishStandartLayout from '../structure/DishStandartLayout';

const DishCartCard: FC<dishCartInfo> = (dishInfo) => {

    return (
        <DishStandartLayout dishInfo={dishInfo}>
            <CounterCartDish dishId={dishInfo.id} cancelDish={dishInfo.DeleteCardFromList}/>
        </DishStandartLayout>
    );
}

export default DishCartCard;


DishMainCard.tsx
import React, { FC } from 'react';
import CounterMainDish from './components/CounterMainDish';
import DishStandartLayout from '../structure/DishStandartLayout';

const DishMainCard: FC<dishClientInfo> = (dishInfo) => {

    return (
        <DishStandartLayout dishInfo={dishInfo}>
            <CounterMainDish dishId={dishInfo.id}/>
        </DishStandartLayout>
    );
}

export default DishMainCard;


DishOrderCard.tsx
import React, { FC, useContext } from 'react';
import CounterOrderDish from './components/CounterOrderDish';
import { AuthContext } from '../contexts/AuthContext';
import DishStandartLayout from '../structure/DishStandartLayout';

const DishOrderCard: FC<orderedDishClientInfo> = ({count, dishInfo, orderId}) => {
    const roleContextData = useContext<authContextProps>(AuthContext);

    const changeCountOrderedDish = async (dishId:string, newCount: number) =>{
        const response = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/changeCountOrderedDish`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({newCount, orderId, dishId})
        });
        if(!response.ok){
            alert(await response.text())
        }
    }

    return (
        <DishStandartLayout dishInfo={dishInfo}>
            {roleContextData.isAdmin && <CounterOrderDish dishId={dishInfo.id} cancelDish={dishInfo.DeleteCardFromList} changeCountDish={changeCountOrderedDish} countOrdered={count}/>}
        </DishStandartLayout>
    );
}

export default DishOrderCard;


OrderCard.tsx
import React, { FC, useContext, useState } from 'react';
import { Card, Col, Row } from 'react-bootstrap';
import Link from 'next/link';
import { AuthContext } from '../contexts/AuthContext';
import OrderStateItem from './components/OrderStateItem';
import CancelOrderModal from '../models/CancelOrderModal';
import ReviewOrderModal from '../models/ReviewOrderModal';

const OrderCard: FC<orderCardInfo> = (orderInfo) => {
    const authContextData = useContext<authContextProps>(AuthContext);
    const [showStory, setShowStory] = useState(false);
    const [showCancelModel, setShowCancelModal] = useState(false);
    const [showReviewModel, setShowReviewModal] = useState(false);

    const handleShowCancelModal = () =>{
        setShowCancelModal(true);
    }

    const handleCloseCancelModal = () =>{
        setShowCancelModal(false);
    }

    const handleShowReviewModal = () =>{
        setShowReviewModal(true);
    }

    const handleCloseReviewModal = () =>{
        setShowReviewModal(false);
    }

    const handleCancelClick = (reasonOfCancel:string): void => {
        orderInfo.DeleteOrder(orderInfo.id, reasonOfCancel);
        setShowCancelModal(false);
    }

    const handleSendReviewClick = async (review:string, rating:number)=>{
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/reviewOrder`, {
            method: "POST",
            credentials: "include",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({ orderId: orderInfo.id, review, clientRating:rating })
        });

        if (resp1.ok) {
            setShowReviewModal(false);
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleShowStoryClick = (): void => {
        setShowStory(!showStory);
    }

    const handleMoveToNextOrderStage = ():void => {
        const orderStory = orderInfo.story as orderState[];
        orderInfo.MoveOrderToNextStage(orderInfo.id, orderStory[orderStory.length - 1].orderStateId)
    }

    const handleMoveToPreviousOrderStage = ():void => {
        const orderStory = orderInfo.story as orderState[];
        orderInfo.MoveOrderToPreviousStage(orderInfo.id, orderStory[orderStory.length - 1].orderStateId)
    }

    let clientCanCancelOrder:Boolean = false;
    if(orderInfo.story != null ){
        const curOrderStatus = orderInfo.story[orderInfo.story.length-1];
        clientCanCancelOrder = (authContextData.isClient && curOrderStatus.numberOfStage != 16 && curOrderStatus.numberOfStage != 32) as Boolean;
    }

    let clientCanReviewOrder:Boolean = false;
    if(orderInfo.story != null ){
        const curOrderStatus = orderInfo.story[orderInfo.story.length-1];
        clientCanReviewOrder = (authContextData.isClient && curOrderStatus.numberOfStage == 16  && orderInfo.canWriteReview) as Boolean;
    }

    return (
        <>
            <Card className="mt-2 bg-light">
                <Row className="g-0 align-items-center">
                    <Col className="col-md">
                        <Card.Body>
                            <Card.Title>Номер заказа: {orderInfo.id}</Card.Title>
                            <Row className='mb-2 d-flex justify-content-between'>
                                <Col className='col-auto'>
                                    <Card.Text>Стоимость:{orderInfo.price}</Card.Text>
                                </Col>
                                <Col className='col-auto'>
                                    <Card.Text>Адрес доставки: {orderInfo.deliveryAddress}</Card.Text>
                                </Col>
                                <Col className='col-auto'>
                                    <Card.Text>Номер клиента: {orderInfo.phoneNumber}</Card.Text>
                                </Col>
                            </Row>

                            {orderInfo.story != null && <Card.Text>Статус: {orderInfo.story[orderInfo.story.length-1].nameOfState}</Card.Text>}
                            <Row className='d-flex justify-content-center'>
                                <Col className='col-10 col-lg-auto me-lg-auto mt-2'>
                                    <Link href={(authContextData.isAdmin ? '/admin':'/profile') + "/order?orderId=" + orderInfo.id} className='btn btn-secondary w-100'>Посмотреть детали</Link>
                                </Col>
                                {(authContextData.isAdmin || clientCanCancelOrder) &&
                                    <Col className='col-10 col-lg-auto mt-2'>
                                        <button className='btn btn-danger w-100' onClick={handleShowCancelModal}>Отменить</button>
                                    </Col>}
                                {clientCanReviewOrder &&
                                    <Col className='col-10 col-lg-auto mt-2'>
                                        <button className='btn btn-primary w-100' onClick={handleShowReviewModal}>Написать отзыв</button>
                                    </Col>}
                                <Col className='col-10 col-lg-auto mt-2'>
                                    <button className='btn btn-secondary w-100' onClick={handleShowStoryClick}>{showStory ? 'Скрыть':'Показать'} историю заказа</button>
                                </Col>
                                {showStory && orderInfo.story?.map((value,i)=><OrderStateItem key={i} {...value}/>)}
                                {((showStory && authContextData.isAdmin) || authContextData.isKitchenWorker) && 
                                    <Row className='d-flex justify-content-center'>
                                        <Col className='col-auto mt-2'>
                                            <button className='btn btn-danger w-100' onClick={handleMoveToPreviousOrderStage}>Вернуть к предыдущей стадии</button>
                                        </Col>
                                        <Col className='col-auto mt-2'>
                                            <button className='btn btn-danger w-100' onClick={handleMoveToNextOrderStage}>Перевести в следующую стадию</button>
                                        </Col>
                                    </Row>
                                }
                            </Row>
                            
                        </Card.Body>
                    </Col>
                </Row>
            </Card>
            {showCancelModel && <CancelOrderModal show={showCancelModel} closeModel={handleCloseCancelModal} commitCancelOrder={handleCancelClick}/>}
            {showReviewModel && <ReviewOrderModal show={showReviewModel} closeModel={handleCloseReviewModal} commitAction={handleSendReviewClick}/>}
        </>
    );
}

export default OrderCard;


UserCard.tsx
import React, { FC, ReactElement, useEffect, useState } from 'react';
import { Card, Col, Row, Button, Form } from 'react-bootstrap';

const UserCard: FC<{ userInfo: profileInfo, markUser: (userId: string) => void, unmarkUser: (userId: string) => void, }> = ({ userInfo, markUser, unmarkUser }) => {
    const [showMoreInfo, setShowMoreInfo] = useState(false);
    const [unmarked, setUnmarked] = useState(true);

    const handleShowStoryClick = (): void => {
        setShowMoreInfo(!showMoreInfo);
    }

    const handleClickToCheckBox = (): void => {
        if (unmarked) {
            markUser(userInfo.id as string);
        }
        else {
            unmarkUser(userInfo.id as string);
        }
        setUnmarked(!unmarked);
    }

    return (
        <>
            <Card className="mt-2 bg-light">
                <Row className="g-0 align-items-center">
                    <Card.Body>
                        <Row className='d-flex justify-content-start'>
                            <Col xs={12} lg='auto' className='mt-1'>
                                <Card.Title>Id: {userInfo.id}</Card.Title>
                            </Col>
                            <Col xs={12} lg='auto' className='mt-1 me-auto'>
                                <Card.Text className='m-0'>Роли пользователя: {userInfo.roles}</Card.Text>
                            </Col>
                            <Col xs={12} lg='auto' className='mt-1 d-flex justify-content-end me-auto '>
                                <Form className='d-flex justify-content-end'>
                                    <Form.Check reverse type="switch" onClick={handleClickToCheckBox} label="Выбрать пользователя" />
                                </Form>
                            </Col>
                        </Row>
                        <Row className='d-flex justify-content-start'>
                            <Col xs={12} lg='auto' className='me-lg-auto mt-1'>
                                <Card.Text>Логин пользователя: {userInfo.login}</Card.Text>
                            </Col>
                            {userInfo.isBlocked &&
                                <Col xs={12} lg='auto' className='mt-1'>
                                    <Card.Text className='text-danger'>Заблокирован</Card.Text>
                                </Col>}
                            <Col xs={12} lg='auto' className='mt-1'>
                                <Button className='btn btn-secondary w-100' onClick={handleShowStoryClick}>{showMoreInfo ? 'Скрыть' : 'Показать'} подробную информацию</Button>
                            </Col>
                        </Row>
                        {showMoreInfo &&
                            <>
                                <Row className='d-flex justify-content-start'>
                                    <Col md='auto' className='mt-1'>
                                        <Card.Text>Имя: {userInfo.name}</Card.Text>
                                    </Col>
                                    <Col md='auto' className='mt-1'>
                                        <Card.Text>Дата рождения: {new Date(userInfo.born as string).toLocaleDateString()}</Card.Text>
                                    </Col>
                                    <Col md='auto' className='mt-1'>
                                        <Card.Text>Номер телефона: {userInfo.phoneNumber}</Card.Text>
                                    </Col>
                                </Row>
                                <Row className='d-flex justify-content-start'>
                                    <Col md='auto' className='mt-1'>
                                        <Card.Text>Адрес: {userInfo.address}</Card.Text>
                                    </Col>
                                </Row>
                            </>
                        }
                    </Card.Body>
                </Row>
            </Card>
        </>
    );
}

export default UserCard;


WorkerCard.tsx
import React, { FC, useState } from 'react';
import { Card, Col, Row, Button } from 'react-bootstrap';

const WorkerCard: FC<{ userInfo: profileInfo }> = ({ userInfo }) => {
    const [showMoreInfo, setShowMoreInfo] = useState(false);

    const handleShowStoryClick = (): void => {
        setShowMoreInfo(!showMoreInfo);
    }

    return (
        <>
            <Card className="mt-2 bg-light">
                <Row className="g-0 align-items-center">
                    <Card.Body>
                        <Row className='d-flex justify-content-start'>
                            <Col xs={12} lg='auto' className='mt-1'>
                                <Card.Title>Id: {userInfo.id}</Card.Title>
                            </Col>
                            <Col xs={12} lg='auto' className='mt-1'>
                                <Card.Title>Должность: {userInfo.jobTitle}</Card.Title>
                            </Col>
                        </Row>
                        <Row className='d-flex justify-content-start'>
                            <Col xs={12} lg='auto' className='me-lg-auto mt-1'>
                                <Card.Text>Имя: {userInfo.name}</Card.Text>
                            </Col>
                            <Col xs={12} lg='auto' className='me-lg-auto mt-1'>
                                <Card.Text>Логин пользователя: {userInfo.login}</Card.Text>
                            </Col>
                            {userInfo.isBlocked &&
                                <Col xs={12} lg='auto' className='mt-1'>
                                    <Card.Text className='text-danger'>Заблокирован</Card.Text>
                                </Col>}
                            <Col xs={12} lg='auto' className='mt-1'>
                                <Button className='btn btn-secondary w-100' onClick={handleShowStoryClick}>{showMoreInfo ? 'Скрыть' : 'Показать'} подробную информацию</Button>
                            </Col>
                        </Row>
                        {showMoreInfo &&
                            <Row className='d-flex justify-content-start'>
                                <Col md='auto' className='mt-1'>
                                    <Card.Text>Получил работу: {new Date (userInfo.gotJob as Date).toLocaleDateString()}</Card.Text>
                                </Col>
                                <Col md='auto' className='mt-1'>
                                    <Card.Text>Дата рождения: {new Date(userInfo.born as string).toLocaleDateString()}</Card.Text>
                                </Col>
                                <Col md='auto' className='mt-1'>
                                    <Card.Text>Номер телефона: {userInfo.phoneNumber}</Card.Text>
                                </Col>
                            </Row>
                        }
                    </Card.Body>
                </Row>
            </Card>
        </>
    );
}

export default WorkerCard;


CounterCartDish.tsx
import React, { FC, useState } from 'react';
import styles from '@/styles/Home.module.css'
import { useCookies } from 'react-cookie';
import { Button, Col, Row } from 'react-bootstrap';


const CounterCartDish: FC<{ dishId: string, cancelDish: (dishId: string) => void }> = ({ dishId, cancelDish }) => {
    const [cookies, setCookie] = useCookies(['cartDishes']);
    const [count, setCount] = useState(Number.parseInt(cookies?.cartDishes[dishId]) ?? 1);

    //Изменяет количество блюд, находящихся в корзине
    const changeCountDishToCookies = (): void => {
        cookies.cartDishes[dishId] = count;

        setCookie('cartDishes', JSON.stringify(cookies.cartDishes), { path: '/', sameSite: "none", secure: true })
    };

    const handleChangeCountClick = (countToAdd: number): void => {
        setCount((count) => {
            let sum = count + countToAdd;
            return sum > 20 || sum < 1 ? count : sum;
        });
    }

    //Удаляет свойство с id текущего блюда из куки, обновляет куки, удаляет блюдо из списка
    const handleCancelClick = (): void => {
        delete cookies.cartDishes[dishId];
        setCookie('cartDishes', JSON.stringify(cookies.cartDishes), { path: '/', sameSite: "none", secure: true })
        cancelDish(dishId);
    }

    return (
        <>
            <Row className='d-flex justify-content-end pe-md-3'>
                <Col xs={12} md={4} className='d-flex justify-content-md-start justify-content-center mt-2'>
                    <Button onClick={handleCancelClick} className={`btn btn-danger me-2`}>
                        Отменить
                    </Button>
                </Col>
                <Col xs={12} md={4} className='mt-2'>
                    <Row className='d-flex justify-content-md-end justify-content-center'>
                        <Button onClick={() => handleChangeCountClick(1)} className={`btn btn-secondary ${styles.cardCountBtnAndP}`}>
                            +
                        </Button>
                        <div className={`d-flex align-items-center justify-content-center ${styles.cardCountBtnAndP}`}>
                            <p className='m-0'>
                                {count}
                            </p>
                        </div>
                        <Button onClick={() => handleChangeCountClick(-1)} className={`btn btn-secondary ${styles.cardCountBtnAndP}`}>
                            -
                        </Button>
                    </Row>
                </Col>
                <Col xs={12} md={4} className='d-flex justify-content-md-start justify-content-center mt-2'>
                    <Button onClick={changeCountDishToCookies}>
                        Изменить количество
                    </Button>
                </Col>
            </Row>
        </>
    );
}

export default CounterCartDish;


CounterMainDish.tsx
import React, { FC, useState } from 'react';
import styles from '@/styles/Home.module.css'
import { useCookies } from 'react-cookie';
import { Button } from 'react-bootstrap';


const CounterMainDish: FC<{dishId: string}> = ({dishId}) => {
    const [count, setCount] = useState(1);
    const [cookies, setCookie] = useCookies(['cartDishes']);    

    //Добавляет количество блюд, к находящимся в корзине
    const addCountDishToCookies = ():void => {
        let futureCookie:any = {};
        if(cookies.cartDishes != undefined)
            futureCookie = cookies.cartDishes;

        var countCurDish = futureCookie[dishId] ?? 0;

        futureCookie[dishId] = countCurDish + count;

        setCookie('cartDishes', JSON.stringify(futureCookie), { path: '/', sameSite: "none", secure: true });
    };

    const handleClick = (countToAdd: number): void => {
        setCount((count) => {
            let sum = count + countToAdd;
            return sum > 20 || sum < 1 ? count : sum;
        });
    }

    return (
        <>
            <div className='d-flex justify-content-end pe-md-3'>
                <button onClick={() => handleClick(1)} className={`btn btn-secondary ${styles.cardCountBtnAndP}`}>
                    +
                </button>
                <div className={`d-flex align-items-center justify-content-center ${styles.cardCountBtnAndP}`}>
                    <p className='m-0'>
                        {count}
                    </p>
                </div>
                <button onClick={() => handleClick(-1)} className={`btn btn-secondary me-2 ${styles.cardCountBtnAndP}`}>
                    -
                </button>
                <Button onClick={addCountDishToCookies}>
                    Добавить в корзину
                </Button>
            </div>
        </>
    );
}

export default CounterMainDish;


CounterOrderDish.tsx
import React, { FC, useState } from 'react';
import styles from '@/styles/Home.module.css'
import { Button, Col, Row } from 'react-bootstrap';

interface CounterOrderDishProps { 
    dishId: string, 
    cancelDish: (dishId: string) => void, 
    changeCountDish: (dishId: string, newCount:number) => void, 
    countOrdered: number,
}

const CounterOrderDish: FC<CounterOrderDishProps> = ({ dishId, cancelDish, changeCountDish, countOrdered }) => {
    const [count, setCount] = useState(countOrdered);

    const handleChangeCountClick = (countToAdd: number) => {
        setCount((count) => {
            let sum = count + countToAdd;
            return sum > 20 || sum < 1 ? count : sum;
        });
    }

    const handleCommitChangeCountClick = async () =>{
        changeCountDish(dishId, count);
    }

    const handleCancelClick = (): void => {
        cancelDish(dishId);
    }

    return (
        <>
            <Row className='d-flex justify-content-end pe-md-3'>
                <Col xs={12} md={4} className='d-flex justify-content-md-start justify-content-center mt-2'>
                    <Button onClick={handleCancelClick} className={`btn btn-danger me-2`}>
                        Отменить
                    </Button>
                </Col>
                <Col xs={12} md={4} className='mt-2'>
                    <Row className='d-flex justify-content-md-end justify-content-center'>
                        <Button onClick={() => handleChangeCountClick(1)} className={`btn btn-secondary ${styles.cardCountBtnAndP}`}>
                            +
                        </Button>
                        <div className={`d-flex align-items-center justify-content-center ${styles.cardCountBtnAndP}`}>
                            <p className='m-0'>
                                {count}
                            </p>
                        </div>
                        <Button onClick={() => handleChangeCountClick(-1)} className={`btn btn-secondary ${styles.cardCountBtnAndP}`}>
                            -
                        </Button>
                    </Row>
                </Col>
                <Col xs={12} md={4} className='d-flex justify-content-md-start justify-content-center mt-2'>
                    <Button onClick={handleCommitChangeCountClick}>
                        Изменить количество
                    </Button>
                </Col>
            </Row>
        </>
    );
}

export default CounterOrderDish;


HandlerAdminDish.tsx
import React, { FC, useState } from 'react';
import styles from '@/styles/Home.module.css'
import { useCookies } from 'react-cookie';
import { Button, Col, Row } from 'react-bootstrap';
import Link from 'next/link';

interface HandlerAdminDishProps {
    dishId: string, 
    dishDeleted: boolean, 
    isVisibleForUsers: boolean, 
    changeDeleteStateDish: (dishId:string)=>void,
    changeVisibleStateDish: (dishId:string)=>void,
}

const HandlerAdminDish: FC<HandlerAdminDishProps> = ({ dishId, dishDeleted, isVisibleForUsers, changeDeleteStateDish, changeVisibleStateDish }) => {

    const handleDeleteStateDish = () =>{
        changeDeleteStateDish(dishId);
    }

    const handleVisibleStateDish = () =>{
        changeVisibleStateDish(dishId);
    }

    return (
        <>
            <Row className='ms-1 d-flex justify-content-center'>
                <Col xs='auto' className='mt-1 mt-xxl-0'>
                    <Link href={"/admin/changeDish?dishId=" + dishId} className={`btn btn-secondary`}>
                        Изменить блюдо
                    </Link>
                </Col>
                <Col xs='auto' className='mt-1 mt-xxl-0'>
                    <Button onClick={handleDeleteStateDish} className={`btn btn-secondary`}>
                        {dishDeleted ? "Восстановить блюдо" : "Удалить блюдо"}
                    </Button>
                </Col>
                <Col xs='auto' className='mt-1 mt-xxl-0'>
                    <Button onClick={handleVisibleStateDish} className={`btn btn-secondary`}>
                        {isVisibleForUsers ? "Скрыть от пользователей" : "Сделать доступным для пользователей"}
                    </Button>
                </Col>
            </Row>
        </>
    );
}

export default HandlerAdminDish;


OrderStateItem.tsx
import React, { FC, useState } from 'react';
import { Card, Col, Row } from 'react-bootstrap';

const OrderStateItem: FC<orderState> = (orderState) => {

    return (
        <Card className='mt-2'>
            <Row className='p-md-1'>
                <Col xs={12} md={5} >
                    <div>Статус: {orderState.nameOfState}</div>
                </Col>
                <Col xs={12} md={7} >
                    <div>Время начала стадии: {orderState.timeStartState.toLocaleString()}</div>
                </Col>
            </Row>
            <Row className='p-md-1'>
                <Col xs={12} >
                    <div>Описание стадии: {orderState.descriptionForClient}</div>
                </Col>
            </Row>
            <Row className='p-md-1'>
                <Col xs={12} >
                    <div>Комментарий: {orderState.comment}</div>
                </Col>
            </Row>
        </Card>
    );
}

export default OrderStateItem;


customMap.tsx
import { MapContext } from "../contexts/MapContext";
import { FC, ReactNode, useEffect, useRef, useState } from "react";
import * as ol from "ol";
import { MapOptions } from "ol/Map";

const CustomMap: FC<{ children: ReactNode, zoom: number, center: Array<number> }> = ({ children, zoom, center }) => {
    const mapRef = useRef<HTMLDivElement | null>(null);
    const [map, setMap] = useState<ol.Map | null>(null);
    
    // on component mount
    useEffect(() => {
        const options:MapOptions = {
            view: new ol.View({ zoom, center }),
            layers: [],
            controls: [],
            overlays: []
        };
        const mapObject = new ol.Map(options);
        mapObject.setTarget(mapRef.current as string | HTMLElement | undefined);
        setMap(mapObject);
        return () => mapObject.setTarget(undefined);
    }, []);
    // zoom change handler
    useEffect(() => {
        if (!map) return;
        map.getView().setZoom(zoom);
    }, [zoom]);
    // center change handler
    useEffect(() => {
        if (!map) return;
        map.getView().setCenter(center)
    }, [center])
    return (
        <MapContext.Provider value={{ map }}>
            <div ref={mapRef} style={{height:'500px'}} >
                {children}
            </div>
        </MapContext.Provider>
    )
}
export default CustomMap;
Layers.tsx
import React, { FC, ReactNode } from "react";

const Layers: FC<{ children: ReactNode }> = ({ children }) => {
  return (<div>
        {children}
    </div>);
};

export default Layers;

TitleLayer.tsx
import { FC, useContext, useEffect } from "react";
import OLTileLayer from "ol/layer/Tile";
import { MapContext } from "@/components/contexts/MapContext";
import * as ol from "ol";
import { Options } from "ol/layer/Layer";

interface mapContextProps {
    map: ol.Map | null,
}

const TileLayer:FC<Options<any>> = ({ source, zIndex = 0 }) => {
  const { map } = useContext<mapContextProps>(MapContext); 
  useEffect(() => {
    if (!map) return;
    
    let tileLayer = new OLTileLayer({
      source,
      zIndex,
    });
    map.addLayer(tileLayer);
    tileLayer.setZIndex(zIndex);
    return () => {
      if (map) {
        map.removeLayer(tileLayer);
      }
    };
  }, [map]);
  return null;
};
export default TileLayer;
CancelOrderModal.tsx
import React, { ChangeEvent, FC, useState } from 'react';
import { Form } from 'react-bootstrap';
import Button from 'react-bootstrap/Button';
import Modal from 'react-bootstrap/Modal';

interface CancelOrderModelProps {
    show: boolean | undefined,
    commitCancelOrder: (reasonOfCancel: string) => void,
    closeModel: () => void,
}

const CancelOrderModal: FC<CancelOrderModelProps> = ({ show, commitCancelOrder, closeModel }) => {
    const [reasonOfCancel, setReasonOfCancel] = useState("")

    const changeTextOfReason = (e:ChangeEvent<HTMLInputElement>) => {
        const newValue = e.target.value;
        setReasonOfCancel(newValue);
    }

    const handleCommit = async () => {
        commitCancelOrder(reasonOfCancel)
    }

    return (
        <>
            <Modal show={show} onHide={closeModel} keyboard={false} aria-labelledby="contained-modal-title-vcenter">
                <Modal.Header closeButton>
                    <Modal.Title>Отмена заказа</Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    <Form>
                        <Form.Group className="mb-3">
                            <Form.Label>Пожалуйста, введите причину, из-за которой Вы отменяете заказ: </Form.Label>
                            <Form.Control as="textarea" rows={3} value={reasonOfCancel} onChange={changeTextOfReason}/>
                        </Form.Group>
                    </Form>
                </Modal.Body>
                <Modal.Footer>
                    <Button variant="secondary" onClick={closeModel}>
                        Закрыть
                    </Button>
                    <Button variant="primary" onClick={handleCommit}>Отменить заказ</Button>
                </Modal.Footer>
            </Modal>
        </>
    );
}

export default CancelOrderModal;
PlaceAnOrderModal.tsx
import React, { ChangeEvent, FC, useEffect, useState } from 'react';
import { Form } from 'react-bootstrap';
import Button from 'react-bootstrap/Button';
import Modal from 'react-bootstrap/Modal';

interface PlaceAnOrderModelProps {
    show: boolean | undefined,
    commitAction: (userAddress: string, userPhoneNumber: string, comment: string) => void,
    closeModel: () => void,
}

const PlaceAnOrderModal: FC<PlaceAnOrderModelProps> = ({ show, commitAction, closeModel }) => {
    const [address, setAddress] = useState("")
    const [phoneNumber, setPhoneNumber] = useState("")
    const [comment, setComment] = useState("")

    const changeAddress = (e:ChangeEvent<HTMLInputElement>) => {
        const newValue = e.target.value;
        setAddress(newValue);
    }

    const changePhoneNumber = (e:ChangeEvent<HTMLInputElement>) => {
        const newValue = e.target.value;
        setPhoneNumber(newValue);
    }

    const changeComment = (e:ChangeEvent<HTMLInputElement>) => {
        const newValue = e.target.value;
        setComment(newValue);
    }

    const handleCommit = async () => {
        if(address == "" || phoneNumber == "")
        {
            alert("Для оформления заказа необходимо ввести ваш номер телефона и адрес")
            return;
        }
        commitAction(address, phoneNumber, comment)
    }

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getProfileInfo`, {
                credentials: 'include',
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                }, 
            });

            if(resp.ok){
                const profileInfo = await resp.json() as {address: string, phoneNumber: string};
                setAddress(profileInfo.address);
                setPhoneNumber(profileInfo.phoneNumber);
            }        
            else{
                const errorText = await resp.text()
                if(errorText != "")
                    alert(errorText);
            }
        }
        fetchData();
    }, []);

    return (
        <>
            <Modal show={show} onHide={closeModel} keyboard={false} aria-labelledby="contained-modal-title-vcenter">
                <Modal.Header closeButton>
                    <Modal.Title>Оформление заказа</Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    <Form>
                        <Form.Group className="mb-3" >
                            <Form.Label>Пожалуйста, введите адрес, по которому необходимо доставить заказ: </Form.Label>
                            <Form.Control type="text" value={address} onChange={changeAddress}/>
                        </Form.Group>
                        <Form.Group className="mb-3">
                            <Form.Label>Пожалуйста, введите свой номер телефона: </Form.Label>
                            <Form.Control type="tel" placeholder="+7" maxLength={12} value={phoneNumber} onChange={changePhoneNumber}/>
                        </Form.Group>
                        <Form.Group className="mb-3">
                            <Form.Label>Комментарий к заказу: </Form.Label>
                            <Form.Control as="textarea" rows={2} value={comment} onChange={changeComment}/>
                        </Form.Group>
                    </Form>
                </Modal.Body>
                <Modal.Footer>
                    <Button variant="secondary" onClick={closeModel}>
                        Закрыть
                    </Button>
                    <Button variant="primary" onClick={handleCommit}>Оформить заказ</Button>
                </Modal.Footer>
            </Modal>
        </>
    );
}

export default PlaceAnOrderModal;
ReviewOrderModal.tsx
import React, { ChangeEvent, FC, useState } from 'react';
import { Form, Row } from 'react-bootstrap';
import Button from 'react-bootstrap/Button';
import Modal from 'react-bootstrap/Modal';
import styles from '@/styles/Home.module.css'

interface ReviewOrderModelProps {
    show: boolean | undefined,
    commitAction: (review: string, rating:number) => void,
    closeModel: () => void,
}

const ReviewOrderModal: FC<ReviewOrderModelProps> = ({ show, commitAction, closeModel }) => {
    const [clientReview, setClientReview] = useState("")
    const [rating, setRating] = useState(10);

    const changeTextOfReason = (e: ChangeEvent<HTMLInputElement>) => {
        const newValue = e.target.value;
        setClientReview(newValue);
    }

    const handleCommit = async () => {
        commitAction(clientReview, rating)
    }

    const handleChangeCountClick = (countToAdd: number): void => {
        setRating((count) => {
            let sum = count + countToAdd;
            return sum > 10 || sum < 1 ? count : sum;
        });
    }

    return (
        <>
            <Modal show={show} onHide={closeModel} keyboard={false} aria-labelledby="contained-modal-title-vcenter">
                <Modal.Header closeButton>
                    <Modal.Title>Отзыв</Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    <Form>
                        <Form.Group className="mb-3">
                            <Form.Label>Ваша оценка: </Form.Label>
                            <Row className='d-flex justify-content-center'>
                                <Button onClick={() => handleChangeCountClick(1)} className={`btn btn-secondary ${styles.cardCountBtnAndP}`}>
                                    +
                                </Button>
                                <div className={`d-flex align-items-center justify-content-center ${styles.cardCountBtnAndP}`}>
                                    <p className='m-0'>
                                        {rating}
                                    </p>
                                </div>
                                <Button onClick={() => handleChangeCountClick(-1)} className={`btn btn-secondary ${styles.cardCountBtnAndP}`}>
                                    -
                                </Button>
                            </Row>
                        </Form.Group>
                        <Form.Group className="mb-3">
                            <Form.Label>Пожалуйста, введите отзыв: </Form.Label>
                            <Form.Control as="textarea" value={clientReview} onChange={changeTextOfReason} />
                        </Form.Group>
                    </Form>
                </Modal.Body>
                <Modal.Footer>
                    <Button variant="secondary" onClick={closeModel}>
                        Закрыть
                    </Button>
                    <Button variant="primary" onClick={handleCommit}>Оставить отзыв</Button>
                </Modal.Footer>
            </Modal>
        </>
    );
}

export default ReviewOrderModal;
BarChart.tsx
import { ChartData } from "chart.js";
import { FC, useEffect, useState } from "react";
import { Bar } from 'react-chartjs-2';
import ChartDataLabels from 'chartjs-plugin-datalabels';

import {
    Chart as ChartJS,
    CategoryScale,
    LinearScale,
    BarElement,
    Title,
    Tooltip,
    Legend,
  } from 'chart.js';
  
  ChartJS.register(
    CategoryScale,
    LinearScale,
    BarElement,
    Title,
    Tooltip,
    Legend
  );

  function getRandomInt(max:number) {
    return Math.floor(Math.random() * max);
}

const BarChart: FC<{ query:statisticQueryInfo }> = ({ query }) => {
    const [chartData, setChartData] = useState<ChartData<"bar">>();

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/statistic/${query.linkToQuery}`, {
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                },
            });

            if(resp.ok){
                const resInfo = await resp.json() as statisticQueryDataItem[];
    
                const data:{labels:string[], datasets:any} = {
                    labels: resInfo.map((value) => value.x),
                    datasets: [],
                }
                
                for( let i = 0; i < (query.nameDatasets?.length ?? 1); i++)
                {
                    data.datasets.push({
                        label: query.nameDatasets == null ? query.nameQuery : query.nameDatasets[i],
                        data: resInfo.map((value) => value.y[i]),
                        borderColor: `rgb(${getRandomInt(255)}, ${getRandomInt(255)}, ${getRandomInt(255)})`,
                        backgroundColor: `rgb(${getRandomInt(255)}, ${getRandomInt(255)}, ${getRandomInt(255)})`,
                        borderWidth: 1,
                    });
                };
    
                setChartData(data);
            }
            else{
                alert(await resp.text());
            }

        }
        fetchData();
    }, [query]);

    const options = {
        plugins: {
            datalabels: {
                color: '#000',
                font: {
                    weight: 'bold' as 'bold'
                },
                align: 'center' as 'center'
              }
        },
    };

    return (
        <>
            {chartData != undefined && <Bar plugins={[ChartDataLabels]} options={options} data={chartData}/>}
        </>    
    );
}

export default BarChart;
LineChart.tsx
import { ChartData } from "chart.js";
import { FC, useEffect, useState } from "react";
import { Line } from "react-chartjs-2";
import ChartDataLabels from 'chartjs-plugin-datalabels';

import {
    Chart as ChartJS,
    CategoryScale,
    LinearScale,
    PointElement,
    LineElement,
    Title,
    Tooltip,
    Legend,
  } from 'chart.js';

  ChartJS.register(
    CategoryScale,
    LinearScale,
    PointElement,
    LineElement,
    Title,
    Tooltip,
    Legend,
  );

const LineChart: FC<{ query:statisticQueryInfo }> = ({ query }) => {
    const [chartsData, setChartsData] = useState<ChartData<"line">[]>([]);

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/statistic/${query.linkToQuery}`, {
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                },
            });

            if(resp.ok){
                const resInfo = await resp.json() as statisticQueryDataItem[];
    
                const datasets:ChartData<"line">[] = [];
                
                for( let i = 0; i < (query.nameDatasets?.length ?? 1); i++)
                {
                    datasets.push({
                        labels: resInfo.map((value) => value.x),
                        datasets: [
                            {
                                label: query.nameDatasets == null ? query.nameQuery : query.nameDatasets[i] ,
                                data: resInfo.map((value) => value.y[i]),
                                borderColor: 'rgb(255, 99, 132)',
                                backgroundColor: '#7E07A9',
                            },
                        ],
                    });
                };
    
                setChartsData(datasets);
            }
            else{
                alert(await resp.text());
            }
           
        }
        fetchData();
    }, [query]);

    const options = {
        plugins: {
            datalabels: {
                color: '#000',
                font: {
                    weight: 'bold' as 'bold'
                },
                align: 'left' as 'left'
              }
        },
    };

    return (
        <>
            {chartsData.map((chartData, i) => <Line key={i} plugins={[ChartDataLabels]} options={options} data={chartData}/>) }
        </>    
    );
}

export default LineChart;
RadarChart.tsx
import { ChartData } from "chart.js";
import { FC, useEffect, useState } from "react";
import { Radar } from 'react-chartjs-2';
import ChartDataLabels from 'chartjs-plugin-datalabels';

import {
    Chart as ChartJS,
    RadialLinearScale,
    PointElement,
    LineElement,
    Filler,
    Tooltip,
    Legend,
  } from 'chart.js';
  
  ChartJS.register(
    RadialLinearScale,
    PointElement,
    LineElement,
    Filler,
    Tooltip,
    Legend
  );

function getRandomInt(max:number) {
    return Math.floor(Math.random() * max);
}

const RadarChart: FC<{ query:statisticQueryInfo }> = ({ query }) => {
    const [chartData, setChartData] = useState<ChartData<"radar">>();

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/statistic/${query.linkToQuery}`, {
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                },
            });

            if(resp.ok){
                const resInfo = await resp.json() as {queryData: statisticQueryDataItem[], nameDatasets:string[]};
    
                const data:{labels:string[], datasets:any} = {
                    labels: resInfo.queryData.map((value) => value.x),
                    datasets: [],
                }
                
                for( let i = 0; i < resInfo.nameDatasets.length; i++)
                {
                    data.datasets.push({
                        label: resInfo.nameDatasets[i] ,
                        data: resInfo.queryData.map(value => value.y[i]),
                        borderColor: `rgb(${getRandomInt(255)}, ${getRandomInt(255)}, ${getRandomInt(255)}, 0.5)`,
                        backgroundColor: `rgb(${getRandomInt(255)}, ${getRandomInt(255)}, ${getRandomInt(255)}, 0.3)`,
                        borderWidth: 1,
                        fill: true,
                    });
                };
    
                setChartData(data);
            }
            else{
                alert(await resp.text());
            }
        }
        fetchData();
    }, [query]);

    const options = {
        plugins: {
            datalabels: {
                color: '#000',
                font: {
                    weight: 'bold' as 'bold'
                },
                align: 'top' as 'top'
              }
        },
    };

    return (
        <>
            {chartData != undefined && <Radar plugins={[ChartDataLabels]} options={options} data={chartData}/> }
        </>    
    );
}

export default RadarChart;
ClientLayout.tsx
import {FC, ReactNode} from "react"
import Sidebar from "./Sidebar";
import { Col, Container, Row } from "react-bootstrap";
import React from "react";

type clientLayoutProps = {
    children: ReactNode,
    categories:Array<categoryItem>,
}

const ClientLayout:FC<clientLayoutProps> = ({children, categories}) => (
        <>
            <Container fluid="xl" className="row pt-2 mx-auto mb-1">
                <Col xs={2} md={3} lg={2} className="g-0 px-1">
                    <Sidebar categories={categories}/> 
                </Col>
                <Col xs={10} md={9} lg={10} className="g-0">
                    {children}
                </Col>
            </Container>
        </>);

export default ClientLayout;
DishStandartLayout.tsx
import React, { FC, ReactNode, useState } from 'react';
import { Card, Col, Row, Carousel, Image } from 'react-bootstrap';
import styles from '@/styles/Home.module.css'
import Link from 'next/link';

const DishStandartLayout: FC<{ dishInfo: dishClientInfo, children: ReactNode }> = ({ dishInfo, children }) => {
    const [index, setIndex] = useState(0);

    const handleSelect = (selectedIndex: number): void => {
        setIndex(selectedIndex);
    };

    return (
        <Card className='mt-1'>
            <Row className='g-0'>
                <Col xs={12} sm={5} md={4} lg={3}>
                    <Carousel activeIndex={index} onSelect={handleSelect}>
                        {dishInfo.images?.slice(0, 3).map((value, i) =>
                            <Carousel.Item key={i}>
                                <Image className="d-block w-100" src={value} alt="First slide" />
                            </Carousel.Item>
                        )}
                    </Carousel>
                </Col>
                <Col xs={12} sm={7} md={8} lg={9}>
                    <Card.Body>
                        <Row className='align-items-center'>
                            <Col xs={9}>
                                <Link href={'/dishes/' + dishInfo.id} className={`${styles.linkWithoutDefaultStyles}`}>
                                    <h3>{dishInfo.name}</h3>
                                </Link>
                            </Col>
                            <Col ><p className='text-start text-lg-center m-0'>Цена: {dishInfo.price}р</p></Col>
                        </Row>
                        <Card.Text>
                            {dishInfo.description}
                        </Card.Text>
                        {children}
                    </Card.Body>
                </Col>
            </Row>
        </Card>
    );
}

export default DishStandartLayout;


Footer.tsx
import Link from "next/link";
import { FC } from "react"
import { Col, Container, NavbarBrand } from "react-bootstrap";
import FooterPanelItem from "../FooterPanelItem";
import Image from "next/image";

const questionsPanel:footerPanelInfo = 
{
    panelName: "Часто задаваемые вопросы",
    panelItems: [
        {
            itemName: "Как получить бонусы?",
            itemHref: "/",
        },
        {
            itemName: "Как связаться с менеджером?",
            itemHref: "/",
        },
        {
            itemName: "Как стать частью вашей команды?",
            itemHref: "/",
        },
        {
            itemName: "Какие доступны способы оплаты?",
            itemHref: "/",
        },
    ]
}
const informationPanel:footerPanelInfo = 
{
    panelName: "Общая информация",
    panelItems: [
        {
            itemName: "История сервиса",
            itemHref: "/",
        },
        {
            itemName: "Действия при возникновении проблем с сайтом",
            itemHref: "/",
        },
        {
            itemName: "Вакансии",
            itemHref: "/",
        },
    ]
}

const Footer: FC = () => {
    return (
        <Container className="row mx-auto">
            <Col md={4} xs={12} className="p-1 h-100">
                {FooterPanelItem(informationPanel)}
            </Col>
            <Col md={4} xs={12} className="p-1">
                {FooterPanelItem(questionsPanel)}
            </Col>
            <Col md={4} xs={12} className="order-md-first d-flex justify-content-center align-items-center p-1">
                <Link href="/">
                    <NavbarBrand>
                        <Image src="/2_logo.svg" alt="logo" width={220} height={80}/>
                    </NavbarBrand>
                </Link>
            </Col>
        </Container>
    );
}

export default Footer;
Header.tsx
import Link from "next/link";
import { FC, MouseEvent } from "react"
import { Button, Col, Container, NavbarBrand } from "react-bootstrap";
import styles from '@/styles/Home.module.css'
import { useRouter } from "next/router";
import Image from "next/image";

interface HeaderProps { 
    isAdmin: boolean, 
    isKitchenWorker: boolean,
    isDeliveryMan: boolean,
    isAuthed: boolean, 
    dropJwtToken: () => void
}

const Header: FC<HeaderProps> = ({isAuthed, dropJwtToken, isAdmin, isKitchenWorker, isDeliveryMan}) => {
    const router = useRouter();

    const logoutClickHandler = async (e:MouseEvent):Promise<void> => {
        e.preventDefault();

        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/auth/logout`, {
            method: "POST",
            credentials: 'include',
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            }, 
        });

        if(resp.ok)
        {
            dropJwtToken();
            router.push("/");
        }
        else{
            alert(await resp.text());
        }
        
    }

    const cartButtonVisibility:boolean = !(isAdmin || isKitchenWorker || isDeliveryMan);

    return (
        <Container fluid="xl" className="row pt-2 mx-auto">
            <Col sm={5} md={6} className="d-flex justify-content-center align-items-center">
                <Link href="/">
                    <NavbarBrand>
                        <Image src="/2_logo.svg" alt="logo" width={220} height={80}/>
                    </NavbarBrand>
                </Link>
            </Col>
            <Col sm={7} md={6} className="d-flex justify-content-end align-items-center">
                {cartButtonVisibility &&  <Col xs={isAuthed ? 4 : 6} sm={4} className={`p-1 ${styles.headerButton}`}>
                    <Link href='/cart' className="btn btn-primary w-100">
                        Корзина
                    </Link>
                </Col>}
                { isAuthed ? 
                    <>
                        <Col xs={4} sm={4} className={`p-1 ${styles.headerButton}`}>
                            <Link href='/profile' className="btn btn-primary w-100">
                                Профиль
                            </Link>
                        </Col>
                        <Col xs={4} sm={4} className={`p-1 ${styles.headerButton}`}>
                            <Button className="w-100" onClick={logoutClickHandler}>Выйти</Button>
                        </Col>
                    </>
                    :
                    <Col xs={6} sm={8} className={`p-1 ${styles.headerButton}`}>
                        <Link href='/login' className="btn btn-primary w-100 text-nowrap">
                            Войти/Регистрация
                        </Link>
                    </Col>
                }
            </Col>
        </Container>
    );
}

export default Header;
Layout.tsx
import {FC, ReactNode, useEffect, useState} from "react"
import MainNavbar from "./Navbar";
import Header from "./Header";
import Footer from "./Footer";
import React from "react";
import { AuthContext as AuthContext } from "../contexts/AuthContext";

type layoutProps = {
    children: ReactNode
}

const Layout:FC<layoutProps> = ({children}) =>  {
    const [isAuthed, setIsAuthed] = useState(false);
    const [roles, setRoles] = useState(["User"]);

    const DropJwtToken = () => {
        setRoles(["User"]);
        setIsAuthed(false);

        localStorage.removeItem("jwtToken");
        localStorage.removeItem("jwtTokenValidTo");
    };

    const JwtTokenIsValid = ():boolean => {
        const jwtTokenValidTo: string | null = localStorage.getItem("jwtTokenValidTo");

        if(jwtTokenValidTo == null || new Date(jwtTokenValidTo) < new Date()){
            return false;
        }

        return true;
    };

    const UpdateJwtToken = async () => {
        //Если пользователь авторизован и при этом
        //Если с jwt токеном все ок, то нет смысла его обновлять
        if(JwtTokenIsValid() && isAuthed == true)
            return;

        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/auth/refreshAccessToken`, {
            method: "POST",
            credentials: "include"
        });
    
        if(resp.ok){
            const token = await resp.json() as jsonTokenInfo;

            setRoles(token.roleNames);
            setIsAuthed(true);

            localStorage.setItem("jwtToken", token.jwtToken);
            localStorage.setItem("jwtTokenValidTo", token.validTo.toString());
        }
        else{
            DropJwtToken();
        }
    }

    useEffect(() => {
        UpdateJwtToken();
    },[isAuthed]);

    const authContextData = { 
        isAdmin: roles.includes("Admin"), 
        isClient: roles.includes("Client"), 
        isDeliveryMan: roles.includes("DeliveryMan"), 
        isKitchenWorker: roles.includes("KitchenWorker"), 
        isAuth: isAuthed, 
        toggleIsAuthed: () => setIsAuthed(true)
    };

    return (
        <>
            <Header {...authContextData} isAuthed={isAuthed} dropJwtToken={DropJwtToken}/>
            <MainNavbar {...authContextData} />
            <AuthContext.Provider value = {authContextData}>
                {children}
            </AuthContext.Provider>
            <Footer />
        </>
    );
};

export default Layout;
Navbar.tsx
import { Nav, Navbar, NavDropdown, Container, Button, Form } from 'react-bootstrap';
import { ChangeEvent, FC, useState } from "react";
import Link from 'next/link';
import Image from 'next/image';

const HorizontalMenuItems: Array<linkPanelItem> = [
    {
        itemName: "Главная",
        itemHref: "/",
    },
    {
        itemName: "Акции",
        itemHref: "/",
    },
    {
        itemName: "Доставка",
        itemHref: "/",
    },
];

const AdminPanelMenuItems: Array<linkPanelItem> = [
    {
        itemName: "Статистика",
        itemHref: "/admin/statistics",
    },
    {
        itemName: "Блюда",
        itemHref: "/admin/dishes",
    },
    {
        itemName: "Заказы",
        itemHref: "/admin/orders",
    },
    {
        itemName: "Пользователи",
        itemHref: "/admin/users",
    },
];

const KitchenPanelMenuItems: Array<linkPanelItem> = [
    {
        itemName: "Заказы кухни",
        itemHref: "/kitchen/orders",
    },
    {
        itemName: "Сотрудники кухни",
        itemHref: "/kitchen/workers",
    },
];

interface MainNavbarProps { 
    isAdmin: boolean, 
    isKitchenWorker: boolean 
}

const MainNavbar: FC<MainNavbarProps> = ({ isAdmin, isKitchenWorker }) => {
    const [searchValue, setSearchValue] = useState("");

    const changeSearchValue = (e: ChangeEvent<HTMLInputElement>): void => {
        e.preventDefault();
        setSearchValue(e.target.value);
    }

    return (
        <Navbar expand="md" className="upperNavbar">
            <Container>
                <Navbar.Toggle id="navbarToggle" aria-controls="offcanvasNavbar-expand" className="order-1 col-3" style={{color:"#FFF"}}></Navbar.Toggle>
                <Navbar.Collapse id="basic-navbar-nav" className='order-3'>
                    <Nav className="me-auto">
                        {HorizontalMenuItems.map((value, i) =>
                        (<Nav.Item className='mx-auto' key={i}>
                            <Link href={value.itemHref} className='nav-link' style={{color: "#FFF"}}>
                                {value.itemName}
                            </Link>
                        </Nav.Item>)
                        )}
                        {isAdmin &&
                            <NavDropdown className='mx-auto' title="Админ панель" id="nav-dropdown">
                                {AdminPanelMenuItems.map((value, i) => (
                                    <Nav.Item key={i} className='mx-auto'>
                                        <Link href={value.itemHref} className='dropdown-item pt-2 pb-2 nav-link'>
                                            {value.itemName}
                                        </Link>
                                    </Nav.Item>))
                                }
                            </NavDropdown>
                        }
                        {isKitchenWorker &&
                            <NavDropdown className='mx-auto' title="Панель кухни" id="nav-dropdown">
                                {KitchenPanelMenuItems.map((value, i) => (
                                    <Nav.Item key={i} className='mx-auto'>
                                        <Link href={value.itemHref} className='dropdown-item pt-2 pb-2'>
                                            {value.itemName}
                                        </Link>
                                    </Nav.Item>))
                                }
                            </NavDropdown>
                        }
                    </Nav>
                </Navbar.Collapse>
                <Form className="d-flex col-lg-4 col-md-5 col-8 order-md-4 order-2 ">
                    <Form.Control className='w-100' placeholder="Поиск" aria-describedby="basic-addon2" value={searchValue} onChange={changeSearchValue} />
                    <Button variant="outline-secondary" className='ms-1' id="button-addon2">
                        <Link href={searchValue.trim() != "" ? `/search?searchText=${searchValue.toLowerCase().trim()}` : '/'}>
                            <Image src="\loupe.svg" width="20" height="20" alt="Поиск"/>
                        </Link>
                    </Button>
                </Form>
            </Container>
        </Navbar>
    )
};

export default MainNavbar;
Sidebar.tsx
import { Nav, Navbar, Container, Offcanvas } from 'react-bootstrap';
import { FC, useEffect, useState } from "react"
import Link from 'next/link';
import styles from '@/styles/Home.module.css'

const Sidebar: FC<{ categories: Array<categoryItem> }> = ({ categories }) => {

    const [isFixed, setIsFixed] = useState(false);

    useEffect(() => {
      const handleScroll = () => {
        let heightOfHeaderAndNavBar = 32 + 56 + window.innerWidth >= 576 ? 88 : 133

        if (window.scrollY > heightOfHeaderAndNavBar && !isFixed) {
          setIsFixed(true);
        } else if (window.scrollY < heightOfHeaderAndNavBar && isFixed) {
          setIsFixed(false);
        }
      };
      window.addEventListener("scroll", handleScroll);
      window.addEventListener("resize", handleScroll);
      return () => {
        window.removeEventListener("scroll", handleScroll);
        window.removeEventListener("resize", handleScroll);
      };
    }, [isFixed]);

    return (
        <Navbar expand="md" style={{ maxHeight: "100vw", minHeight: "23vw", position: (isFixed?"fixed":"static"), top: "0px"}} className="h-100">
            <Container fluid className='h-100 align-items-start justify-content-end g-0 mx-auto'>
                <Navbar.Toggle aria-controls='offcanvasNavbar' className={`${styles.sidebarToggle} p-0 h-100`}>
                    <div className={`${styles.rotate90deg} align-items-center`}>Категории</div>
                </Navbar.Toggle>
                <Navbar.Offcanvas id='offcanvasNavbar' aria-labelledby='offcanvasNavbarLabel' placement="start">
                    <Offcanvas.Header closeButton>
                        <Offcanvas.Title id='offcanvasNavbarLabel'>
                            Категории
                        </Offcanvas.Title>
                    </Offcanvas.Header>
                    <Offcanvas.Body className='g-0'>
                        <Nav className="flex-column">
                            <Nav.Item className='w-100 d-none d-md-block p-2'>
                                <b>Категории</b>
                            </Nav.Item>
                            {categories?.map((value, i) =>
                            (<Nav.Item key={i} className='w-100 ms-2'>
                                <Link className="nav-link " href={`/categories/${value.linkName}`} >
                                    {value.name}
                                </Link>
                            </Nav.Item>)
                            )}
                        </Nav>
                    </Offcanvas.Body>
                </Navbar.Offcanvas>
            </Container>
        </Navbar>
    )
};

export default Sidebar;
AuthContext.ts
import React from "react"

export const AuthContext = React.createContext<authContextProps>({
    isAdmin: false,
    isClient: false,
    isDeliveryMan: false,
    isKitchenWorker: false,
    isAuth: false,
    toggleIsAuthed: ()=>{},
  });
MapContext.ts
import React from "react";
import * as ol from "ol";

interface mapContextProps {
    map: ol.Map | null,
}

export const MapContext = React.createContext<mapContextProps>({
    map: null
});
