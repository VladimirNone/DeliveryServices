GraphHealthCheck.cs
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Neo4jClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager
{
    public class GraphHealthCheck : IHealthCheck
    {

        private readonly IGraphClient _client;
        public GraphHealthCheck(IGraphClient client)
        {
            _client = client;
        }

        public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
        {

            var healthCheckResultHealthy = await CheckNeo4jGraphConnectionAsync();


            if (healthCheckResultHealthy)
            {
                return HealthCheckResult.Healthy("neo4j graph db health check success");
            }

            return HealthCheckResult.Unhealthy("neo4j graph db health check success"); ;
        }

        private async Task<bool> CheckNeo4jGraphConnectionAsync()
        {
            try
            {
                await _client.ConnectAsync();
            }

            catch (Exception)
            {
                return false;
            }

            return true;
        }
    }
}

Neo4jSettings.cs
namespace DbManager
{
    public class Neo4jSettings
    {
        public Uri Neo4jConnection { get; set; }

        public string Neo4jUser { get; set; }

        public string Neo4jPassword { get; set; }

        public string Neo4jDatabase { get; set; }
    }
}

ServiceRegistration.cs
using DbManager.Neo4j.Implementations;
using DbManager.Neo4j.Interfaces;
using Microsoft.Extensions.DependencyInjection;
using Neo4jClient;
using DbManager.Data.Nodes;
using DbManager.Services;
using DbManager.Neo4j.DataGenerator;
using Microsoft.Extensions.Configuration;
using DbManager.Data.Relations;
using DbManager.Data;

namespace DbManager
{
    public static class ServiceRegistration
    {
        public static void AddDbInfrastructure(this IServiceCollection services, IConfiguration configuration)
        {
            // Fetch settings object from configuration
            var settings = new Neo4jSettings();
            configuration.GetSection("Neo4jSettings").Bind(settings);

            // This is to register Neo4j Client Object as a singleton
            services.AddSingleton<IGraphClient, BoltGraphClient>(op => {
                        var graphClient = new BoltGraphClient(settings.Neo4jConnection, settings.Neo4jUser, settings.Neo4jPassword);
                        graphClient.ConnectAsync().Wait();
                        if(Convert.ToBoolean(configuration.GetSection("ApplicationSettings:GenerateData").Value) == false)
                            PrepareData(graphClient, configuration.GetSection("ClientAppSettings:PathToPublicSourceDirecroty").Value, configuration.GetSection("ClientAppSettings:DirectoryWithDishImages").Value);
                        return graphClient;
                    });

            services.AddSingleton<IRepositoryFactory, RepositoryFactory>();

            services.AddTransient<IPasswordService, PasswordService>();

            services.AddTransient<DataGenerator>();
            services.AddSingleton<GeneratorService>();

            // This is the registration for custom repository class
            services.AddTransient<IGeneralRepository<Order>, OrderRepository>();
            services.AddTransient<IGeneralRepository<Dish>, DishRepository>();
            services.AddTransient<IGeneralRepository<User>, UserRepository>();
            services.AddTransient<IGeneralRepository<Client>, ClientRepository>();
            services.AddTransient<IGeneralRepository<DeliveryMan>, DeliveryManRepository>();
        }

        private static void PrepareData(IGraphClient graphClient, string pathToPublicClientAppDirectory, string dirWithDishImages)
        {
            var categoryRepo = new GeneralRepository<Category>(graphClient);
            var dishRepo = new GeneralRepository<Dish>(graphClient);

            OrderState.OrderStatesFromDb = new GeneralRepository<OrderState>(graphClient).GetNodesAsync().Result;

            Category.CategoriesFromDb = categoryRepo.GetNodesAsync().Result;

            foreach (var category in Category.CategoriesFromDb)
            {
                var categoryDishes = categoryRepo.GetRelationsOfNodesAsync<ContainsDish, Dish>(category).Result.Select(h=>(Dish)h.NodeTo);

                foreach (var dish in categoryDishes)
                {
                    var pathToDishDir = PathToDirWithDish(pathToPublicClientAppDirectory, dirWithDishImages, category.LinkName, dish.Id.ToString());
                    if (Directory.Exists(pathToDishDir))
                    {
                        dish.Images = Directory
                            .GetFiles(pathToDishDir)
                            //получаемый путь
                            // /dishes/{Название категории на англ}/{Guid}/{Название файла}
                            .Select(h => ConvertFromIOPathToInternetPath_DirWithDish(pathToPublicClientAppDirectory, h))
                            .ToList();

                        dishRepo.UpdateNodeAsync(dish).Wait();
                    }
                    else
                    {
                        Directory.CreateDirectory(pathToDishDir);
                    }
                }
            }
            
        }

        public static string PathToDirWithDish(string pathToPublicClientAppDirectory, string dirWithDishImages, string categoryLink, string dishId)
        {
            var pathToDishesDir = Path.Combine(pathToPublicClientAppDirectory, dirWithDishImages);
            var pathToCategoryDir = Path.Combine(pathToDishesDir, categoryLink);
            var pathToDishDir = Path.Combine(pathToCategoryDir, dishId);

            return pathToDishDir;
        }

        public static string ConvertFromIOPathToInternetPath_DirWithDish(string pathToPublicClientAppDirectory, string pathToImage)
        {
            pathToImage = pathToImage
                .Replace(pathToPublicClientAppDirectory, "")
                .Replace('\\', '/');

            return Path.Combine("/", pathToImage);
        }
    }
}

IModel.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data
{
    public interface IModel
    {
        public Guid Id { get; set; }
    }
}

INode.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data
{
    public interface INode : IModel
    {
    }
}

IRelation.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data
{
    public interface IRelation : IModel
    {
        INode NodeFrom { get; set; }
        INode NodeTo { get; set; }

        Guid? NodeFromId { get; set; }
        Guid? NodeToId { get; set; }
    }
}

Node.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data
{
    public abstract class Node : INode
    {
        public Guid Id { get; set; }
    }
}

OrderStateEnum.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data
{
    [Flags]
    public enum OrderStateEnum
    {
        InQueue = 1,
        Cooking = 2,
        WaitDeliveryMan = 4,
        Delivering = 8,
        Finished = 16,
        Cancelled = 32,
    }
}

Relation.cs
using Neo4jClient;
using Newtonsoft.Json;

namespace DbManager.Data
{
    public class Relation<TFrom, TTo> : IRelation where TFrom : class, INode where TTo : class, INode
    {
        public Guid Id { get; set; }

        private TFrom? _nodeFrom;
        private TTo? _nodeTo;

        [Neo4jIgnore]
        public INode NodeFrom
        {
            get => _nodeFrom;
            set
            {
                NodeFromId = value.Id;
                _nodeFrom = (TFrom)value;
            }
        }

        [Neo4jIgnore]
        public INode NodeTo
        {
            get => _nodeTo;
            set
            {
                NodeToId = value.Id;
                _nodeTo = (TTo)value;
            }
        }

        public Guid? NodeFromId { get; set; }
        public Guid? NodeToId { get; set; }

    }
}

User.cs
using Neo4jClient;

namespace DbManager.Data
{
    public class User : Node
    {
        public string Login { get; set; }
        public List<byte> PasswordHash { get; set; }
        public string PhoneNumber { get; set; }
        public string Address { get; set; }
        public string Name { get; set; }
        [Neo4jDateTime]
        public DateTime? Born { get; set; }
        public Guid RefreshToken { get; set; }
        [Neo4jDateTime]
        public DateTime RefreshTokenCreated { get; set; }
        public bool IsBlocked { get; set; }
    }
}

JwtTokenInfoOutDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class JwtTokenInfoOutDTO
    {
        public string JwtToken { get; set; }
        public DateTime ValidTo { get; set; }
        public List<string> RoleNames { get; set; }
    }
}

KitchenWorkerOutDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class KitchenWorkerOutDTO
    {
        public Guid Id { get; set; }
        public string Login { get; set; }
        public string PhoneNumber { get; set; }
        public string Name { get; set; }
        public DateTime? Born { get; set; }
        public bool IsBlocked { get; set; }
        public string? JobTitle { get; set; }

        public DateTime GotJob { get; set; }
    }
}

ManipulateDishDataInDTO.cs
using Microsoft.AspNetCore.Http;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class ManipulateDishDataInDTO
    {
        public Guid? Id { get; set; }
        public string? Name { get; set; }
        public string? Description { get; set; }
        public double? Price { get; set; }
        public int? Weight { get; set; }
        public bool? IsAvailableForUser { get; set; }
        public bool? IsDeleted { get; set; }

        public string? CategoryId { get; set; }
        public IFormFileCollection? ImagesFiles { get; set; }
    }
}

ManipulateOrderDataInDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class ManipulateOrderDataInDTO
    {
        public int? NewCount { get; set; }
        public string? OrderId { get; set; }
        public string? DishId { get; set; }
        public string? ReasonOfCancel { get; set; }
    }
}

ManipulateUserDataInDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class ManipulateUserDataInDTO
    {
        public string UserId { get; set; }
        public string? ChangeRole { get; set; }
    }
}

OrderOutDTO.cs
using DbManager.Data.Relations;
using Neo4jClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class OrderOutDTO
    {
        public Guid Id { get; set; }
        public double Price { get; set; }
        public int SumWeight { get; set; }
        public string DeliveryAddress { get; set; }
        public string PhoneNumber { get; set; }
        public string? Review { get; set; }
        public int? ClientRating { get; set; }

        public List<OrderStateItemOutDTO> Story { get; set; } = new List<OrderStateItemOutDTO>();
    }
}

OrderStateItemOutDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class OrderStateItemOutDTO
    {
        public DateTime? TimeStartState { get; set; }
        public string? Comment { get; set; }
        public Guid OrderStateId { get; set; }
        public int NumberOfStage { get; set; }
        public string NameOfState { get; set; }
        public string DescriptionForClient { get; set; }
    }
}

PlaceAnOrderInDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class PlaceAnOrderInDTO
    {
        public string DeliveryAddress { get; set; }
        public string PhoneNumber { get; set; }
        public string? Comment { get; set; }  
    }
}

ProfileUserOutDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class ProfileUserOutDTO
    {
        public string Login { get; set; }
        public string PhoneNumber { get; set; }
        public string Name { get; set; }
        public DateTime? Born { get; set; }

        // Client props
        public double? Bonuses { get; set; }

        //KitchenWorker props
        public string? JobTitle { get; set; }

        //Admin props

    }
}

ReviewOrderInDTO.cs
using Neo4jClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class ReviewOrderInDTO
    {
        public string? OrderId { get; set; }
        public int? ClientRating { get; set; }
        public string? Review { get; set; }
    }
}

StatisticQueryDataItemOutDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class StatisticQueryDataItemOutDTO
    {
        public string X { get; set; }
        public List<double> Y { get; set; }
    }
}

StatisticQueryInfoOutDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class StatisticQueryInfoOutDTO
    {
        public string NameQuery { get;set; }
        public string LinkToQuery { get;set; }
        public string ChartName { get;set; }
        public bool NeedDataRange { get;set; }
        public List<string>? NameDatasets { get; set; }
    }
}

UserForAdminOutDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class UserForAdminOutDTO
    {
        public Guid Id { get; set; }
        public string Login { get; set; }
        public string PhoneNumber { get; set; }
        public string Name { get; set; }
        public DateTime? Born { get; set; }
        public bool IsBlocked { get; set; }
        public string Address { get; set; }

        public string Roles { get; set; }
    }
}

UserLoginInDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class UserLoginInDTO
    {
        public string Login { get; set; }
        public string Password { get; set; }
    }
}

UserSignupInDTO.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.DTOs
{
    public class UserSignupInDTO
    {
        public string Login { get; set; }
        public string Password { get; set; }
        public string? PhoneNumber { get; set; }
        public string? Address { get; set; }
        public string Name { get; set; }
        public DateTime? Born { get; set; }
    }
}

Admin.cs

namespace DbManager.Data.Nodes
{
    public class Admin: User, INode
    {
    }
}

Category.cs

using Neo4jClient;
using Newtonsoft.Json;

namespace DbManager.Data.Nodes
{
    public class Category : Node, INode
    {
        public string Name { get; set; }
        public string? Description { get; set; }
        public string LinkName { get; set; }
        public int CategoryNumber { get; set; }

        /// <summary>
        /// Categories loading from DB when app starts
        /// </summary>
        [JsonIgnore]
        [Neo4jIgnore]
        public static List<Category> CategoriesFromDb = new List<Category>();
    }
}

Client.cs
using DbManager.Data.Relations;
using Neo4jClient;

namespace DbManager.Data.Nodes
{
    public class Client : User, INode
    {
        public double Bonuses { get; set; }

        [Neo4jIgnore]
        public List<Ordered>? ClientOrders { get; set; }
    }
}

DeliveryMan.cs
using DbManager.Data.Relations;
using Neo4jClient;

namespace DbManager.Data.Nodes
{
    public class DeliveryMan : User, INode
    {
        public int MaxWeight { get; set; }

        [Neo4jIgnore]
        public List<DeliveredBy>? DeliveredOrders { get; set; }
    }
}

Dish.cs
using DbManager.Data.Relations;
using Neo4jClient;

namespace DbManager.Data.Nodes
{
    /// <summary>
    /// Продаваемое блюдо (напиток, товар)
    /// </summary>
    public class Dish : Node, INode
    {
        public string Name { get; set; }
        public string Description { get; set; }
        public double Price { get; set; }
        public int Weight { get; set; }
        public bool IsAvailableForUser { get; set; }
        public bool IsDeleted { get; set; }
        /// <summary>
        /// Images of product. First image is main
        /// </summary>
        public List<string> Images { get; set; }

        [Neo4jIgnore]
        public List<OrderedDish>? Orders { get; set; }
    }
}

Kitchen.cs
using DbManager.Data.Relations;
using Neo4jClient;

namespace DbManager.Data.Nodes
{
    public class Kitchen : Node, INode
    {
        public string Address { get; set; }

        [Neo4jIgnore]
        public List<CookedBy>? PreparedOrders { get; set; }
    }
}

KitchenWorker.cs
using DbManager.Data.Relations;
using Neo4jClient;

namespace DbManager.Data.Nodes
{
    public class KitchenWorker : User, INode
    {
        public string JobTitle { get; set; }

        [Neo4jIgnore]
        public WorkedIn? Kitchen { get; set; }
    }
}

Order.cs
using DbManager.Data.Relations;
using Neo4jClient;
using Newtonsoft.Json;

namespace DbManager.Data.Nodes
{
    public class Order : Node, INode
    {
        public double Price { get; set; }
        public int SumWeight { get; set; }
        public string DeliveryAddress { get; set; }
        public string PhoneNumber { get; set; }

        [Neo4jIgnore]
        public List<HasOrderState> Story { get; set; } = new List<HasOrderState>();

        public string StoryJson
        {
            get
            {
                return JsonConvert.SerializeObject(Story, Formatting.Indented, new JsonSerializerSettings() { NullValueHandling = NullValueHandling.Ignore});
            }
            set
            {
                Story = JsonConvert.DeserializeObject<List<HasOrderState>>(value, new JsonSerializerSettings() { NullValueHandling = NullValueHandling.Ignore });
            }
        }

        [Neo4jIgnore]
        public List<OrderedDish>? OrderedObjects { get; set; }
        [Neo4jIgnore]
        public DeliveredBy? DeliveredMan { get; set; }
        [Neo4jIgnore]
        public Ordered Client { get; set; }
        [Neo4jIgnore]
        public CookedBy? Kitchen { get; set; }

    }
}

OrderState.cs
using Neo4jClient;
using Newtonsoft.Json;

namespace DbManager.Data.Nodes
{
    public class OrderState : Node, INode
    {
        public int NumberOfStage { get; set; }
        public string NameOfState { get; set; }
        public string DescriptionForClient { get; set; }

        /// <summary>
        /// Order states loading from DB when app starts
        /// </summary>
        [JsonIgnore]
        [Neo4jIgnore]
        public static List<OrderState> OrderStatesFromDb = new List<OrderState>();

        [Neo4jIgnore]
        public List<Order> Orders { get; set; } 
    }
}

ContainsDish.cs
using DbManager.Data.Nodes;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// Category -> Dish
    /// </summary>
    public class ContainsDish : Relation<Category, Dish>
    {

    }
}

CookedBy.cs
using DbManager.Data.Nodes;
using Neo4jClient;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// Kitchen -> Order
    /// </summary>
    public class CookedBy : Relation<Kitchen, Order>
    {
    }
}

DeliveredBy.cs
using DbManager.Data.Nodes;
using Neo4jClient;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// DeliveryMan -> Order
    /// </summary>
    public class DeliveredBy : Relation<DeliveryMan, Order>
    {

    }
}

HasOrderState.cs
using DbManager.Data.Nodes;
using Neo4jClient;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// Order -> OrderState
    /// </summary>
    public class HasOrderState : Relation<Order, OrderState>
    {
        [Neo4jDateTime]
        public DateTime TimeStartState { get; set; }
        public string? Comment { get; set; }

    }
}

Ordered.cs
using DbManager.Data.Nodes;
using Neo4jClient;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// Client -> Order
    /// </summary>
    public class Ordered : Relation<Client, Order>
    {

    }
}

OrderedDish.cs
using Neo4jClient;
using DbManager.Data.Nodes;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// Order -> Dish
    /// </summary>
    public class OrderedDish : Relation<Order, Dish>
    {
        public int Count { get; set; }
    }
}

ReviewedBy.cs
using DbManager.Data.Nodes;
using Neo4jClient;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// Client -> Order
    /// </summary>
    public class ReviewedBy : Relation<Client, Order>
    {
        public int? ClientRating { get; set; }
        [Neo4jDateTime]
        public DateTime TimeCreated { get; set; }
        public string? Review { get; set; }
    }
}

WorkedIn.cs
using DbManager.Data.Nodes;
using Neo4jClient;

namespace DbManager.Data.Relations
{
    /// <summary>
    /// KitchenWorker -> Kitchen
    /// </summary>
    public class WorkedIn : Relation<KitchenWorker, Kitchen>
    {
        [Neo4jDateTime]
        public DateTime GotJob { get; set; }
    }
}

MapperProfile.cs
using DbManager.Data.Nodes;
using DbManager.Data;
using AutoMapper;
using DbManager.Data.DTOs;
using DbManager.Data.Relations;
using Neo4jClient.Extensions;

namespace DbManager.Mapper
{
    public class MapperProfile : Profile
    {
        public MapperProfile()
        {
            CreateMap<User, ProfileUserOutDTO>();
            CreateMap<Client, ProfileUserOutDTO>();
            CreateMap<Admin, ProfileUserOutDTO>();
            CreateMap<KitchenWorker, ProfileUserOutDTO>();

            CreateMap<User, UserForAdminOutDTO>();
            CreateMap<List<string>, UserForAdminOutDTO>()
                .ForMember(h => h.Roles, opt => opt.MapFrom(src => string.Join(", ", src)));

            CreateMap<KitchenWorker, KitchenWorkerOutDTO>();

            CreateMap<OrderState, OrderStateItemOutDTO>()
                .ForMember(h=>h.OrderStateId, (o) => o.MapFrom(src=>src.Id));

            CreateMap<HasOrderState, OrderStateItemOutDTO>()
                .BeforeMap((h,k) => h.NodeTo = OrderState.OrderStatesFromDb.FirstOrDefault(s=>s.Id == h.NodeToId))
                .ForMember(h => h.OrderStateId, (o) => o.MapFrom(src => src.NodeToId))
                .ForMember(h => h.NumberOfStage, (o) => o.MapFrom(src => ((OrderState)src.NodeTo).NumberOfStage))
                .ForMember(h => h.NameOfState, (o) => o.MapFrom(src => ((OrderState)src.NodeTo).NameOfState))
                .ForMember(h => h.DescriptionForClient, (o) => o.MapFrom(src => ((OrderState)src.NodeTo).DescriptionForClient));

            CreateMap<Order, OrderOutDTO>()
                .ForMember(dest => dest.Story, opt => opt.MapFrom(src => src.Story));

            CreateMap<ReviewedBy, OrderOutDTO>()
                .ForMember(h => h.Review, (o) => o.MapFrom(src => src.Review))
                .ForMember(h => h.ClientRating, (o) => o.MapFrom(src => src.ClientRating));

            CreateMap<Dish, ManipulateDishDataInDTO>();
            CreateMap<ManipulateDishDataInDTO, Dish>()
                .ForMember(h=>h.Id, o => o.Ignore());
        }
    }
}

Neo4jExtentions.cs
using DbManager.Data;
using Neo4jClient.Cypher;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j
{
    internal static class Neo4jExtentions
    {
        public static ICypherFluentQuery<TModel> ChangeQueryForPagination<TModel>(this ICypherFluentQuery<TModel> query, string[] orderByProperty, int? skipCount = null, int? limitCount = null) where TModel : IModel
        {
            if (orderByProperty != null && orderByProperty.Length != 0)
                query = query.OrderBy(orderByProperty);

            query = query
                .Skip(skipCount)
                .Limit(limitCount);

            return query;
        }

        public static ICypherFluentQuery<T> ChangeQueryForPaginationAnonymousType<T>(this ICypherFluentQuery<T> query, string[] orderByProperty, int? skipCount = null, int? limitCount = null) where T : class
        {
            if (orderByProperty != null && orderByProperty.Length != 0)
                query = query.OrderBy(orderByProperty);

            query = query
                .Skip(skipCount)
                .Limit(limitCount);

            return query;
        }
    }
}

BogusExtentions.cs
using Bogus;

namespace DbManager.Neo4j.DataGenerator
{
    internal static class BogusExtentions
    {
        /// <summary>
        /// Get a random list item and remove it from list.
        /// </summary>
        public static T ListItemWithRemove<T>(this Randomizer randomizer, List<T> list)
        {
            var item = randomizer.ListItem(list as IList<T>);
            list.Remove(item);
            return item;
        }
    }
}

DataGenerator.cs
using Bogus;
using DbManager.Data;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Services;
using Microsoft.Extensions.Configuration;

namespace DbManager.Neo4j.DataGenerator
{
    public class DataGenerator
    {
        private IPasswordService pswService { get; set; }
        private IConfiguration _configuration { get; set; }


        public DataGenerator(IPasswordService passwordService, IConfiguration configuration)
        {
            pswService = passwordService;
            _configuration = configuration;
        }

        public List<Admin> GenerateAdmins(int count)
            => ObjectGenerator.GenerateAdmin(pswService).Generate(count);

        public List<Client> GenerateClients(int count)
            => ObjectGenerator.GenerateClient(pswService).Generate(count);

        public List<DeliveryMan> GenerateDeliveryMen(int count)
            => ObjectGenerator.GenerateDeliveryMan(pswService).Generate(count);

        public List<KitchenWorker> GenerateKitchenWorkers(int count)
            => ObjectGenerator.GenerateKitchenWorker(pswService).Generate(count);
    
        public List<Dish> GenerateDishes(int count)
            => ObjectGenerator.GenerateDish().Generate(count);

        public List<Dish> GenerateDishes(int count, List<string> dishNames)
            => ObjectGenerator.GenerateDish(dishNames).Generate(count);

        public List<Order> GenerateOrders(int count)
            => ObjectGenerator.GenerateOrder().Generate(count);

        public List<Kitchen> GenerateKitchens(int count)
            => ObjectGenerator.GenerateKitchen().Generate(count);

        public List<Category> GenerateCategories(int count)
            => ObjectGenerator.GenerateCategory().Generate(count);

        public List<OrderState> GenerateOrderStates()
            => new List<OrderState> 
            {
                new OrderState() { Id = Guid.NewGuid(), NumberOfStage = (int)OrderStateEnum.InQueue, NameOfState = "В очереди заказов", DescriptionForClient = "Заказ был получен и в текущий момент находится в очереди заказов на кухне"},
                new OrderState() { Id = Guid.NewGuid(), NumberOfStage = (int)OrderStateEnum.Cooking, NameOfState = "Готовится", DescriptionForClient = "Блюда готовятся на кухне"},
                new OrderState() { Id = Guid.NewGuid(), NumberOfStage = (int)OrderStateEnum.WaitDeliveryMan, NameOfState = "В ожидании курьера", DescriptionForClient = "Заказ собран и ожидает когда его заберет курьер"},
                new OrderState() { Id = Guid.NewGuid(), NumberOfStage = (int)OrderStateEnum.Delivering, NameOfState = "Доставляется", DescriptionForClient = "Заказ находится у курьера, который его доставляет"},
                new OrderState() { Id = Guid.NewGuid(), NumberOfStage = (int)OrderStateEnum.Finished, NameOfState = "Завершен", DescriptionForClient = "Заказ был завершен"},
                new OrderState() { Id = Guid.NewGuid(), NumberOfStage = (int)OrderStateEnum.Cancelled, NameOfState = "Отменён", DescriptionForClient = "Заказ был отменен"},
            };

        public List<CookedBy> GenerateRelationsCookedBy(int count, List<Order> orders, List<Kitchen> kitchens)
            => ObjectGenerator.GenerateCookedBy(orders, kitchens).Generate(count);

        public List<ContainsDish> GenerateRelationsContainsDishWithNodes(int countDish, int countCategory, List<Category> categories, List<Dish> dishes)
        {
            var relations = new List<ContainsDish>();
            var mediumCountDishesInCategory = countDish / countCategory;
            var random = new Random();

            categories.AddRange(GenerateCategories(countCategory));

            for (int i = 0, j = 1; i < categories.Count; i++, j = (int)Math.Pow(2, i))
            {
                categories[i].CategoryNumber = j;
                var categoryDishNames = CategoryLinkWithDishNames[categories[i].LinkName];
                var categoryDishes = GenerateDishes(random.Next(2, mediumCountDishesInCategory + 2), categoryDishNames);
                dishes.AddRange(categoryDishes);

                var pathToPublicClientAppDirectory = _configuration.GetSection("ClientAppSettings:PathToPublicSourceDirecroty").Value;
                var dirWithDishImages = _configuration.GetSection("ClientAppSettings:DirectoryWithDishImages").Value;
                var dirWithImagesForGeneration = Path.Combine("ImagesForGeneration", categories[i].LinkName);
                var filesForGeneration = Directory.GetFiles(dirWithImagesForGeneration);

                for (int l = 0; l < filesForGeneration.Length; l++)
                {
                    var pathToDishDir = ServiceRegistration.PathToDirWithDish(  pathToPublicClientAppDirectory, 
                                                                                dirWithDishImages, 
                                                                                categories[i].LinkName, 
                                                                                categoryDishes[l % categoryDishes.Count].Id.ToString());
                    var imageName = filesForGeneration[l].Replace(dirWithImagesForGeneration+"\\", "");
                    var pathToDishFile = Path.Combine(pathToDishDir, imageName);

                    if (!Directory.Exists(pathToDishDir))
                        Directory.CreateDirectory(pathToDishDir);

                    File.Copy(filesForGeneration[l], pathToDishFile, false);

                    if (categoryDishes[l % categoryDishes.Count].Images == null)
                        categoryDishes[l % categoryDishes.Count].Images = new List<string>();

                    categoryDishes[l % categoryDishes.Count].Images.Add(ServiceRegistration.ConvertFromIOPathToInternetPath_DirWithDish(pathToPublicClientAppDirectory, pathToDishFile));
                }

                var categoryContainsDishRelation = ObjectGenerator.GenerateContainsDish(new List<Category>() { categories[i] }, categoryDishes)
                    .Generate(categoryDishes.Count);

                relations.AddRange(categoryContainsDishRelation);
            }

            return relations;
        }

        public List<DeliveredBy> GenerateRelationsDeliveredBy(int count, List<Order> orders, List<DeliveryMan> deliveryMen)
            => ObjectGenerator.GenerateDeliveredBy(orders, deliveryMen).Generate(count);

        public List<HasOrderState> GenerateRelationsHasOrderState(int count, List<Order> orders, List<OrderState> orderStates)
            => ObjectGenerator.GenerateHasOrderState(orders, orderStates).Generate(count);

        public List<HasOrderState> GenerateOrderStory(List<HasOrderState> currentOrderStates, List<OrderState> orderStates)
        {
            foreach (var curOrderState in currentOrderStates)
            {
                var order = (Order)curOrderState.NodeFrom;
                var state = (OrderState)curOrderState.NodeTo;
                var faker = new Faker("ru");
                var previousStageTimeStart = curOrderState.TimeStartState.AddHours(-5);
                //если заказ отменен, то он может быть отменен только до завершения заказа
                var limitStory = state.NumberOfStage == (int)OrderStateEnum.Cancelled ? (int)OrderStateEnum.Finished : state.NumberOfStage;

                for (int i = 0, j = 1; j < limitStory; i++, j = (int)Math.Pow(2,i))
                {
                    if(j != (int)OrderStateEnum.InQueue && state.NumberOfStage == (int)OrderStateEnum.Cancelled)
                    {
                        //с вероятностью 1/3 прекращаем создавать историю, тем самым
                        //отменяя заказ после случайной стадии
                        var rand = new Random().Next(0, 3);
                        if(rand == 0)
                        {
                            break;
                        }
                    }

                    var orderStoryState = new HasOrderState()
                    {
                        TimeStartState = faker.Date.Between(previousStageTimeStart, previousStageTimeStart.AddHours(1)),
                        Comment = faker.Lorem.Sentence(),
                        Id = Guid.NewGuid(),
                        NodeFromId = order.Id,
                        NodeToId = orderStates[i].Id,
                    };
                    order.Story.Add(orderStoryState);
                    previousStageTimeStart = orderStoryState.TimeStartState;
                }

                order.Story.Add(new HasOrderState()
                {
                    TimeStartState = curOrderState.TimeStartState,
                    Comment = faker.Lorem.Sentence(),
                    Id = curOrderState.Id,
                    NodeFromId = order.Id,
                    NodeToId = state.Id,
                });
            }
            return currentOrderStates;
        }

        public List<Ordered> GenerateRelationsOrdered(int count, List<Order> orders, List<Client> client)
            => ObjectGenerator.GenerateOrdered(orders, client).Generate(count);

        public List<OrderedDish> GenerateRelationsOrderedDish(int count, List<Order> orders, List<Dish> dishes)
        {
            var mediumCountDishesInOrder = count / orders.Count;
            var rand = new Random();
            List<OrderedDish> relations = new List<OrderedDish>();

            foreach (var order in orders)
            {
                var countDishInOrder = rand.Next(1, mediumCountDishesInOrder + 2);
                relations.AddRange(ObjectGenerator.GenerateOrderedDish(new List<Order>() { order }, dishes).Generate(countDishInOrder));
            }

            relations = ExcludeDuplicate(relations);

            for (int i = 0; i < relations.Count; i++)
            {
                var orderItem = (Order)relations[i].NodeFrom;
                var dishItem = (Dish)relations[i].NodeTo;

                orderItem.SumWeight += dishItem.Weight * relations[i].Count;
                orderItem.Price += dishItem.Price * relations[i].Count;
            }
            return relations;
        }

        public List<ReviewedBy> GenerateRelationsReviewedBy(int count, List<Order> orders, List<Client> reviewers)
            => ObjectGenerator.GenerateReviewedBy(orders, reviewers).Generate(count);

        public List<WorkedIn> GenerateRelationsWorkedIn(int count, List<Kitchen> kitchens, List<KitchenWorker> kitchenWorkers)
            => ObjectGenerator.GenerateWorkedIn(kitchens, kitchenWorkers).Generate(count);

        /// <summary>
        /// Exclude Duplicate. Compare NodeFrom.Ids and NodeTo.Ids then remove this relations from list and return it
        /// </summary>
        /// <param name="relations">List with relations</param>
        /// <returns>Relations without duplicate</returns>
        private List<TRelation> ExcludeDuplicate<TRelation>(List<TRelation> relations) where TRelation: IRelation
        {
            relations = relations.OrderBy(x => x.NodeFrom.Id).ThenBy(x => x.NodeTo.Id).ToList();
            var relationsForRemove = new List<TRelation>();

            for (int i = 0; i < relations.Count - 1; i++)
            {
                for (int j = i + 1; j < relations.Count; j++)
                {
                    if (relations[i].NodeFrom.Id == relations[j].NodeFrom.Id && relations[i].NodeTo.Id == relations[j].NodeTo.Id)
                    {
                        relationsForRemove.Add(relations[j]);
                    }
                    else break;
                }
            }

            relations = relations.Except(relationsForRemove).ToList();

            return relations;
        }

        private Dictionary<string, List<string>> CategoryLinkWithDishNames { get; set; } =
            new Dictionary<string, List<string>>()
            {
                {"Rolls", new List<string>{ "Суши с лососем", "Унаги ролл", "Калифорния ролл", "Филадельфия ролл", "Авокадо ролл", "Креветка ролл", "Темпура ролл", "Дракон ролл", "Спайси тунец ролл", "Ролл с огурцом" } },
                {"Drinks", new List<string>{ "Мохито", "Пина Колада", "Дайкири", "Маргарита", "Май Тай", "Космополитен", "Мартини", "Белый Русский", "Текила Санрайз" } },
                {"SecondMeal", new List<string>{ "Стейк", "Котлеты", "Рыба запеченная в духовке", "Жаркое", "Гуляш", "Курица табака", "Мясо по-французски", "Свинина в соусе", "Телятина с овощами", "Гриль" } },
                {"FirstMeal", new List<string>{ "Борщ", "Солянка", "Уха", "Грибной суп", "Щи", "Окрошка", "Рассольник", "Лапша по-флотски", "Французский луковый суп", "Куриный суп с лапшой" } },
                {"Salads", new List<string>{ "Цезарь", "Греческий", "Оливье", "Винегрет", "Салат нисуаз", "Мимоза", "Тушёнка", "Капустный", "Селёдочный", "Крабовый" } },
                {"Pizza", new List<string>{ "Маргарита", "Пепперони", "Гавайская пицца", "Пицца четыре сыра", "Вегетарианская пицца", "Барбекю", "Мексиканская пицца", "Мясная пицца", "Морская пицца", "Дьябло" } },
            };
    }
}

GeneratorService.cs

using DbManager.Data;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.Interfaces;
using DbManager.Services;
using Newtonsoft.Json;

namespace DbManager.Neo4j.DataGenerator
{
    public class GeneratorService
    {
        private readonly IRepositoryFactory _repoFactory;
        private readonly DataGenerator _dataGenerator;
        private readonly IPasswordService _pswService;

        public GeneratorService(IRepositoryFactory repositoryFactory, IPasswordService passwordService, DataGenerator dataGenerator)
        {
            _repoFactory = repositoryFactory;
            _dataGenerator = dataGenerator;
            _pswService = passwordService;
        }

        public async Task GenerateAll()
        {
            var mediumCountDishesInOrder = 3;
            var countRandomStateForOrders = 350;

            //генерируем узлы
            var orderStates = _dataGenerator.GenerateOrderStates();
            var admins = _dataGenerator.GenerateAdmins(2);

            var admin = admins[0];
            admin.Login = "admin@admin";
            admin.PasswordHash = _pswService.GetPasswordHash(admin.Login, "admin").ToList();

            var clients = _dataGenerator.GenerateClients(50);

            var client = clients[0];
            client.Login = "item@item";
            client.PasswordHash = _pswService.GetPasswordHash(client.Login, "item").ToList();

            var deliveryMen = _dataGenerator.GenerateDeliveryMen(7);

            var deliveryMan = deliveryMen[0];
            deliveryMan.Login = "deliveryMan@deliveryMan";
            deliveryMan.PasswordHash = _pswService.GetPasswordHash(deliveryMan.Login, "deliveryMan").ToList();

            var kitchenWorkers = _dataGenerator.GenerateKitchenWorkers(9);

            var kitchenWorker = kitchenWorkers[0];
            kitchenWorker.Login = "kitchenWorker@kitchenWorker";
            kitchenWorker.PasswordHash = _pswService.GetPasswordHash(kitchenWorker.Login, "kitchenWorker").ToList();

            var kitchens = _dataGenerator.GenerateKitchens(3);
            var orders = _dataGenerator.GenerateOrders(1000);
            var categories = new List<Category>();
            var dishes = new List<Dish>();
            //генерация категорий и блюд происходит в данном методе!
            var containsDishes = _dataGenerator.GenerateRelationsContainsDishWithNodes(30, 6, categories, dishes);

            //вставляем узлы в бд
            var orderRepo = _repoFactory.GetRepository<Order>();

            await orderRepo.AddNodesAsync(orders);
            await _repoFactory.GetRepository<Dish>().AddNodesAsync(dishes);
            await _repoFactory.GetRepository<Admin>().AddNodesAsync(admins);
            await _repoFactory.GetRepository<Client>().AddNodesAsync(clients);
            await _repoFactory.GetRepository<DeliveryMan>().AddNodesAsync(deliveryMen);
            await _repoFactory.GetRepository<KitchenWorker>().AddNodesAsync(kitchenWorkers);
            await _repoFactory.GetRepository<Kitchen>().AddNodesAsync(kitchens);
            await _repoFactory.GetRepository<OrderState>().AddNodesAsync(orderStates);
            await _repoFactory.GetRepository<Category>().AddNodesAsync(categories);

            //генерируем связи между узлами. Последовательность важна!
            //создаем новые списки, т.к. эти списки будут изменяться. 
            //так, при генерации связи Ordered будут удаляться заказы из списка, чтобы они не дублировались
            var workedIns = _dataGenerator.GenerateRelationsWorkedIn(kitchenWorkers.Count, kitchens, new List<KitchenWorker>(kitchenWorkers));
            var cookedBies = _dataGenerator.GenerateRelationsCookedBy(orders.Count, new List<Order>(orders), kitchens);
            var deliveredBies = _dataGenerator.GenerateRelationsDeliveredBy(orders.Count, new List<Order>(orders), deliveryMen);
            var hasOrderStates = _dataGenerator.GenerateRelationsHasOrderState(countRandomStateForOrders, new List<Order>(orders.GetRange(0, countRandomStateForOrders)), orderStates);
            hasOrderStates.AddRange(_dataGenerator.GenerateRelationsHasOrderState(orders.Count - countRandomStateForOrders, new List<Order>(orders.GetRange(countRandomStateForOrders, orders.Count - countRandomStateForOrders)), new List<OrderState>() { orderStates.First(h => h.NumberOfStage == (int)OrderStateEnum.Finished) }));
            var ordereds = _dataGenerator.GenerateRelationsOrdered(orders.Count, new List<Order>(orders), clients);
            
            //Генерируем связь OrderedDish. Количество связей будет меньше, т.к. удаляются дублируемые
            var orderedDishes = _dataGenerator.GenerateRelationsOrderedDish(orders.Count * mediumCountDishesInOrder, orders, dishes);
            
            //связываем узлы
            foreach (var item in workedIns)
                await _repoFactory.GetRepository<Kitchen>().RelateNodesAsync(item);

            //В цикле все, т.к. при генерации учитывается, что эти связи идут 1 к 2
            for (int i = 0; i < orders.Count; i++)
            {
                await orderRepo.RelateNodesAsync(cookedBies[i]);
                await orderRepo.RelateNodesAsync(deliveredBies[i]);
                await orderRepo.RelateNodesAsync(hasOrderStates[i]);
                await orderRepo.RelateNodesAsync(ordereds[i]);
            }
            //Создаем историю для заказов. Создаются рандомные связи с состояниями до последнего
            hasOrderStates = _dataGenerator.GenerateOrderStory(hasOrderStates, orderStates);

            for (int i = 0; i < orders.Count; i++)
            {
                //обновляем узлы Order, т.к. появились привязанные заказы
                await orderRepo.UpdateNodeAsync(orders[i]);
            }

            foreach (var item in orderedDishes)
                await orderRepo.RelateNodesAsync(item);

            //Создание отзыва в самом конце, т.к. время ее создания зависит от времени завершения заказа
            var reviewedBies = new List<ReviewedBy>();

            var finishedOrders = hasOrderStates.Where(h => ((OrderState)h.NodeTo).NumberOfStage == (int)OrderStateEnum.Finished).Select(h => (Order)h.NodeFrom).ToList();

            //Генерируем связь ReviewedBy между клиентами и ИХ заказами. Генерация только для завершенных заказов
            foreach (var item in clients)
            {
                var orderedOrders = ordereds
                    .Where(h => h.NodeFrom.Id == item.Id && finishedOrders.Contains((Order)h.NodeTo))
                    .Select(h => (Order)h.NodeTo)
                    .ToList();

                reviewedBies.AddRange(_dataGenerator
                    .GenerateRelationsReviewedBy(orderedOrders.Count, new List<Order>(orderedOrders), new List<Client>() { item }));
            }

            foreach (var item in reviewedBies)
                await orderRepo.RelateNodesAsync(item);

            foreach (var item in containsDishes)
                await _repoFactory.GetRepository<Dish>().RelateNodesAsync(item);

            //устанавливаем всем пользователям тип User
            foreach (var item in admins)
                await _repoFactory.GetRepository<Admin>().SetNewNodeType<User>(item.Id.ToString());
            foreach (var item in clients)
                await _repoFactory.GetRepository<Client>().SetNewNodeType<User>(item.Id.ToString());
            foreach (var item in kitchenWorkers)
                await _repoFactory.GetRepository<KitchenWorker>().SetNewNodeType<User>(item.Id.ToString());
            foreach (var item in deliveryMen)
                await _repoFactory.GetRepository<DeliveryMan>().SetNewNodeType<User>(item.Id.ToString());


        }
    }
}

ObjectGenerator.cs
using Bogus;
using DbManager.Data.Nodes;
using DbManager.Data;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using DbManager.Data.Relations;
using DbManager.Services;

namespace DbManager.Neo4j.DataGenerator
{
    internal static class ObjectGenerator
    {
        private static List<string> CategoryNames = new List<string>
        {
            "Роллы",
            "Напитки",
            "Вторые блюда",
            "Первые блюда",
            "Салаты",
            "Пицца",
        };

        private static Dictionary<string, string> CategoryLinks = new Dictionary<string, string>
        {
            { "Роллы", "Rolls" },
            { "Напитки", "Drinks" },
            { "Вторые блюда", "SecondMeal" },
            { "Первые блюда", "FirstMeal" },
            { "Салаты", "Salads" },
            { "Пицца", "Pizza" },
        };

        //----------------------------------------------GenerateNodes------------------------------------------------------------

        public static Faker<Dish> GenerateDish(List<string>? dishNames = null)
            => new Faker<Dish>("ru")
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.Name, g => dishNames == null ? g.Commerce.ProductName() : g.Random.ListItemWithRemove(dishNames))
                .RuleFor(h => h.Description, g => g.Lorem.Paragraph())
                .RuleFor(h => h.Price, g => g.Random.Number(100, 800))
                .RuleFor(h => h.Weight, g => g.Random.Number(150, 1000))
                .RuleFor(h => h.IsAvailableForUser, g => true);

        public static Faker<Category> GenerateCategory()
            => new Faker<Category>("ru")
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.Name, g => g.Random.ListItemWithRemove(CategoryNames))
                .RuleFor(h => h.LinkName, (g, o) => CategoryLinks[o.Name])
                .RuleFor(h => h.Description, g => g.Lorem.Paragraph());

        public static Faker<Order> GenerateOrder()
            => new Faker<Order>("ru") 
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.PhoneNumber, g => g.Phone.PhoneNumber("+7!!!!!!!!!!"))
                .RuleFor(h => h.DeliveryAddress, g => g.Address.StreetAddress());

        public static Faker<Kitchen> GenerateKitchen()
            => new Faker<Kitchen>("ru")
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.Address, g => g.Address.StreetAddress());

        public static Faker<Admin> GenerateAdmin(IPasswordService pswService)
            => new Faker<Admin>("ru")
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshToken, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshTokenCreated, g => g.Date.Soon())
                .RuleFor(h => h.Born, g => g.Date.Between(new DateTime(1980, 10, 10), new DateTime(2003, 10, 10)))
                .RuleFor(h => h.Name, g => g.Person.FullName)
                .RuleFor(h => h.Login, g => g.Internet.Email())
                .RuleFor(h => h.PhoneNumber, g => g.Phone.PhoneNumber("+7!!!!!!!!!!"))
                .RuleFor(h => h.Address, g => g.Address.StreetAddress())
                .RuleFor(h => h.PasswordHash, (g, o) => pswService.GetPasswordHash(o.Login, g.Internet.Password()).ToList());

        public static Faker<Client> GenerateClient(IPasswordService pswService)
            => new Faker<Client>("ru")
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshToken, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshTokenCreated, g => g.Date.Soon())
                .RuleFor(h => h.Born, g => g.Date.Between(new DateTime(1980, 10, 10), new DateTime(2003, 10, 10)))
                .RuleFor(h => h.Name, g => g.Person.FullName)
                .RuleFor(h => h.Login, g => g.Internet.Email())
                .RuleFor(h => h.Bonuses, g => Math.Round(g.Random.Double() + g.Random.Number(150, 1000), 2))
                .RuleFor(h => h.PhoneNumber, g => g.Phone.PhoneNumber("+7!!!!!!!!!!"))
                .RuleFor(h => h.Address, g => g.Address.StreetAddress())
                .RuleFor(h => h.PasswordHash, (g, o) => pswService.GetPasswordHash(o.Login, g.Internet.Password()).ToList());

        public static Faker<DeliveryMan> GenerateDeliveryMan(IPasswordService pswService)
            => new Faker<DeliveryMan>("ru")
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshToken, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshTokenCreated, g => g.Date.Soon())
                .RuleFor(h => h.Born, g => g.Date.Between(new DateTime(1980, 10, 10), new DateTime(2003, 10, 10)))
                .RuleFor(h => h.Name, g => g.Person.FullName)
                .RuleFor(h => h.Login, g => g.Internet.Email())
                .RuleFor(h => h.MaxWeight, g => g.Random.Number(4000, 50000))
                .RuleFor(h => h.PhoneNumber, g => g.Phone.PhoneNumber("+7!!!!!!!!!!"))
                .RuleFor(h => h.Address, g => g.Address.StreetAddress())
                .RuleFor(h => h.PasswordHash, (g, o) => pswService.GetPasswordHash(o.Login, g.Internet.Password()).ToList());

        public static Faker<KitchenWorker> GenerateKitchenWorker(IPasswordService pswService)
            => new Faker<KitchenWorker>("ru")
                .RuleFor(h => h.Id, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshToken, g => Guid.NewGuid())
                .RuleFor(h => h.RefreshTokenCreated, g => g.Date.Soon())
                .RuleFor(h => h.Born, g => g.Date.Between(new DateTime(1980, 10, 10), new DateTime(2003, 10, 10)))
                .RuleFor(h => h.Name, g => g.Person.FullName)
                .RuleFor(h => h.Login, g => g.Internet.Email())
                .RuleFor(h => h.JobTitle, g => g.Name.JobTitle())
                .RuleFor(h => h.PhoneNumber, g => g.Phone.PhoneNumber("+7!!!!!!!!!!"))
                .RuleFor(h => h.Address, g => g.Address.StreetAddress())
                .RuleFor(h => h.PasswordHash, (g, o) => pswService.GetPasswordHash(o.Login, g.Internet.Password()).ToList());

        //---------------------------------------------GenerateRelations-------------------------------------------------------------

        public static Faker<OrderedDish> GenerateOrderedDish(List<Order> orders, List<Dish> dishes)
            => new Faker<OrderedDish>("ru")
                .RuleFor(h => h.NodeTo, g => g.Random.ListItem(dishes))
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItem(orders))
                .RuleFor(h => h.Count, g => g.Random.Number(1, g.Random.Number(1,3)));

        public static Faker<CookedBy> GenerateCookedBy(List<Order> orders, List<Kitchen> kitchens)
            => new Faker<CookedBy>("ru")
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItem(kitchens))
                .RuleFor(h => h.NodeTo, g => g.Random.ListItemWithRemove(orders));

        public static Faker<ContainsDish> GenerateContainsDish(List<Category> categories, List<Dish> dishes)
            => new Faker<ContainsDish>("ru")
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItem(categories))
                .RuleFor(h => h.NodeTo, g => g.Random.ListItemWithRemove(dishes));

        public static Faker<DeliveredBy> GenerateDeliveredBy(List<Order> orders, List<DeliveryMan> deliveryMen)
            => new Faker<DeliveredBy>("ru")
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItem(deliveryMen))
                .RuleFor(h => h.NodeTo, g => g.Random.ListItemWithRemove(orders));

        public static Faker<HasOrderState> GenerateHasOrderState(List<Order> orders, List<OrderState> states)
            => new Faker<HasOrderState>("ru")
                .RuleFor(h => h.TimeStartState, g => g.Date.Between(new DateTime(2022, 10, 10), DateTime.Now))
                .RuleFor(h => h.Comment, g => g.Random.Bool() ? g.Lorem.Sentence() : null)
                .RuleFor(h => h.NodeTo, g => g.Random.ListItem(states))
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItemWithRemove(orders));

        public static Faker<Ordered> GenerateOrdered(List<Order> orders, List<Client> clients)
            => new Faker<Ordered>("ru")
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItem(clients))
                .RuleFor(h => h.NodeTo, g => g.Random.ListItemWithRemove(orders));

        /// <summary>
        /// Предпологается, что на вход идут только завершенные или отмененные заказы  
        /// </summary>
        /// <param name="orders"></param>
        /// <param name="reviewers"></param>
        /// <returns></returns>
        public static Faker<ReviewedBy> GenerateReviewedBy(List<Order> orders, List<Client> reviewers)
            => new Faker<ReviewedBy>("ru")
                .RuleFor(h => h.ClientRating, g => g.Random.Int(1, 10))
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItem(reviewers))
                .RuleFor(h => h.NodeTo, g => g.Random.ListItemWithRemove(orders))
                .RuleFor(h => h.TimeCreated, (g, o) => g.Date.Between(((Order)o.NodeTo).Story.Last().TimeStartState, ((Order)o.NodeTo).Story.Last().TimeStartState.AddHours(3)))
                .RuleFor(h => h.Review, g => g.Lorem.Paragraph());

        public static Faker<WorkedIn> GenerateWorkedIn(List<Kitchen> kitchens, List<KitchenWorker> kitchenWorkers)
            => new Faker<WorkedIn>("ru")
                .RuleFor(h => h.GotJob, g => g.Date.Between(new DateTime(2010, 10, 10), DateTime.Now))
                .RuleFor(h => h.NodeTo, g => g.Random.ListItem(kitchens))
                .RuleFor(h => h.NodeFrom, g => g.Random.ListItemWithRemove(kitchenWorkers));
    }
}

ClientRepository.cs
using DbManager.Data;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.Interfaces;
using Neo4jClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Implementations
{
    public class ClientRepository : GeneralRepository<Client>, IClientRepository
    {
        public ClientRepository(IGraphClient DbContext) : base(DbContext)
        {
        }

        public async Task<List<(Client, double, int)>> GetTopClientBySumPriceOrderStatistic(int topCount)
        {
            /*match (c:Client)-[r:ORDERED]-(o:Order)
            with c, sum(o.Price) as sum, count(o) as count
            return c,sum,count order by sum limit 10*/

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(Client).Name})-[relation:{typeof(Ordered).Name.ToUpper()}]-(relatedNode:{typeof(Order).Name})")
                .With("node, sum(relatedNode.Price) as sum, count(relatedNode) as count")
                //.Where($"")
                .Return((node, sum, count) => new
                {
                    client = node.As<Client>(),
                    sum = sum.As<double>(),
                    count = count.As<int>(),
                })
                .ChangeQueryForPaginationAnonymousType(new[] { "sum DESC" }, limitCount: topCount)
                .ResultsAsync;

            return res.Select(h => (h.client, h.sum, h.count)).ToList();
        }
    }
}

DeliveryManRepository.cs
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.Interfaces;
using Neo4jClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Implementations
{
    public class DeliveryManRepository : GeneralRepository<DeliveryMan>, IDeliveryManRepository
    {
        public DeliveryManRepository(IGraphClient DbContext) : base(DbContext)
        {
        }

        public async Task<List<(DeliveryMan, int)>> GetTopDeliveryMenByCountOrder(int topCount)
        {
            /*match (c:DeliveryMan)-[r:DELIVEREDBY]-(o:Order)
            with c, count(o) as count
            return c,count order by COUNT desc limit 10*/

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(DeliveryMan).Name})-[relation:{typeof(DeliveredBy).Name.ToUpper()}]-(relatedNode:{typeof(Order).Name})")
                .With("node, count(relatedNode) as count")
                //.Where($"")
                .Return((node, count) => new
                {
                    delMan = node.As<DeliveryMan>(),
                    count = count.As<int>(),
                })
                .ChangeQueryForPaginationAnonymousType(new[] { "count DESC" }, limitCount: topCount)
                .ResultsAsync;

            return res.Select(h => (h.delMan, h.count)).ToList();
        }
    }
}

DishRepository.cs
using DbManager.Data;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.Interfaces;
using Neo4jClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Implementations
{
    public class DishRepository : GeneralRepository<Dish>, IDishRepository
    {
        public DishRepository(IGraphClient DbContext) : base(DbContext)
        {
        }

        public async Task<List<Dish>> SearchDishesByNameAndDescription(string searchText, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "node." + orderByProperty[i];

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(Dish).Name})")
                .Where($"toLower(node.Name) contains($searchText) or toLower(node.Description) contains($searchText)")
                .WithParams(new
                    {
                        searchText
                    })
                .Return((node) => node.As<Dish>())
                .ChangeQueryForPagination(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            return res.ToList();
        }

        public async Task<List<(Dish, int)>> GetTopDishByCountOrderedStatistic(int topCount)
        {
            /*match (o:Order)-[r:ORDEREDDISH]-(d:Dish) 
            with count(r) as countR, d
            return d, countR order by countR desc limit 10*/

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(Order).Name})-[relation:{typeof(OrderedDish).Name.ToUpper()}]-(relatedNode:{typeof(Dish).Name})")
                .With("relatedNode, count(relation) as countR")
                //where time > date("2022-11-01") and time < date("2023-03-01")
                .Return((relatedNode, countR) => new
                {
                    dish = relatedNode.As<Dish>(),
                    countOfOrdereds = countR.As<int>(),
                })
                .ChangeQueryForPaginationAnonymousType(new[] { "countR desc" }, limitCount: topCount)
                .ResultsAsync;

            return res.Select(h => (h.dish, h.countOfOrdereds)).ToList();
        }
    }
}

GeneralRepository.cs
using DbManager.Data;
using DbManager.Neo4j.Interfaces;
using Neo4jClient;
using Neo4jClient.Cypher;

namespace DbManager.Neo4j.Implementations
{
    public class GeneralRepository<TNode> : IGeneralRepository<TNode> 
        where TNode : INode
    {
        protected readonly IGraphClient dbContext;

        public GeneralRepository(IGraphClient DbContext)
        {
            dbContext = DbContext;
        }

        public async Task AddNodeAsync(TNode newNode)
        {
            if(newNode.Id == Guid.Empty)
                newNode.Id = Guid.NewGuid();
            await dbContext.Cypher
                .Merge($"(newNode:{typeof(TNode).Name} {{Id: $id}})")
                .OnCreate()
                .Set("newNode = $newEntity")
                .WithParams(new
                {
                    id = newNode.Id,
                    newEntity = newNode
                })  
                .ExecuteWithoutResultsAsync();
        }

        public async Task AddNodesAsync(List<TNode> newNodes)
        {
            foreach (var item in newNodes)
            {
                await AddNodeAsync(item);
            }
        }

        public async Task UpdateNodeAsync(TNode node)
        {
            await dbContext.Cypher
                .Match($"(updateNode:{typeof(TNode).Name} {{Id: $id}})")
                .Set("updateNode = $updatedEntity")
                .WithParams(new
                {
                    id = node.Id,
                    updatedEntity = node
                })
                .ExecuteWithoutResultsAsync();
        }

        public async Task UpdateNodesPropertiesAsync(TNode node)
        {
            var properties = typeof(TNode).GetProperties();
            var query = dbContext.Cypher
                .Match($"(updateNode:{typeof(TNode).Name} {{Id: $id}})");

            foreach (var property in properties)
            {
                query = query.Set($"updateNode.{property.Name} = $updatedEntity.{property.Name}");
            }

            await query.WithParams(new
            {
                id = node.Id,
                updatedEntity = node
            })
                .ExecuteWithoutResultsAsync();
        }

        public async Task<TNode> GetNodeAsync(string id)
            => await GetNodeAsync(Guid.Parse(id));

        public async Task<TNode> GetNodeAsync(Guid id)
        {
            var res = await dbContext.Cypher
                .Match($"(entity:{typeof(TNode).Name} {{Id: $id}})")
                .WithParams(new
                {
                    id,
                })
                .Return(entity => entity.As<TNode>())
                .ResultsAsync;

            if (res.Count() != 1)
                throw new Exception($"Count of nodes with such Id don't equels 1. Type: {typeof(TNode).Name}");

            return res.First();
        }

        public async Task<List<TNode>> GetNodesAsync(int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "entity." + orderByProperty[i];

            var query = dbContext.Cypher
                .Match($"(entity:{typeof(TNode).Name})")
                .Return(entity => entity.As<TNode>())
                .ChangeQueryForPagination(orderByProperty, skipCount, limitCount);

            var res = await query.ResultsAsync;

            return res.ToList();
        }

        public async Task DeleteNodeWithAllRelations(TNode node)
        {
            await dbContext.Cypher
                .Match($"(entity:{typeof(TNode).Name} {{Id: $id}})-[r]-()")
                .WithParams(new
                {
                    id = node.Id,
                })
                .Delete("r, entity")
                .ExecuteWithoutResultsAsync();
        }

        public async Task RelateNodesAsync<TRelation>(TRelation relation)
            where TRelation : IRelation
        {
            if(relation.NodeFromId == null || relation.NodeToId == null)
            { 
                throw new Exception("NodeFromId or NodeToId is null. Method RelateNodesAsync where TRelation is " + typeof(TRelation));
            }
            var typeNodeFrom = typeof(TRelation).BaseType.GenericTypeArguments[0];
            var direction = GetDirection(relation.GetType().Name, "relation", typeNodeFrom == typeof(TNode));

            if (relation.Id == Guid.Empty)
                relation.Id = Guid.NewGuid();

            await dbContext.Cypher
                .Match($"(node {{Id: $entityId}}), (otherNode {{Id: $otherNodeId}})")
                .Create($"(node){direction}(otherNode)")
                .Set("relation=$newRelation")
                .WithParams(new
                {
                    entityId = relation.NodeFromId,
                    otherNodeId = relation.NodeToId,
                    newRelation = relation
                })
                .ExecuteWithoutResultsAsync();
        }

        public async Task UpdateRelationNodesAsync<TRelation>(TRelation updatedRelation)
            where TRelation : IRelation
        {
            var typeNodeFrom = typeof(TRelation).BaseType.GenericTypeArguments[0];
            var direction = GetDirection(updatedRelation.GetType().Name, "relation", typeNodeFrom == typeof(TNode));

            await dbContext.Cypher
                .Match($"(node {{Id: $id}}){direction}(relatedNode {{Id: $relatedNodeId}})")
                .Set("relation=$updatedRelation")
                .WithParams(new
                {
                    id = updatedRelation.NodeFromId,
                    relatedNodeId = updatedRelation.NodeToId,
                    updatedRelation
                })
                .ExecuteWithoutResultsAsync();
        }

        public async Task<TRelation> GetRelationBetweenTwoNodesAsync<TRelation, TRelatedNode>(TNode node, TRelatedNode relatedNode, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TRelation : IRelation
            where TRelatedNode : INode
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "relation." + orderByProperty[i];

            var direction = GetDirection(typeof(TRelation).Name, "relation");

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name} {{Id: $id}}){direction}(relatedNode:{typeof(TRelatedNode).Name} {{Id: $relatedNodeId}})")
                .WithParams(new
                {
                    id = node.Id,
                    relatedNodeId = relatedNode.Id,
                })
                .Return(relation => relation.As<TRelation>())
                .ChangeQueryForPagination(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            if (res.Count() < 1)
                throw new Exception($"Nodes don't have relation ({typeof(TNode).Name})-[{typeof(TRelation).Name.ToUpper()})]-({typeof(TRelatedNode).Name})");

            return res.First();
        }

        public async Task<List<TRelation>> GetRelationsOfNodesAsync<TRelation, TRelatedNode>(TNode node, int? skipCount = null, int? limitCount = null, params string[] orderByProperty) 
            where TRelation: IRelation
            where TRelatedNode: INode
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "relatedNode." + orderByProperty[i];

            var direction = GetDirection(typeof(TRelation).Name, "relation");
            var typeNodeFrom = typeof(TRelation).BaseType.GenericTypeArguments[0];

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name} {{Id: $id}}){direction}(relatedNode:{typeof(TRelatedNode).Name})")
                .WithParams(new
                {
                    id = node.Id,
                })
                .Return((relation, relatedNode) => new
                {
                    nodeRelations = relation.As<TRelation>(),
                    relationNodes = relatedNode.As<TRelatedNode>()
                })
                .ChangeQueryForPaginationAnonymousType(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            var nodeIsNodeFrom = typeof(TNode) == typeNodeFrom;
            var relations = res.Select(h =>
            {
                h.nodeRelations.NodeFrom = nodeIsNodeFrom ? node : h.relationNodes;
                h.nodeRelations.NodeTo = nodeIsNodeFrom ? h.relationNodes : node;
                return h.nodeRelations;
            }).ToList();

            return relations;
        }

        public async Task<List<TRelation>> GetRelationsOfNodesAsync<TRelation, TRelatedNode>(string nodeId, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TRelation : IRelation
            where TRelatedNode : INode 
        {
            var node = await GetNodeAsync(nodeId);

            return await GetRelationsOfNodesAsync<TRelation, TRelatedNode>(node, skipCount, limitCount, orderByProperty);
        }

        public async Task DeleteRelationOfNodesAsync<TRelation, TRelatedNode>(TNode node, TRelatedNode relatedNode)
            where TRelation : IRelation
            where TRelatedNode : INode
        {
            var direction = GetDirection(typeof(TRelation).Name, "relation");

            await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name} {{Id: $id}}){direction}(relatedNode:{typeof(TRelatedNode).Name} {{Id: $relatedNodeId}})")
                .Delete("relation")
                .WithParams(new
                {
                    id = node.Id,
                    relatedNodeId = relatedNode.Id,
                })
                .ExecuteWithoutResultsAsync();
        }

        public async Task<List<TNode>> GetNodesWithoutRelation<TRelation>(int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "node." + orderByProperty[i];

            var directionIn = GetDirection(typeof(TRelation).Name); 
            var directionOut = GetDirection(typeof(TRelation).Name);

            var result = await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name})")
                .Where($"not (node){directionIn}() and not (node){directionOut}()")
                .Return(node => node.As<TNode>())
                .ChangeQueryForPagination(orderByProperty,skipCount,limitCount)
                .ResultsAsync;

            return result.ToList();
        }

        public async Task<List<TNode>> GetNodesByIdAsync(string[] ids, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "node." + orderByProperty[i];

            var result = await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name})")
                .Where($"node.Id in [\"{string.Join("\",\"", ids)}\"]")
                .Return(node => node.As<TNode>())
                .ChangeQueryForPagination(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            return result.ToList();
        }

        public async Task<List<TNode>> GetNodesByPropertyAsync(string nameOfProperty, string[] propertyValues, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "node." + orderByProperty[i];

            var result = await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name})")
                .Where($"node.{nameOfProperty} in [\"{string.Join("\",\"", propertyValues)}\"]")
                .Return(node => node.As<TNode>())
                .ChangeQueryForPagination(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            return result.ToList();
        }

        public async Task SetNewNodeType<TNewNodeType>(string nodeId)
            where TNewNodeType : INode
        {
            await SetNewNodeType(nodeId, typeof(TNewNodeType).Name);
        }

        public async Task SetNewNodeType(string nodeId, string nodeTypeName)
        {
            await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name} {{Id: $id}})")
                .Set($"node:{nodeTypeName}")
                .WithParams(new
                {
                    id = nodeId,
                })
                .ExecuteWithoutResultsAsync();
        }

        public async Task RemoveNodeType<TNodeType>(string nodeId)
            where TNodeType : INode
        {
            await RemoveNodeType(nodeId, typeof(TNodeType).Name);
        }

        public async Task RemoveNodeType(string nodeId, string nodeTypeName)
        {
            await dbContext.Cypher
                .Match($"(node:{typeof(TNode).Name} {{Id: $id}})")
                .Remove($"node:{nodeTypeName}")
                .WithParams(new
                {
                    id = nodeId,
                })
                .ExecuteWithoutResultsAsync();
        }

        public async Task<bool> HasNodeType<TNodeType>(string nodeId)
            where TNodeType : INode
        {
            return await HasNodeType(nodeId, typeof(TNodeType).Name);
        }

        public async Task<bool> HasNodeType(string nodeId, string nodeType)
        {
            var result = await dbContext.Cypher
                .Match($"(node:{typeof(User).Name} {{Id: $id}})")
                .WithParams(new
                {
                    id = nodeId,
                })
                .ReturnDistinct<List<string>>("labels(node)")
                .ResultsAsync;

            var clearResult = result.First().ToList();

            if (clearResult.Contains(nodeType))
                return true;

            return false;
        }

        /// <summary>
        /// Get string with directed relation. Relation has name type of "relation" + relationInstanceName
        /// </summary>
        /// <param name="nameRelation">Name of the relation in DB</param>
        /// <param name="relationInstanceName">Name of relation instance</param>
        /// <param name="relationInEntity">Relation input in node or output</param>
        /// <returns>String with directed relation</returns>
        protected string GetDirection(string nameRelation, string? relationInstanceName = "", bool? relationInEntity = null)
        {
            string direction = "-[]-";
            if(!string.IsNullOrEmpty(nameRelation))
                direction = $"-[{relationInstanceName}:{nameRelation.ToUpper()}]-";

            if (relationInEntity == null)
                return direction;

            return relationInEntity.Value ? "<" + direction: direction + ">";
        }
    }
}
OrderRepository.cs
using DbManager.Data;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.Interfaces;
using Neo4jClient;
using Neo4jClient.Cypher;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Implementations
{
    public class OrderRepository : GeneralRepository<Order>, IOrderRepository
    {
        public OrderRepository(IGraphClient DbContext) : base(DbContext)
        {
        }

        public async Task<List<Order>> GetOrdersByStateRelatedWithNode<TNode>(string nodeId, string nameOfState, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TNode : INode
        {
            return await GetOrdersByStateRelatedWithNode<TNode>(Guid.Parse(nodeId),OrderState.OrderStatesFromDb.Single(h=>h.NameOfState == nameOfState).Id, skipCount, limitCount, orderByProperty);
        }

        public async Task<List<Order>> GetOrdersByStateRelatedWithNode<TNode>(string nodeId, OrderStateEnum orderState, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TNode : INode
        {
            return await GetOrdersByStateRelatedWithNode<TNode>(Guid.Parse(nodeId), OrderState.OrderStatesFromDb.Single(h => (OrderStateEnum)h.NumberOfStage == orderState).Id, skipCount, limitCount, orderByProperty);
        }

        public async Task<List<Order>> GetOrdersByStateRelatedWithNode<TNode>(Guid nodeId, Guid orderStateId, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TNode : INode
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "orders." + orderByProperty[i];

            var directionInOrderCB = GetDirection("");
            var directionInOrderHOS = GetDirection(typeof(HasOrderState).Name, "rel");

            var res = await dbContext.Cypher
                .Match(
                    $"(node:{typeof(TNode).Name} {{Id: $nodeId}})" +
                    $"{directionInOrderCB}" +
                    $"(orders:{typeof(Order).Name})" +
                    $"{directionInOrderHOS}" +
                    $"(orderState:{typeof(OrderState).Name} {{Id: $orderStateId}})")
                .WithParams(new
                    {
                        nodeId,
                        orderStateId,
                    })
                .Return(orders => orders.As<Order>())
                .ChangeQueryForPagination(orderByProperty.Concat(new[] { "rel.TimeStartState desc" }).ToArray(), skipCount, limitCount)
                .ResultsAsync;

            return res.ToList();
        }

        public async Task<HasOrderState?> MoveOrderToNextStage(string orderId, string comment)
        {
            var order = await GetNodeAsync(Guid.Parse(orderId));
            var orderHasState = order.Story.Last();
            var orderState = OrderState.OrderStatesFromDb.Single(h => h.Id == orderHasState.NodeToId);
            //Если заказ был отменен или завершен, то ничего не произойдет
            if ((OrderStateEnum)orderState.NumberOfStage == OrderStateEnum.Cancelled || (OrderStateEnum)orderState.NumberOfStage == OrderStateEnum.Finished)
                return null;

            await DeleteRelationOfNodesAsync<HasOrderState, OrderState>(order, orderState);
            var newOrderState = new HasOrderState() 
            {
                Comment = comment, 
                NodeFromId = order.Id, 
                NodeToId = OrderState.OrderStatesFromDb.Single(h => h.NumberOfStage == orderState.NumberOfStage * 2).Id,
                TimeStartState = DateTime.Now 
            };

            order.Story.Add(newOrderState);
            await RelateNodesAsync(newOrderState);
            await UpdateNodeAsync(order);

            newOrderState.NodeTo = OrderState.OrderStatesFromDb.Single(h => h.NumberOfStage == orderState.NumberOfStage * 2);

            return newOrderState;
        }

        public async Task<bool> MoveOrderToPreviousStage(string orderId)
        {
            var order = await GetNodeAsync(Guid.Parse(orderId));
            var orderHasState = order.Story.Last();
            var orderState = OrderState.OrderStatesFromDb.Single(h => h.Id == orderHasState.NodeToId);
            //Если заказ только попал в очередь
            if ((OrderStateEnum)orderState.NumberOfStage == OrderStateEnum.InQueue)
                return false;
            
            await DeleteRelationOfNodesAsync<HasOrderState, OrderState>(order, orderState);
            order.Story.Remove(orderHasState);

            var newOrderState = order.Story.Last();

            await RelateNodesAsync(newOrderState);
            await UpdateNodeAsync(order);

            return true;
        }

        public async Task CreateOrderRelationInDB(Order order, string? userId, List<Dish> dishes, Kitchen kitchen, DeliveryMan deliveryMan, Dictionary<string, int> countOfDishes, string? comment)
        {
            if(userId != null)
                await RelateNodesAsync(new Ordered() { NodeFromId = Guid.Parse(userId), NodeTo = order });

            foreach (var dish in dishes)
            {
                await RelateNodesAsync(new OrderedDish() { NodeFrom = order, NodeTo = dish, Count = countOfDishes[dish.Id.ToString()] });
            }

            await RelateNodesAsync(new CookedBy() { NodeFrom = kitchen, NodeTo = order });

            await RelateNodesAsync(new DeliveredBy() { NodeFrom = deliveryMan, NodeTo = order });

            var firstState = OrderState.OrderStatesFromDb.First(h => h.NumberOfStage == (int)OrderStateEnum.InQueue);
            var relationCancel = new HasOrderState() { Comment = comment, NodeFromId = order.Id, NodeToId = firstState.Id, TimeStartState = DateTime.Now };

            order.Story.Add(relationCancel);
            await RelateNodesAsync(relationCancel);
            await UpdateNodeAsync(order);
        }

        public async Task<List<(string, double, int)>> GetOrderPriceAndCountStatistic()
        {
            /*MATCH (node:Order)-[relation:HASORDERSTATE]-(relatedNode:OrderState {NumberOfStage: 16}) 
            WITH date.truncate('month', datetime(relation.TimeStartState)) as time , sum(node.Price) as sum, count(relatedNode) as count 
            where time > date("2022-11-01") and time < date("2023-03-01")
            RETURN time, sum, count order by time*/

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(Order).Name})-[relation:{typeof(HasOrderState).Name.ToUpper()}]-(relatedNode:{typeof(OrderState).Name} {{NumberOfStage: $NumberOfFinishStage}})")
                .WithParams(new
                {
                    NumberOfFinishStage = (int)OrderStateEnum.Finished,
                })
                .With("date.truncate('month', datetime(relation.TimeStartState)) as time , sum(node.Price) as sum, count(relatedNode) as count")
                //where time > date("2022-11-01") and time < date("2023-03-01")
                .Return((time, sum, count) => new
                {
                    time = time.As<DateTime>(),
                    sum = sum.As<double>(),
                    count = count.As<int>(),
                })
                .ChangeQueryForPaginationAnonymousType(new[] { "time" })
                .ResultsAsync;

            return res.Select(h => (h.time.Month+"."+h.time.Year, h.sum, h.count)).ToList();
        }

        public async Task<List<(string, int, int)>> GetCountFinishedOrderAndClientsStatistic()
        {
            /*MATCH (node:Client)-[relation:ORDERED]-(relatedNode:Order)-[relation2:HASORDERSTATE]-(relatedNode2:OrderState {NumberOfStage: 16})
            with count(relatedNode) as countOfOrders, count(distinct node) as countOfClients, date.truncate('month', datetime(relation2.TimeStartState)) as time
            RETURN countOfOrders, countOfClients, time order by time */

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(Client).Name})-[relation:{typeof(Ordered).Name.ToUpper()}]-(relatedNode:{typeof(Order).Name})-[relation2:{typeof(HasOrderState).Name.ToUpper()}]-(relatedNode2:{typeof(OrderState).Name} {{NumberOfStage: $NumberOfFinishStage}})")
                .WithParams(new
                {
                    NumberOfFinishStage = (int)OrderStateEnum.Finished,
                })
                .With("count(relatedNode) as countOfOrders, count(distinct node) as countOfClients, date.truncate('month', datetime(relation2.TimeStartState)) as time")
                //where time > date("2022-11-01") and time < date("2023-03-01")
                .Return((time, countOfOrders, countOfClients) => new
                {
                    time = time.As<DateTime>(),
                    countOfOrders = countOfOrders.As<int>(),
                    countOfClients = countOfClients.As<int>(),
                })
                .ChangeQueryForPaginationAnonymousType(new[] { "time" })
                .ResultsAsync;

            return res.Select(h => (h.time.Month + "." + h.time.Year, h.countOfOrders, h.countOfClients)).ToList();
        }

        public async Task<List<(string, List<Order>)>> GetCancelledOrderGroupedByMonthStatistic()
        {
            /* MATCH(node:Order)-[relation: HASORDERSTATE]-(relatedNode:OrderState {NumberOfStage: 32})
            with node, date.truncate('month', datetime(relation.TimeStartState)) as time
            RETURN node, time order by time */

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(Order).Name})-[relation:{typeof(HasOrderState).Name.ToUpper()}]-(relatedNode:{typeof(OrderState).Name} {{NumberOfStage: $NumberOfFinishStage}})")
                .WithParams(new
                {
                    NumberOfFinishStage = (int)OrderStateEnum.Cancelled,
                })
                .With("node, date.truncate('month', datetime(relation.TimeStartState)) as time")
                //where time > date("2022-11-01") and time < date("2023-03-01")
                .Return((node, time) => new
                {
                    time = time.As<DateTime>(),
                    node = node.CollectAs<Order>(),
                })
                .ChangeQueryForPaginationAnonymousType(new[] { "time" })
                .ResultsAsync;

            return res.Select(h => (h.time.Month + "." + h.time.Year, h.node.ToList())).ToList();
        }

        public async Task<List<(Kitchen, int, int)>> GetCountOrdersAndOrderedDishesForEveryKitchenStatistic()
        {
            /*match(k:Kitchen)-[]-(o:Order)-[r:ORDEREDDISH]-(d:Dish)
            with k, count(distinct o) as countO, sum(r.Count) as sumD
            return k,countO, sumD */

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(Kitchen).Name})-[relation:{typeof(CookedBy).Name.ToUpper()}]-(relatedNode:{typeof(Order).Name})-[relation2:{typeof(OrderedDish).Name.ToUpper()}]-(relatedNode2:{typeof(Dish).Name})")
                .With("node, count(distinct relatedNode) as countO, sum(relation2.Count) as sumD")
                //where time > date("2022-11-01") and time < date("2023-03-01")
                .Return((node, countO, sumD) => new
                {
                    kitchen = node.As<Kitchen>(),
                    countOfOrders = countO.As<int>(),
                    sumOfDishes = sumD.As<int>(),
                })
                .ChangeQueryForPaginationAnonymousType(new string[0])
                .ResultsAsync;

            return res.Select(h => (h.kitchen, h.countOfOrders, h.sumOfDishes)).ToList();
        }
    }
}

RepositoryFactory.cs
using DbManager.Data;
using DbManager.Neo4j.Interfaces;
using Microsoft.Extensions.DependencyInjection;
using Neo4jClient;

namespace DbManager.Neo4j.Implementations
{
    public class RepositoryFactory: IRepositoryFactory
    {
        private readonly IGraphClient dbContext;
        private readonly IServiceProvider services;
        private readonly Dictionary<Type, object> repositories = new Dictionary<Type, object>();

        public IGraphClient DbContext => dbContext;

        public RepositoryFactory(IGraphClient neo4jData, IServiceProvider serviceProvider)
        {
            dbContext = neo4jData;
            services = serviceProvider;

            var res = neo4jData.JsonConverters;
            var count = res.Count;
        }

        public IGeneralRepository<TEntity> GetRepository<TEntity>(bool hasCustomRepository = false) where TEntity : INode
        {
            if (hasCustomRepository)
            {
                var repo = services.GetService<IGeneralRepository<TEntity>>();
                if(repo != null)
                {
                    return repo;
                }
            }

            var typeEntity = typeof(TEntity);
            if (!repositories.ContainsKey(typeEntity)) 
            { 
                var generalRepo = new GeneralRepository<TEntity>(DbContext);
                repositories.Add(typeEntity, generalRepo);
            }

            return (IGeneralRepository<TEntity>)repositories[typeEntity];
        }
    }
}

UserRepository.cs
using DbManager.Data;
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using DbManager.Neo4j.Interfaces;
using Neo4jClient;
using Neo4jClient.Cypher;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Implementations
{
    public class UserRepository : GeneralRepository<User>, IUserRepository
    {
        public UserRepository(IGraphClient DbContext) : base(DbContext)
        {
        }

        public Dictionary<string, byte> UserRolePriority { get; } = new Dictionary<string, byte>
        {
            {"User", 0},
            {"Client", 1},
            {"KitchenWorker", 2},
            {"Admin", 100},
        };

        private string GetMaxPriorityRole(List<string> roles)
        {
            var maxPriRole = UserRolePriority.First(h=>h.Value == 0).Key;

            foreach (var role in roles)
            {
                if(UserRolePriority.TryGetValue(role, out _))
                {
                    if (UserRolePriority[role] > UserRolePriority[maxPriRole])
                    {
                        maxPriRole = role;
                    }
                }
                else
                {
                    break;
                }
            }

            return maxPriRole;
        }

        public async Task<List<string>> GetUserRoles(string userId)
        {
            var result = await dbContext.Cypher
                .Match($"(node:{typeof(User).Name} {{Id: $id}})")
                .WithParams(new
                {
                    id = userId,
                })
                .ReturnDistinct<List<string>>("labels(node)")
                .ResultsAsync;

            var clearResult = result.First().ToList();

            return clearResult;
        }

        public async Task<List<(User, List<string>)>> GetUsersForAdmin(int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "node." + orderByProperty[i];

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(User).Name})")
                .With("node, labels(node) as roles")
                .Return((node, roles) => new
                {
                    user = node.As<User>(),
                    userRoles = roles.As<List<string>>()
                })
                .ChangeQueryForPaginationAnonymousType(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            return res.Select(h=>(h.user, h.userRoles)).ToList();
        }

        public async Task<List<(User, List<string>)>> SearchUsersByIdAndLoginForAdmin(string searchText, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "node." + orderByProperty[i];

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(User).Name})")
                .Where($"toLower(node.Id) contains($searchText) or toLower(node.Login) contains($searchText)")
                .WithParams(new
                {
                    searchText
                })
                .With("node, labels(node) as roles")
                .Return((node, roles) => new
                {
                    user = node.As<User>(),
                    userRoles = roles.As<List<string>>()
                })
                .ChangeQueryForPaginationAnonymousType(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            return res.Select(h => (h.user, h.userRoles)).ToList();
        }

        public async Task<List<User>> SearchUsersByIdAndLogin(string searchText, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
        {
            for (int i = 0; i < orderByProperty.Length; i++)
                orderByProperty[i] = "node." + orderByProperty[i];

            var res = await dbContext.Cypher
                .Match($"(node:{typeof(User).Name})")
                .Where($"toLower(node.Id) contains($searchText) or toLower(node.Login) contains($searchText)")
                .WithParams(new
                {
                    searchText
                })
                .Return((node) => node.As<User>())
                .ChangeQueryForPagination(orderByProperty, skipCount, limitCount)
                .ResultsAsync;

            return res.ToList();
        }
    }
}

IClientRepository.cs
using DbManager.Data.Nodes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Interfaces
{
    public interface IClientRepository : IGeneralRepository<Client>
    {
        public Task<List<(Client, double, int)>> GetTopClientBySumPriceOrderStatistic(int topCount);
    }
}

IDeliveryManRepository.cs
using DbManager.Data.Nodes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Interfaces
{
    public interface IDeliveryManRepository : IGeneralRepository<DeliveryMan>
    {
        Task<List<(DeliveryMan, int)>> GetTopDeliveryMenByCountOrder(int topCount);
    }
}

IDishRepository.cs
using DbManager.Data.Nodes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Interfaces
{
    public interface IDishRepository : IGeneralRepository<Dish>
    {
        Task<List<Dish>> SearchDishesByNameAndDescription(string searchText, int? skipCount = null, int? limitCount = null, params string[] orderByProperty);
        Task<List<(Dish, int)>> GetTopDishByCountOrderedStatistic(int topCount);
    }
}

IGeneralRepository.cs
 using DbManager.Data;

namespace DbManager.Neo4j.Interfaces
{
    /// <summary>
    /// General interface for repository
    /// </summary>
    /// <typeparam name="TNode"></typeparam>
    public interface IGeneralRepository<TNode> where TNode : INode
    {
        /// <summary>
        /// Add node with properties to DB. Generate new Id. If node with such id already exist in DB, then node won't added to DB
        /// </summary>
        /// <param name="node">New node</param>
        /// <returns></returns>
        Task AddNodeAsync(TNode node);

        /// <summary>
        /// Add nodes with properties to DB. Generate new Id for each nodes. If node with such id already exist in DB, then node won't added to DB
        /// </summary>
        /// <param name="newNodes">List of new nodes</param>
        /// <returns></returns>
        Task AddNodesAsync(List<TNode> newNodes);

        /// <summary>
        /// Replace existing node
        /// </summary>
        /// <param name="node">The node, which will be replaced</param>
        /// <returns></returns>
        Task UpdateNodeAsync(TNode node);

        /// <summary>
        /// Update existing node properties
        /// </summary>
        /// <param name="node">The node, which will be updated</param>
        /// <returns></returns>
        Task UpdateNodesPropertiesAsync(TNode node);

        /// <summary>
        /// Get the node with the specified id. If DB return count of nodes < 1, then function throw Exception
        /// </summary>
        /// <param name="id">Node id</param>
        /// <returns>Node with specified id</returns>
        /// <exception cref="Exception">Count of items with specified id less 1.</exception>
        Task<TNode> GetNodeAsync(string id);

        /// <summary>
        /// Get the node with the specified id. If DB return count of nodes != 1, then function throw Exception
        /// </summary>
        /// <param name="id">Node id</param>
        /// <returns>Node with specified id</returns>
        /// <exception cref="Exception">Count of items with specified id don't equels 1.</exception>
        Task<TNode> GetNodeAsync(Guid id);

        /// <summary>
        /// Get all nodes TModel type
        /// </summary>
        /// <param name="skipCount">Count of nodes will skip</param>
        /// <param name="limitCount">Count of nodes will returner after skip</param>
        /// <param name="orderByProperty">Property names by which to sort. ONLY properties of TNode</param>
        /// <returns>List of TModel type</returns>
        Task<List<TNode>> GetNodesAsync(int? skipCount = null, int? limitCount = null, params string[] orderByProperty);

        /// <summary>
        /// Delete existing node
        /// </summary>
        /// <param name="node">The node, which will be deleted</param>
        /// <returns></returns>
        Task DeleteNodeWithAllRelations(TNode node);

        /// <summary>
        /// Get relation between two nodes
        /// </summary>
        /// <typeparam name="TRelation">The type of relation</typeparam>
        /// <typeparam name="TRelatedNode">Type of related nodes</typeparam>
        /// <param name="node">The first node</param>
        /// <param name="relatedNode">The second node</param>
        /// <param name="skipCount">Count of nodes will skip</param>
        /// <param name="limitCount">Count of nodes will returner after skip</param>
        /// <param name="orderByProperty">Property names by which to sort. ONLY properties of TRelation</param>
        /// <returns></returns>
        Task<TRelation> GetRelationBetweenTwoNodesAsync<TRelation, TRelatedNode>(TNode node, TRelatedNode relatedNode, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TRelation : IRelation
            where TRelatedNode : INode;

        /// <summary>
        /// Update realtion of two existing nodes
        /// </summary>
        /// <typeparam name="TRelation">The type of updated relation</typeparam>
        /// <param name="updatedRelation">The relation, which will be used for update data</param>
        /// <returns></returns>
        Task UpdateRelationNodesAsync<TRelation>(TRelation updatedRelation)
            where TRelation : IRelation;

        /// <summary>
        /// Delete relation between two nodes
        /// </summary>
        /// <typeparam name="TRelation">The type of relation</typeparam>
        /// <typeparam name="TRelatedNode">Type of related nodes</typeparam>
        /// <param name="node">The first node</param>
        /// <param name="relatedNode">The second node</param>
        /// <returns></returns>
        Task DeleteRelationOfNodesAsync<TRelation, TRelatedNode>(TNode node, TRelatedNode relatedNode)
            where TRelation : IRelation
            where TRelatedNode : INode;

        /// <summary>
        /// Get related nodes as List
        /// </summary>
        /// <typeparam name="TRelation">The type of searched relation</typeparam>
        /// <typeparam name="TRelatedNode">The type of related nodes</typeparam>
        /// <param name="node">Node, which have related nodes</param>
        /// <param name="skipCount">Count of nodes will skip</param>
        /// <param name="limitCount">Count of nodes will returner after skip</param>
        /// <param name="orderByProperty">Property names by which to sort. ONLY properties of TRelatedNode</param>
        /// <returns>If target node don't have related nodes, will be returned empty lists</returns>
        Task<List<TRelation>> GetRelationsOfNodesAsync<TRelation, TRelatedNode> (TNode node, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TRelation : IRelation
            where TRelatedNode : INode;

        /// <summary>
        /// Get related nodes as List
        /// </summary>
        /// <typeparam name="TRelation">The type of searched relation</typeparam>
        /// <typeparam name="TRelatedNode">The type of related nodes</typeparam>
        /// <param name="nodeId">Node id, which have related nodes</param>
        /// <param name="skipCount">Count of nodes will skip</param>
        /// <param name="limitCount">Count of nodes will returner after skip</param>
        /// <param name="orderByProperty">Property names by which to sort. ONLY properties of TRelatedNode</param>
        /// <returns>If target node don't have related nodes, will be returned empty lists</returns>
        Task<List<TRelation>> GetRelationsOfNodesAsync<TRelation, TRelatedNode>(string nodeId, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TRelation : IRelation
            where TRelatedNode : INode;

        /// <summary>
        /// Relate two existing nodes
        /// </summary>
        /// <typeparam name="TRelation">The type of added relation</typeparam>
        /// <param name="relation">The relation, which will be related nodes</param>
        /// <returns></returns>
        Task RelateNodesAsync<TRelation>(TRelation relation)
            where TRelation : IRelation;

        /// <summary>
        /// Get all nodes, which haven't specified relation
        /// </summary>
        /// <typeparam name="TRelation">The type of relation, which nodes haven't to use</typeparam>
        /// <param name="skipCount">Count of nodes will skip</param>
        /// <param name="limitCount">Count of nodes will returner after skip</param>
        /// <param name="orderByProperty">Property names by which to sort. ONLY properties of TNode</param>
        /// <returns>Nodes, which haven't related using specified relation</returns>
        Task<List<TNode>> GetNodesWithoutRelation<TRelation>(int? skipCount = null, int? limitCount = null, params string[] orderByProperty);

        /// <summary>
        /// Get nodes by property from params
        /// </summary>
        /// <param name="nameOfProperty">Name of property, which will be use for search</param>
        /// <param name="propertyValues">Values of property</param>
        /// <param name="skipCount">Count of nodes will skip</param>
        /// <param name="limitCount">Count of nodes will returner after skip</param>
        /// <param name="orderByProperty">Property names by which to sort. ONLY properties of TNode</param>
        /// <returns></returns>
        Task<List<TNode>> GetNodesByPropertyAsync(string nameOfProperty, string[] propertyValues, int? skipCount = null, int? limitCount = null, params string[] orderByProperty);

        /// <summary>
        /// Set new type to node
        /// </summary>
        /// <typeparam name="TNewNodeType">New node type</typeparam>
        /// <param name="nodeId">Id of node</param>
        /// <returns></returns>
        Task SetNewNodeType<TNewNodeType>(string nodeId)
            where TNewNodeType : INode;

        /// <summary>
        /// Set new type to node
        /// </summary>
        /// <param name="nodeId">Id of node</param>
        /// <param name="nodeTypeName">Node type which will be new</param>
        /// <returns></returns>
        Task SetNewNodeType(string nodeId, string nodeTypeName);

        /// <summary>
        /// Remove new type to node. If the node doesn't implement this type, then nothing will happen.
        /// </summary>
        /// <typeparam name="TNodeType">Node type which will be removed</typeparam>
        /// <param name="nodeId">Id of node</param>
        /// <returns></returns>
        Task RemoveNodeType<TNodeType>(string nodeId)
            where TNodeType : INode;

        /// <summary>
        /// Remove new type to node. If the node doesn't implement this type, then nothing will happen.
        /// </summary>
        /// <param name="nodeId">Id of node</param>
        /// <param name="nodeTypeName">Node type which will be removed</param>
        /// <returns></returns>
        Task RemoveNodeType(string nodeId, string nodeTypeName);

        /// <summary>
        /// Return true if node is node type "TNodeType", false if not.
        /// </summary>
        /// <typeparam name="TNodeType">Node type which will searched</typeparam>
        /// <param name="nodeId">Id of node</param>
        /// <returns></returns>
        Task<bool> HasNodeType<TNodeType>(string nodeId)
            where TNodeType : INode;

        /// <summary>
        /// Return true if node is node type "TNodeType", false if not.
        /// </summary>
        /// <param name="nodeId">Id of node</param>
        /// <param name="nodeTypeName">Node type which will searched</param>
        /// <returns></returns>
        Task<bool> HasNodeType(string nodeId, string nodeTypeName);
    }
}

IOrderRepository.cs
using DbManager.Data;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Interfaces
{
    /// <summary>
    /// Interface for repository, which work with nodes Order
    /// </summary>
    public interface IOrderRepository : IGeneralRepository<Order>
    {
        Task<List<Order>> GetOrdersByStateRelatedWithNode<TNode>(string nodeId, string nameOfState, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TNode : INode;
        Task<List<Order>> GetOrdersByStateRelatedWithNode<TNode>(string nodeId, OrderStateEnum orderState, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TNode : INode;
        Task<List<Order>> GetOrdersByStateRelatedWithNode<TNode>(Guid nodeId, Guid orderStateId, int? skipCount = null, int? limitCount = null, params string[] orderByProperty)
            where TNode : INode;
        Task<HasOrderState?> MoveOrderToNextStage(string orderId, string comment);
        Task<bool> MoveOrderToPreviousStage(string orderId);
        Task<List<(string, double, int)>> GetOrderPriceAndCountStatistic();
        Task<List<(string, int, int)>> GetCountFinishedOrderAndClientsStatistic();
        Task<List<(string, List<Order>)>> GetCancelledOrderGroupedByMonthStatistic();
        Task<List<(Kitchen, int, int)>> GetCountOrdersAndOrderedDishesForEveryKitchenStatistic();
        Task CreateOrderRelationInDB(Order order, string? userId, List<Dish> dishes, Kitchen kitchen, DeliveryMan deliveryMan, Dictionary<string, int> countOfDishes, string? comment);
    }
}

IRepositoryFactory.cs
using DbManager.Data;

namespace DbManager.Neo4j.Interfaces
{
    /// <summary>
    /// Factory for IGeneralRepository, it uses for work with neo4j database
    /// </summary>
    public interface IRepositoryFactory
    {
        /// <summary>
        /// Get repository for work with database nodes
        /// </summary>
        /// <typeparam name="TEntity">Type node from database</typeparam>
        /// <param name="hasCustomRepository">Return custom repository if it register as service</param>
        /// <returns>IGeneralRepository for work with database</returns>
        IGeneralRepository<TEntity> GetRepository<TEntity>(bool hasCustomRepository = false) where TEntity : INode;
    }
}

IUserRepository.cs
using DbManager.Data;
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DbManager.Neo4j.Interfaces
{
    public interface IUserRepository : IGeneralRepository<User>
    {
        Dictionary<string, byte> UserRolePriority { get; }
        /// <summary>
        /// Return max priority role of user. For example, if user has Client and Admin roles, then it return Admin
        /// </summary>
        /// <param name="userId">Id of user</param>
        /// <returns>string Role</returns>
        Task<List<string>> GetUserRoles(string userId);

        Task<List<(User, List<string>)>> GetUsersForAdmin(int? skipCount, int? limitCount, params string[] orderByProperty);

        Task<List<User>> SearchUsersByIdAndLogin(string searchText, int? skipCount = null, int? limitCount = null, params string[] orderByProperty);

        Task<List<(User, List<string>)>> SearchUsersByIdAndLoginForAdmin(string searchText, int? skipCount = null, int? limitCount = null, params string[] orderByProperty);
    }
}


IPasswordService.cs

namespace DbManager.Services
{
    /// <summary>
    /// Service for generate argon2i hash
    /// </summary>
    public interface IPasswordService
    {
        /// <summary>
        /// Get Argon2i hash from password
        /// </summary>
        /// <param name="salt">string, which will be used as salt</param>
        /// <param name="password">string, which will be hashed</param>
        /// <returns></returns>
        byte[] GetPasswordHash(string salt, string password);
        /// <summary>
        /// Equels hash password with old hash from Db
        /// </summary>
        /// <param name="salt">string, which will be used as salt</param>
        /// <param name="password">string, which will be hashed</param>
        /// <param name="hashFromDb">hash old password</param>
        /// <returns></returns>
        bool CheckPassword(string salt, string password, byte[] hashFromDb);
    }
}

PasswordService.cs
using Konscious.Security.Cryptography;

namespace DbManager.Services
{
    public class PasswordService : IPasswordService
    {
        public byte[] GetPasswordHash(string salt, string password)
        {
            var argon2 = new Argon2i(password.Select(h => ((byte)h)).ToArray());
            argon2.Salt = salt.Select(h => ((byte)h)).ToArray();
            argon2.DegreeOfParallelism = 16;
            argon2.MemorySize = 4096;
            argon2.Iterations = 40;

            var hash = argon2.GetBytes(128);

            return hash;
        }

        public bool CheckPassword(string salt, string password, byte[] hashFromDb)
        {
            var passBytes = GetPasswordHash(salt, password);

            return hashFromDb.SequenceEqual(passBytes);
        }
    }
}

ApplicationSettings.cs
namespace WepPartDeliveryProject
{
    public class ApplicationSettings
    {
        public int CountOfItemsOnWebPage { get; set; }
        public string JwtSecretKey { get; set; }
        public bool GenerateData { get; set; }
    }
}

Program.cs
using DbManager;
using DbManager.Mapper;
using DbManager.Neo4j.DataGenerator;
using Microsoft.AspNetCore.Authentication.Cookies;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.DataProtection.KeyManagement;
using Microsoft.AspNetCore.Http.HttpResults;
using Microsoft.AspNetCore.SpaServices.ReactDevelopmentServer;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.IdentityModel.Tokens;
using Microsoft.Net.Http.Headers;
using Neo4jClient;
using Neo4jClient.Execution;
using Newtonsoft.Json;
using System.Text;
using WepPartDeliveryProject;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
var services = builder.Services;
var configuration = builder.Configuration;

services.AddLogging(loggingBuilder => {
    var loggingSection = configuration.GetSection("Logging");
    loggingBuilder.AddFile(loggingSection);
});

services.AddAutoMapper(typeof(MapperProfile));
services.AddSingleton<JwtService>();

builder.Services.AddCors(options =>
{
    options.AddDefaultPolicy(
        policy =>
        {
            policy
                .WithOrigins(configuration.GetSection("ClientAppSettings:ClientAppApi").Value)
                .WithOrigins("https://e9eb-176-124-28-223.ngrok-free.app")
                //.WithHeaders(HeaderNames.ContentType, HeaderNames.Cookie)
                .AllowAnyHeader()
                .AllowAnyMethod()
                .AllowCredentials();

            /*            policy
                            .AllowAnyOrigin()
                            .AllowAnyHeader()
                            .AllowAnyMethod();*/
        });
});

services.AddControllers().AddNewtonsoftJson(options =>
        {
            options.SerializerSettings.MaxDepth = 3;
            options.SerializerSettings.Formatting = Newtonsoft.Json.Formatting.Indented;
        }
    ); 
//services.AddEndpointsApiExplorer();
services.AddSwaggerGen();

// Register application setting
services.Configure<Neo4jSettings>(configuration.GetSection("Neo4jSettings"));
services.Configure<ApplicationSettings>(configuration.GetSection("ApplicationSettings"));

services.AddDbInfrastructure(configuration);
services.AddHealthChecks().AddCheck<GraphHealthCheck>("GraphHealthCheck");

services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;

})
    .AddJwtBearer(options =>
    {
        options.RequireHttpsMetadata = false;
        options.SaveToken = true;
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(configuration.GetSection("ApplicationSettings:JwtSecretKey").Value)),
            ValidateIssuer = false,
            ValidateAudience = false,
            ValidateLifetime = true,
        };
    });


var app = builder.Build();

// Configure the HTTP request pipeline.
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

var appSetting = new ApplicationSettings();
configuration.GetSection("ApplicationSettings").Bind(appSetting);

if (appSetting.GenerateData)
    await app.Services.GetService<GeneratorService>().GenerateAll();

//               
var graphClient = app.Services.GetService<IGraphClient>();
graphClient.OperationCompleted += (sender, e) => app.Logger.LogInformation(e.QueryText.Replace("\r\n", " "));

app.UseSwagger();
app.UseSwaggerUI(options =>
{
    options.SwaggerEndpoint("/swagger/v1/swagger.json", "v1");
    options.RoutePrefix = string.Empty;
});

app.UseCors();

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseHealthChecks("/healthcheck");

app.UseAuthentication();
app.UseRouting();
app.UseAuthorization();

app.MapControllers();

app.Run();
AdminController.cs
using AutoMapper;
using DbManager;
using DbManager.Data;
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.Interfaces;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Components.Forms;
using Microsoft.AspNetCore.Mvc;


namespace WepPartDeliveryProject.Controllers
{
    [Authorize(Roles = "Admin")]
    [Route("[controller]")]
    [ApiController]
    public class AdminController : Controller
    {
        private readonly IRepositoryFactory _repositoryFactory;
        private readonly ApplicationSettings _appSettings;
        private readonly IConfiguration _configuration;
        private readonly IMapper _mapper;

        public AdminController(IRepositoryFactory repositoryFactory, IConfiguration configuration, IMapper mapper)
        {
            // Fetch settings object from configuration
            _appSettings = new ApplicationSettings();
            configuration.GetSection("ApplicationSettings").Bind(_appSettings);

            _configuration = configuration;
            _repositoryFactory = repositoryFactory;
            _mapper = mapper;
        }

        [HttpGet("getOrders")]
        public async Task<IActionResult> GetOrders(int page = 0, int numberOfState = 1)
        {
            var orderRelations = await _repositoryFactory.GetRepository<OrderState>().GetRelationsOfNodesAsync<HasOrderState, Order>(OrderState.OrderStatesFromDb.First(h=>h.NumberOfStage == numberOfState), _appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1, "TimeStartState");

            var orders = orderRelations.Select(h => (Order)h.NodeFrom).ToList();

            var ordersDTOs = _mapper.Map<List<OrderOutDTO>>(orders);

            var pageEnded = ordersDTOs.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            return Ok(new { orders = ordersDTOs.GetRange(0, ordersDTOs.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage : ordersDTOs.Count), pageEnded });
        }

        [HttpGet("getDishes")]
        public async Task<IActionResult> GetDishes(string searchText = "", int page = 0)
        {
            var dishes = await ((IDishRepository)_repositoryFactory.GetRepository<Dish>(true))
                .SearchDishesByNameAndDescription(searchText, _appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1, "Name");

            var pageEnded = dishes.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            return Ok(new { dishes = dishes.GetRange(0, dishes.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage : dishes.Count), pageEnded });
        }

        [HttpGet("getDish/{id}")]
        public async Task<IActionResult> GetDish(Guid id)
        {
            var dish = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(id);
            var dishCategory = await _repositoryFactory.GetRepository<Dish>().GetRelationsOfNodesAsync<ContainsDish, Category>(dish);

            return Ok(new { dish, category = dishCategory.First().NodeFrom });
        }

        [HttpGet("getUsers")]
        public async Task<IActionResult> GetUsers(string searchText = "", int page = 0)
        {
            var usersAsTuples = await ((IUserRepository)_repositoryFactory.GetRepository<User>(true)).SearchUsersByIdAndLoginForAdmin(searchText, _appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1);

            var rightUsers = usersAsTuples.Select(h => _mapper.Map(h.Item2, _mapper.Map<UserForAdminOutDTO>(h.Item1))).ToList();
            
            var pageEnded = rightUsers.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            return Ok(new { users = rightUsers.GetRange(0, rightUsers.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage : rightUsers.Count), pageEnded });
        }

        [HttpGet("getRoles")]   
        public IActionResult GetRoles()
        {
            return Ok(((IUserRepository)_repositoryFactory.GetRepository<User>(true)).UserRolePriority.Keys.ToList().Except(new List<String>() { "User"}));
        }

        [HttpPost("addUserRole")]
        public async Task<IActionResult> AddUserRole(List<ManipulateUserDataInDTO> inputData)
        {
            var userRepo = (IUserRepository)_repositoryFactory.GetRepository<User>(true);
            var usersDicrionary = (await userRepo.GetNodesByPropertyAsync("Id", inputData.Select(h => h.UserId).ToArray())).ToDictionary(h => h.Id.ToString());

            foreach (var manipulateUsersData in inputData)
            {
                //на тот случай, если не все id верно переданы
                if (usersDicrionary.TryGetValue(manipulateUsersData.UserId, out var user))
                {
                    await _repositoryFactory.GetRepository<User>().SetNewNodeType(user.Id.ToString(), manipulateUsersData.ChangeRole);
                }

            }

            return Ok();
        }

        [HttpPost("removeUserRole")]
        public async Task<IActionResult> RemoveUserRole(List<ManipulateUserDataInDTO> inputData)
        {
            var userRepo = (IUserRepository)_repositoryFactory.GetRepository<User>(true);
            var usersDicrionary = (await userRepo.GetNodesByPropertyAsync("Id", inputData.Select(h => h.UserId).ToArray())).ToDictionary(h=>h.Id.ToString());

            foreach (var manipulateUsersData in inputData)
            {
                //на тот случай, если не все id верно переданы
                if(usersDicrionary.TryGetValue(manipulateUsersData.UserId, out var user))
                {
                    await _repositoryFactory.GetRepository<User>().RemoveNodeType(user.Id.ToString(), manipulateUsersData.ChangeRole);
                }

            }

            return Ok();
        }

        [HttpPost("blockUsers")]
        public async Task<IActionResult> BlockUsers(List<ManipulateUserDataInDTO> inputData)
        {
            var userRepo = (IUserRepository)_repositoryFactory.GetRepository<User>(true);
            var users = await userRepo.GetNodesByPropertyAsync("Id", inputData.Select(h=>h.UserId).ToArray());
            foreach (var user in users)
            {
                user.IsBlocked = true;
                await userRepo.UpdateNodeAsync(user);
            }

            return Ok();
        }

        [HttpPost("unblockUsers")]
        public async Task<IActionResult> UnblockUsers(List<ManipulateUserDataInDTO> inputData)
        {
            var userRepo = (IUserRepository)_repositoryFactory.GetRepository<User>(true);
            var users = await userRepo.GetNodesByPropertyAsync("Id", inputData.Select(h => h.UserId).ToArray());
            foreach (var user in users)
            {
                user.IsBlocked = false;
                await userRepo.UpdateNodeAsync(user);
            }

            return Ok();
        }

        [HttpPost("changeDeleteStatusOfDish")]
        public async Task<IActionResult> ChangeDeleteStatusOfDish(ManipulateDishDataInDTO inputData)
        {
            var dish = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(inputData.Id.ToString());
            if (dish == null)
            {
                return BadRequest("Данные о блюде не обнаружены");
            }

            dish.IsDeleted = !dish.IsDeleted;
            await _repositoryFactory.GetRepository<Dish>().UpdateNodeAsync(dish);

            return Ok(dish.IsDeleted);
        }

        [HttpPost("changeVisibleStatusOfDish")]
        public async Task<IActionResult> ChangeVisibleStatusOfDish(ManipulateDishDataInDTO inputData)
        {
            var dish = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(inputData.Id.ToString());
            if (dish == null)
            {
                return BadRequest("Данные о блюде не обнаружены");
            }

            dish.IsAvailableForUser = !dish.IsAvailableForUser;
            await _repositoryFactory.GetRepository<Dish>().UpdateNodeAsync(dish);

            return Ok(dish.IsAvailableForUser);
        }

        [HttpPatch("changeDish")]
        public async Task<IActionResult> ChangeDish([FromForm] ManipulateDishDataInDTO inputData)
        {
            var dishRepo = _repositoryFactory.GetRepository<Dish>();
            var dishToChange = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(inputData.Id.ToString());
            if(dishToChange == null)
            {
                return BadRequest("Данные о блюде не обнаружены");
            }

            var category = Category.CategoriesFromDb.SingleOrDefault(h => h.Id.ToString() == inputData.CategoryId);

            var curDishCategory = await dishRepo.GetRelationsOfNodesAsync<ContainsDish, Category>(dishToChange);

            if(curDishCategory != null && curDishCategory.Count !=0 && curDishCategory.First().NodeFromId != category.Id)
            {
                await dishRepo.DeleteRelationOfNodesAsync<ContainsDish, Category>(dishToChange, (Category)curDishCategory.First().NodeFrom);

                await dishRepo.RelateNodesAsync(new ContainsDish() { NodeFrom = category, NodeTo = dishToChange });
            }

            _mapper.Map(inputData, dishToChange);

            var newImages = await LoadImagesToDir(inputData.ImagesFiles, category.LinkName, dishToChange.Id.ToString());
            if(newImages.Count != 0)
            {
                dishToChange.Images = newImages;
            }

            await _repositoryFactory.GetRepository<Dish>().UpdateNodeAsync(dishToChange);

            return Ok(dishToChange.Id);
        }

        [HttpPost("createDish")]
        public async Task<IActionResult> CreateDish([FromForm] ManipulateDishDataInDTO inputData)
        {
            var dishRepo = _repositoryFactory.GetRepository<Dish>();
            var dish = _mapper.Map<Dish>(inputData);
            dish.Images = new List<string>();
            var category = Category.CategoriesFromDb.SingleOrDefault(h => h.Id.ToString() == inputData.CategoryId);

            await dishRepo.AddNodeAsync(dish);
            await dishRepo.RelateNodesAsync(new ContainsDish() { NodeFrom = category, NodeTo = dish});

            dish.Images = await LoadImagesToDir(inputData.ImagesFiles, category.LinkName, dish.Id.ToString());
            if(dish.Images.Count != 0)
            {
                await dishRepo.UpdateNodeAsync(dish);
            }

            return Ok(dish.Id);
        }

        private async Task<List<string>> LoadImagesToDir(IFormFileCollection? files, string categoryLinkName, string dishId)
        {
            var images = new List<string>();

            var pathToPublicClientAppDirectory = _configuration.GetSection("ClientAppSettings:PathToPublicSourceDirecroty").Value;
            var dirWithDishImages = _configuration.GetSection("ClientAppSettings:DirectoryWithDishImages").Value;

            var pathToDishDir = ServiceRegistration.PathToDirWithDish(pathToPublicClientAppDirectory, dirWithDishImages, categoryLinkName, dishId);

            if (!Directory.Exists(pathToDishDir))
                Directory.CreateDirectory(pathToDishDir);

            if (files != null)
            {
                foreach (var imageFile in files)
                {
                    var pathToImage = Path.Combine(pathToDishDir, imageFile.FileName);
                    using var fileStream = new FileStream(pathToImage, FileMode.Create);
                    await imageFile.CopyToAsync(fileStream);

                    images.Add(ServiceRegistration.ConvertFromIOPathToInternetPath_DirWithDish(pathToPublicClientAppDirectory, pathToImage));
                }
            }

            return images;
        }
    }
}

AuthController.cs
using DbManager.Data;
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using DbManager.Neo4j.Interfaces;
using DbManager.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace WepPartDeliveryProject.Controllers
{
    [Route("[controller]")]
    [ApiController]
    public class AuthController : ControllerBase
    {
        private readonly IRepositoryFactory _repositoryFactory;
        private readonly IPasswordService _pswService;
        private readonly JwtService _jwtService;

        public AuthController(IRepositoryFactory repositoryFactory, IPasswordService passwordService, JwtService jwtService)
        {
            _repositoryFactory = repositoryFactory;
            _pswService = passwordService;
            _jwtService = jwtService;
        }

        private void AddCookieDataToResponse(string RefreshToken, string? userId = null)
        {
            if(userId != null) 
            {
                Response.Cookies.Append("X-UserId", userId,
                            new CookieOptions() { HttpOnly = true, Secure = true, Expires = DateTime.Now.AddDays(60), SameSite = SameSiteMode.None });
            }

            Response.Cookies.Append("X-Refresh-Token", RefreshToken,
                        new CookieOptions() { HttpOnly = true, Secure = true, Expires = DateTime.Now.AddDays(60), SameSite = SameSiteMode.None });

        }

        [HttpPost("login")]
        public async Task<IActionResult> Login(UserLoginInDTO data)
        {
            var users = await _repositoryFactory.GetRepository<User>().GetNodesByPropertyAsync("Login", new[] { data.Login });
            if(users.Count != 1)
            {
                return BadRequest("Вы ввели не верный логин");
            }

            var user = users[0];

            if (user.IsBlocked)
            {
                return BadRequest("Ваш аккаунт был заблокирован!");
            }

            if(_pswService.CheckPassword(data.Login, data.Password, user.PasswordHash.ToArray()))
            {
                user.RefreshToken = Guid.NewGuid();
                user.RefreshTokenCreated = DateTime.Now;

                await _repositoryFactory.GetRepository<User>().UpdateNodesPropertiesAsync(user);

                AddCookieDataToResponse(user.RefreshToken.ToString(), user.Id.ToString());

                return Ok();
            }

            return Unauthorized("Вы ввели не верный логин или пароль");
        }

        [HttpPost("refreshAccessToken")]
        public async Task<IActionResult> RefreshAccessToken()
        {
            var userRepo = (IUserRepository)_repositoryFactory.GetRepository<User>(true);

            var userId = Request.Cookies["X-UserId"];
            if (userId == null)
                return BadRequest("У вас отсутсвует refresh token. Вам необходимо авторизоваться или зарегистрироваться.");

            var inputRefreshToken = Request.Cookies["X-Refresh-Token"];

            var userNode = await userRepo.GetNodeAsync(userId);

            if (userNode.IsBlocked)
                return BadRequest("Ваш аккаунт был заблокирован!");

            if (inputRefreshToken == userNode.RefreshToken.ToString() && userNode.RefreshTokenCreated.AddDays(60) > DateTime.Now)
            {
                var userRoles = await userRepo.GetUserRoles(userId);

                var jwtTokenInfo = _jwtService.GenerateAccessJwtToken(userId, userRoles);

                userNode.RefreshTokenCreated = DateTime.Now;

                await userRepo.UpdateNodesPropertiesAsync(userNode);

                AddCookieDataToResponse(userNode.RefreshToken.ToString());
                
                return Ok(jwtTokenInfo);
            }

            return BadRequest("You refresh token don't work. You need to login or signup to system");
        }

        [HttpPost("signup")]
        public async Task<IActionResult> Signup(UserSignupInDTO data)
        {
            var user = new User() { 
                Login = data.Login, 
                Name = data.Name,
                Born = data.Born,
                Address = data.Address,
                PhoneNumber = data.PhoneNumber,
                RefreshToken = Guid.NewGuid(), 
                RefreshTokenCreated = DateTime.Now, 
                PasswordHash = _pswService.GetPasswordHash(data.Login, data.Password).ToList(), 
            };

            await _repositoryFactory.GetRepository<User>().AddNodeAsync(user);
            await _repositoryFactory.GetRepository<User>().SetNewNodeType<Client>(user.Id.ToString());

            AddCookieDataToResponse(user.RefreshToken.ToString(), user.Id.ToString());

            return Ok();
        }

        [Authorize]
        [HttpPost("logout")]
        public async Task<IActionResult> Logout()
        {
            Response.Cookies.Delete("X-UserId",
                        new CookieOptions() { HttpOnly = true, Secure = true, Expires = DateTime.Now.AddDays(60), SameSite = SameSiteMode.None });
            Response.Cookies.Delete("X-Refresh-Token",
                        new CookieOptions() { HttpOnly = true, Secure = true, Expires = DateTime.Now.AddDays(60), SameSite = SameSiteMode.None });

            return Ok();
        }
    }
}

DeliveryManController.cs
using AutoMapper;
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Data;
using DbManager.Neo4j.Interfaces;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace WepPartDeliveryProject.Controllers
{
    [Authorize(Roles = "DeliveryMan")]
    [Route("[controller]")]
    [ApiController]
    public class DeliveryManController : Controller
    {
        private readonly IRepositoryFactory _repositoryFactory;
        private readonly ApplicationSettings _appSettings;
        private readonly IMapper _mapper;

        public DeliveryManController(IRepositoryFactory repositoryFactory, IConfiguration configuration, IMapper mapper)
        {
            // Fetch settings object from configuration
            _appSettings = new ApplicationSettings();
            configuration.GetSection("ApplicationSettings").Bind(_appSettings);

            _repositoryFactory = repositoryFactory;
            _mapper = mapper;
        }

        [HttpGet("getOrders")]
        public async Task<IActionResult> GetOrderQueue(int page = 0, int numberOfState = 1)
        {
            var userId = Request.Cookies["X-UserId"];
            if (userId == null)
            {
                return BadRequest("You don't have refresh token. You need to login or signup to system");
            }

            var orderRepo = (IOrderRepository)_repositoryFactory.GetRepository<Order>(true);

            var delMan = await _repositoryFactory.GetRepository<DeliveryMan>().GetNodeAsync(userId);

            var orders = await orderRepo.GetOrdersByStateRelatedWithNode<DeliveryMan>(delMan.Id.ToString(), (OrderStateEnum)numberOfState, _appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1);

            var ordersOut = _mapper.Map<List<OrderOutDTO>>(orders);

            var pageEnded = ordersOut.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            return Ok(new { orders = ordersOut.GetRange(0, ordersOut.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage : ordersOut.Count), pageEnded });
        }
    }
}

KitchenController.cs
using AutoMapper;
using DbManager.Data;
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.Interfaces;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace WepPartDeliveryProject.Controllers
{
    [Authorize(Roles = "KitchenWorker")]
    [Route("[controller]")]
    [ApiController]
    public class KitchenController : Controller
    {
        private readonly IRepositoryFactory _repositoryFactory;
        private readonly ApplicationSettings _appSettings;
        private readonly IMapper _mapper;

        public KitchenController(IRepositoryFactory repositoryFactory, IConfiguration configuration, IMapper mapper)
        {
            // Fetch settings object from configuration
            _appSettings = new ApplicationSettings();
            configuration.GetSection("ApplicationSettings").Bind(_appSettings);

            _repositoryFactory = repositoryFactory;
            _mapper = mapper;
        }

        [HttpGet("getOrders")]
        public async Task<IActionResult> GetOrderQueue(int page = 0, int numberOfState = 1)
        {
            var userId = Request.Cookies["X-UserId"];
            if (userId == null)
            {
                return BadRequest("You don't have refresh token. You need to login or signup to system");
            }

            var orderRepo = (IOrderRepository)_repositoryFactory.GetRepository<Order>(true);

            var workedIns = await _repositoryFactory.GetRepository<KitchenWorker>().GetRelationsOfNodesAsync<WorkedIn, Kitchen>(userId);
            var kitchen = (Kitchen)workedIns.FirstOrDefault().NodeTo;

            var orders = await orderRepo.GetOrdersByStateRelatedWithNode<Kitchen>(kitchen.Id.ToString(), (OrderStateEnum)numberOfState, _appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1);

            var ordersOut = _mapper.Map<List<OrderOutDTO>>(orders);

            var pageEnded = ordersOut.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            return Ok(new { orders = ordersOut.GetRange(0, ordersOut.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage : ordersOut.Count), pageEnded });
        }

        [HttpGet("getWorkers")]
        public async Task<IActionResult> GeWorkers()
        {
            var userId = Request.Cookies["X-UserId"];
            if (userId == null)
            {
                return BadRequest("You don't have refresh token. You need to login or signup to system");
            }

            var workedIns = await _repositoryFactory.GetRepository<KitchenWorker>().GetRelationsOfNodesAsync<WorkedIn, Kitchen>(userId);
            var kitchen = (Kitchen)workedIns.FirstOrDefault().NodeTo;

            var kitchenWorkers = await _repositoryFactory.GetRepository<Kitchen>().GetRelationsOfNodesAsync<WorkedIn, KitchenWorker>(kitchen);

            var kitchenWorkersOut = _mapper.Map<List<KitchenWorkerOutDTO>>(kitchenWorkers.Select(h=>(KitchenWorker)h.NodeFrom).ToList());

            for (int i = 0; i < kitchenWorkersOut.Count; i++)
            {
                if(kitchenWorkersOut[i].Id == kitchenWorkers[i].NodeFromId)
                {
                    kitchenWorkersOut[i].GotJob = kitchenWorkers[i].GotJob;
                }
            }

            return Ok(kitchenWorkersOut);
        }
    }
}

MainController.cs
using AutoMapper;
using DbManager;
using DbManager.Data;
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using DbManager.Data.Relations;
using DbManager.Neo4j.DataGenerator;
using DbManager.Neo4j.Implementations;
using DbManager.Neo4j.Interfaces;
using DbManager.Services;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;
using Swashbuckle.AspNetCore.SwaggerGen;

namespace WepPartDeliveryProject.Controllers
{
    [Route("[controller]")]
    [ApiController]
    public class MainController : ControllerBase
    {
        private readonly IRepositoryFactory _repositoryFactory;
        private readonly ApplicationSettings _appSettings;
        private readonly IMapper _mapper;
        private readonly int countCharInDishDescription = 160;

        public MainController(IRepositoryFactory repositoryFactory, IConfiguration configuration, IMapper mapper)
        {
            // Fetch settings object from configuration
            _appSettings = new ApplicationSettings();
            configuration.GetSection("ApplicationSettings").Bind(_appSettings);

            _repositoryFactory = repositoryFactory;
            _mapper = mapper;
        }

        [HttpGet("getDishesForMainPage")]
        public async Task<IActionResult> GetDishesForMainPage(int page = 0)
        {
            //обычному пользователю не должен быть доступен удаленный или недоступный продукт
            var dishes = await _repositoryFactory.GetRepository<Dish>().GetNodesAsync(_appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1, "Name");

            var pageEnded = dishes.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            PrepareDish(dishes);

            return Ok(new { dishes = dishes.GetRange(0, dishes.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage : dishes.Count), pageEnded });
        }

        [HttpGet("getOrderStates")]
        public async Task<IActionResult> GetOrderStates()
        {
            var states = _mapper.Map<List<OrderStateItemOutDTO>>(OrderState.OrderStatesFromDb);

            return Ok(states);
        }

        [HttpGet("getCategoriesList")]
        public IActionResult GetCategoriesList()
        {
            var categories = Category.CategoriesFromDb;
            return Ok(categories);
        }

        [HttpGet("getDishIds")]
        public async Task<IActionResult> GetDishIds()
        {
            var dishIds = (await _repositoryFactory.GetRepository<Dish>().GetNodesAsync()).Select(h=>h.Id).ToList();
            return Ok(dishIds);
        }

        [HttpGet("getDish/{id}")]
        public async Task<IActionResult> GetDish(Guid id)
        {
            var dish = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(id);

            var userId = Request.Cookies["X-UserId"];
            if (userId != null)
            {
                if (dish.IsDeleted || !dish.IsAvailableForUser)
                {
                    return BadRequest("Данный продукт был скрыт или удален");
                }
            }

            return Ok(dish);
        }

        [HttpGet("getDishAbilityInfo/{id}")]
        public async Task<IActionResult> GetDishAbilityInfo(Guid id)
        {
            var dish = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(id);

            var userCanAbilityToViewDish = !dish.IsDeleted && dish.IsAvailableForUser;

            return Ok(userCanAbilityToViewDish);
        }

        [HttpGet("getDishesList/{category}")]
        public async Task<IActionResult> GetDishesList(string category)
        {
            var choicedCategory = Category.CategoriesFromDb.Single(h=>h.LinkName == category);
            var categoryDishes = await _repositoryFactory.GetRepository<Category>().GetRelationsOfNodesAsync<ContainsDish, Dish>(choicedCategory, orderByProperty: "Name");

            var dishes = categoryDishes.Select(h => (Dish)h.NodeTo).ToList();

            PrepareDish(dishes);

            return Ok(dishes);
        }

        [HttpGet("getSearchedDishes")]
        public async Task<IActionResult> GetCart(string searchText, int page = 0)
        {
            //обычному пользователю не должен быть доступен удаленный или недоступный продукт
            var dishes = await ((IDishRepository)_repositoryFactory.GetRepository<Dish>(true))
                .SearchDishesByNameAndDescription(searchText, _appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1, "Name");

            var pageEnded = dishes.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            PrepareDish(dishes);

            return Ok(new { dishes = dishes.GetRange(0, dishes.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage: dishes.Count), pageEnded});
        }

        [Authorize]
        [HttpGet("getProfileInfo")]
        public async Task<IActionResult> GetProfileInfo()
        {
            var userId = Request.Cookies["X-UserId"];
            if (userId == null)
            {
                return BadRequest("You don't have refresh token. You need to login or signup to system");
            }

            var user = _mapper.Map<ProfileUserOutDTO>(await _repositoryFactory.GetRepository<User>().GetNodeAsync(userId));

            return Ok(user);
        }

        private void PrepareDish(List<Dish> dishes)
        {
            for (int i = 0; i < dishes.Count; i++)
            {
                var dish = dishes[i];
                if (dish.IsDeleted || !dish.IsAvailableForUser)
                {
                    dishes.Remove(dish);
                    i--;
                }
                else if (dish.Description.Length > countCharInDishDescription)
                    dish.Description = dish.Description.Substring(0, countCharInDishDescription - 3) + "...";
            }
        }
    }
}
 
OrderController.cs
using DbManager.Data.DTOs;
using DbManager.Data.Nodes;
using DbManager.Neo4j.Interfaces;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Newtonsoft.Json;
using DbManager.Data.Relations;
using AutoMapper;
using DbManager.Data;
using System.Xml.Linq;

namespace WepPartDeliveryProject.Controllers
{
    [Authorize]
    [Route("[controller]")]
    [ApiController]
    public class OrderController : Controller
    {
        private readonly IRepositoryFactory _repositoryFactory;
        private readonly ApplicationSettings _appSettings;
        private readonly IMapper _mapper;
        private readonly JwtService _jwtService;

        public OrderController(IRepositoryFactory repositoryFactory, IConfiguration configuration, IMapper mapper, JwtService jwtService)
        {
            // Fetch settings object from configuration
            _appSettings = new ApplicationSettings();
            configuration.GetSection("ApplicationSettings").Bind(_appSettings);

            _repositoryFactory = repositoryFactory;
            _mapper = mapper;
            _jwtService = jwtService;
        }

        [AllowAnonymous]
        [HttpGet("getCart")]
        public async Task<IActionResult> GetCart()
        {
            var jsonData = Request.Cookies["cartDishes"];

            var res = jsonData != null ? JsonConvert.DeserializeObject<Dictionary<string, int>>(jsonData) : new Dictionary<string, int>();

            var dishes = await _repositoryFactory.GetRepository<Dish>().GetNodesByPropertyAsync("Id", res.Keys.ToArray());

            return Ok(dishes);
        }

        [AllowAnonymous]
        [HttpPost("placeAnOrder")]
        public async Task<IActionResult> PlaceAnOrder(PlaceAnOrderInDTO inputData)
        {
            var jsonData = Request.Cookies["cartDishes"];
            var userId = Request.Cookies["X-UserId"];

            var res = jsonData != null ? JsonConvert.DeserializeObject<Dictionary<string, int>>(jsonData) : new Dictionary<string, int>();
            if (res.Count == 0)
                return BadRequest("При оформлении заказа, в корзине отсутсвовали продукты");

            var dishes = await _repositoryFactory.GetRepository<Dish>().GetNodesByPropertyAsync("Id", res.Keys.ToArray());

            var order = new Order() { 
                SumWeight = dishes.Sum(h=>h.Weight), 
                Price = dishes.Sum(h => h.Price), 
                DeliveryAddress = inputData.DeliveryAddress, 
                PhoneNumber = inputData.PhoneNumber };

            var orderRepo = (IOrderRepository)_repositoryFactory.GetRepository<Order>(true);

            await orderRepo.AddNodeAsync(order);

            var kitchens = await _repositoryFactory.GetRepository<Kitchen>().GetNodesAsync();
            var randomKitchen = kitchens[new Random().Next(0, kitchens.Count)];

            var deliveryMen = await _repositoryFactory.GetRepository<DeliveryMan>().GetNodesAsync();
            var randomdelMan = deliveryMen[new Random().Next(0, deliveryMen.Count)];

            await orderRepo.CreateOrderRelationInDB(order, userId, dishes, randomKitchen, randomdelMan, res, inputData.Comment);

            return Ok();
        }

        [Authorize(Roles = "Admin")]
        [HttpPost("changeCountOrderedDish")]
        public async Task<IActionResult> ChangeCountOrderedDish(ManipulateOrderDataInDTO inputData)
        {
            var order = await _repositoryFactory.GetRepository<Order>().GetNodeAsync(inputData.OrderId);

            var dish = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(inputData.DishId);

            var orderedDish = await _repositoryFactory.GetRepository<Dish>().GetRelationBetweenTwoNodesAsync<OrderedDish, Order>(dish, order);

            order.Price -= orderedDish.Count * dish.Price;

            orderedDish.Count = (int)inputData.NewCount;

            order.Price += orderedDish.Count * dish.Price;

            await _repositoryFactory.GetRepository<Order>().UpdateNodeAsync(order);

            await _repositoryFactory.GetRepository<Order>().UpdateRelationNodesAsync(orderedDish);

            return Ok();
        }

        [HttpGet("getClientOrders")]
        public async Task<IActionResult> GetClientOrders(int page = 0, int numberOfState = 1)
        {
            var userId = Request.Cookies["X-UserId"];
            if (userId == null)
            {
                return BadRequest("You don't have refresh token. You need to login or signup to system");
            }

            var orderRepo = (IOrderRepository)_repositoryFactory.GetRepository<Order>(true);

            var orders = await orderRepo.GetOrdersByStateRelatedWithNode<Client>(userId, (OrderStateEnum)numberOfState, _appSettings.CountOfItemsOnWebPage * page, _appSettings.CountOfItemsOnWebPage + 1);

            var ordersOut = _mapper.Map<List<OrderOutDTO>>(orders);

            var pageEnded = ordersOut.Count() < _appSettings.CountOfItemsOnWebPage + 1;

            return Ok(new { orders = ordersOut.GetRange(0, ordersOut.Count > _appSettings.CountOfItemsOnWebPage ? _appSettings.CountOfItemsOnWebPage : ordersOut.Count), pageEnded });
        }

        [HttpGet("getOrder/{orderId}")]
        public async Task<IActionResult> GetOrder(string orderId)
        {
            Order? searchedOrder;
            if (_jwtService.UserHasRole(Request.Headers.Authorization.FirstOrDefault(), "Admin") 
                || _jwtService.UserHasRole(Request.Headers.Authorization.FirstOrDefault(), "KitchenWorker")
                || _jwtService.UserHasRole(Request.Headers.Authorization.FirstOrDefault(), "DeliveryMan"))
            {
                searchedOrder = await _repositoryFactory.GetRepository<Order>().GetNodeAsync(orderId);
            }
            else
            {
                var userId = Request.Cookies["X-UserId"];

                if (userId == null)
                {
                    return BadRequest("You don't have refresh token. You need to login or signup to system");
                }

                var ordereds = await _repositoryFactory.GetRepository<Client>().GetRelationsOfNodesAsync<Ordered, Order>(userId);
                searchedOrder = (Order)ordereds.SingleOrDefault(h => h.NodeToId.ToString() == orderId)?.NodeTo;
            }

            if (searchedOrder != null)
            {
                var reviewedOrder = await _repositoryFactory.GetRepository<Order>().GetRelationsOfNodesAsync<ReviewedBy, Client>(searchedOrder);
                var orderedDishes = await _repositoryFactory.GetRepository<Order>().GetRelationsOfNodesAsync<OrderedDish, Dish>(searchedOrder);

                var preparedOrder = _mapper.Map<OrderOutDTO>(searchedOrder);
                if(reviewedOrder.Count != 0)
                    _mapper.Map(reviewedOrder[0], preparedOrder);
                preparedOrder.Story = _mapper.Map<List<OrderStateItemOutDTO>>(searchedOrder.Story);

                return Ok(new { order = preparedOrder, orderedDishes = orderedDishes.Select(h=> new {count = h.Count, dishInfo = h.NodeTo}) });
            }

            return BadRequest("Запрашиваемый заказ не доступен данному пользователю или не существует");
        }

        [Authorize(Roles = "Admin")]
        [HttpPost("cancelOrderedDish")]
        public async Task<IActionResult> CancelOrderedDish(ManipulateOrderDataInDTO inputData)
        {
            var order = await _repositoryFactory.GetRepository<Order>().GetNodeAsync(inputData.OrderId);

            var dish = await _repositoryFactory.GetRepository<Dish>().GetNodeAsync(inputData.DishId);

            var orderedDish = await _repositoryFactory.GetRepository<Dish>().GetRelationBetweenTwoNodesAsync<OrderedDish, Order>(dish, order);

            order.Price -= orderedDish.Count * dish.Price;

            await _repositoryFactory.GetRepository<Order>().UpdateNodeAsync(order);

            await _repositoryFactory.GetRepository<Order>().DeleteRelationOfNodesAsync<OrderedDish, Dish>(order, dish);

            return Ok();
        }

        [Authorize(Roles = "Admin, Client")]
        [HttpPost("cancelOrder")]
        public async Task<IActionResult> CancelOrder(ManipulateOrderDataInDTO inputData)
        {
            var orderRepo = _repositoryFactory.GetRepository<Order>();

            var order = await orderRepo.GetNodeAsync(inputData.OrderId);
            var orderHasState = order.Story.Last();
            var orderState = OrderState.OrderStatesFromDb.Single(h => h.Id == orderHasState.NodeToId);

            await orderRepo.DeleteRelationOfNodesAsync<HasOrderState, OrderState>(order, orderState);

            var cancelState = OrderState.OrderStatesFromDb.First(h => h.NumberOfStage == (int)OrderStateEnum.Cancelled);
            var relationCancel = new HasOrderState() { Comment = inputData.ReasonOfCancel, NodeFromId = order.Id, NodeToId = cancelState.Id, TimeStartState = DateTime.Now };

            order.Story.Add(relationCancel);
            await orderRepo.RelateNodesAsync(relationCancel);
            await orderRepo.UpdateNodeAsync(order);

            return Ok();
        }

        [Authorize(Roles = "Admin, KitchenWorker, DeliveryMan")]
        [HttpPost("moveToNextStage")]
        public async Task<IActionResult> MoveToNextStage(ManipulateOrderDataInDTO inputData)
        {
            var orderRepo = (IOrderRepository) _repositoryFactory.GetRepository<Order>(true);
            var newHasOrderState = await orderRepo.MoveOrderToNextStage(inputData.OrderId, "Изменено администрацией");

            if(newHasOrderState != null){
                return Ok(_mapper.Map<OrderStateItemOutDTO>(newHasOrderState));
            }
            return BadRequest("Заказ находится на финальной стадии и его состояние не может перейти на следующую стадию");
        }

        [Authorize(Roles = "Admin, KitchenWorker")]
        [HttpPost("moveToPreviousStage")]
        public async Task<IActionResult> MoveToPreviousStage(ManipulateOrderDataInDTO inputData)
        {
            var orderRepo = (IOrderRepository)_repositoryFactory.GetRepository<Order>(true);
            if (await orderRepo.MoveOrderToPreviousStage(inputData.OrderId))
                return Ok();
            return BadRequest("Заказ находится на начальной стадии и его состояние не может перейти на предыдущую стадию");
        }

        [Authorize(Roles = "Client")]
        [HttpPost("reviewOrder")]
        public async Task<IActionResult> ReviewOrder(ReviewOrderInDTO inputData)
        {
            var userId = Request.Cookies["X-UserId"];
            if (userId == null)
            {
                return BadRequest("You don't have refresh token. You need to login or signup to system");
            }

            var orderRepo = _repositoryFactory.GetRepository<Order>();

            var reviews = await orderRepo.GetRelationBetweenTwoNodesAsync<ReviewedBy, Client>(new Order() { Id = Guid.Parse(inputData.OrderId) }, new Client() { Id = Guid.Parse(userId) });
            if(reviews != null)
            {
                return BadRequest("Вы уже оставили отзыв о данном заказе");
            }

            var reviewRelation = new ReviewedBy()
            {
                NodeFromId = Guid.Parse(userId),
                NodeToId = Guid.Parse(inputData.OrderId),
                Review = inputData.Review,
                ClientRating = inputData.ClientRating,
                TimeCreated = DateTime.Now,
            };

            await orderRepo.RelateNodesAsync(reviewRelation);

            return Ok();
        }
    }
}

StatisticController.cs
using DbManager.Data.DTOs;
using DbManager.Data;
using DbManager.Neo4j.Interfaces;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using DbManager.Data.Nodes;
using AutoMapper;
using DbManager.Data.Relations;

namespace WepPartDeliveryProject.Controllers
{
    [Authorize(Roles = "Admin")]
    [Route("[controller]")]
    [ApiController]
    public class StatisticController : Controller
    {
        private readonly IRepositoryFactory _repositoryFactory;
        private readonly ApplicationSettings _appSettings;
        private readonly IMapper _mapper;

        public StatisticController(IRepositoryFactory repositoryFactory, IConfiguration configuration, IMapper mapper)
        {
            // Fetch settings object from configuration
            _appSettings = new ApplicationSettings();
            configuration.GetSection("ApplicationSettings").Bind(_appSettings);

            _repositoryFactory = repositoryFactory;
            _mapper = mapper;
        }

        public static List<StatisticQueryInfoOutDTO> Statistics { get; } = new List<StatisticQueryInfoOutDTO>()
        {
            new StatisticQueryInfoOutDTO(){ NameQuery = "Количество и суммарная стоимость заказов по месяцам",                      LinkToQuery = "query1", ChartName = "line", NeedDataRange = true, NameDatasets = new List<string>(){ "Стоимость заказов", "Количество заказов" } },
            new StatisticQueryInfoOutDTO(){ NameQuery = "Топ-10 клиентов по стоимости заказов",                                     LinkToQuery = "query2", ChartName = "line", NeedDataRange = true, NameDatasets = new List<string>(){ "Стоимость заказов", "Количество заказов" } },
            new StatisticQueryInfoOutDTO(){ NameQuery = "Топ доставщиков по количеству заказов",                                    LinkToQuery = "query3", ChartName = "line", NeedDataRange = true},
            new StatisticQueryInfoOutDTO(){ NameQuery = "Количество отмененных заказов на каждой стадии",                           LinkToQuery = "query4", ChartName = "radar",NeedDataRange = true},
            new StatisticQueryInfoOutDTO(){ NameQuery = "Сколько в среднем клиенты оформляют заказов, если оформляют",              LinkToQuery = "query5", ChartName = "bar",  NeedDataRange = true, NameDatasets = new List<string>(){ "Количество заказов", "Количество клиентов, оформивших заказы" } },
            new StatisticQueryInfoOutDTO(){ NameQuery = "Средняя продолжительность пребывания заказа в стадии",                     LinkToQuery = "query6", ChartName = "line", NeedDataRange = true},
            new StatisticQueryInfoOutDTO(){ NameQuery = "Количество выполненных заказов и приготовленных блюд в каждой из кухонь",  LinkToQuery = "query7", ChartName = "bar",  NeedDataRange = true, NameDatasets = new List<string>(){ "Количество выполненных заказов", "Количество приготовленных блюд" } },
            new StatisticQueryInfoOutDTO(){ NameQuery = "Топ-10 самых популярных блюд",                                             LinkToQuery = "query8", ChartName = "line", NeedDataRange = true},
        };

        [AllowAnonymous]
        [HttpGet("getStatisticQueries")]
        public IActionResult GetStatisticQueries()
        {
            return Ok(Statistics);
        }

        [HttpGet("query1")]
        public async Task<IActionResult> GetQuery1()
        {
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var resData = await ((IOrderRepository)_repositoryFactory.GetRepository<Order>(true)).GetOrderPriceAndCountStatistic();

            foreach (var item in resData)
            {
                resQueryData.Add(new StatisticQueryDataItemOutDTO() { Y = new List<double>() { item.Item2, item.Item3 }, X = item.Item1 });
            }

            return Ok(resQueryData);
        }

        [HttpGet("query2")]
        public async Task<IActionResult> GetQuery2()
        {
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var clientRepo = (IClientRepository)_repositoryFactory.GetRepository<Client>(true);

            var topClients = await clientRepo.GetTopClientBySumPriceOrderStatistic(10);
            topClients.Reverse();

            foreach (var item in topClients)
            {
                resQueryData.Add(new StatisticQueryDataItemOutDTO() { Y = new List<double>() { item.Item2, item.Item3 }, X = item.Item1.Login });
            }

            return Ok(resQueryData);
        }

        [HttpGet("query3")]
        public async Task<IActionResult> GetQuery3()
        {
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var delManRepo = (IDeliveryManRepository)_repositoryFactory.GetRepository<DeliveryMan>(true);

            var topDelMen = await delManRepo.GetTopDeliveryMenByCountOrder(10);
            topDelMen.Reverse();

            foreach (var item in topDelMen)
            {
                resQueryData.Add(new StatisticQueryDataItemOutDTO() { Y = new List<double>() { item.Item2 }, X = item.Item1.Name });
            }

            return Ok(resQueryData);
        }

        [HttpGet("query4")]
        public async Task<IActionResult> GetQuery4()
        {
            //месяц только для диапазона, выводиться будет как название dataset
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var resData = await ((IOrderRepository)_repositoryFactory.GetRepository<Order>(true)).GetCancelledOrderGroupedByMonthStatistic();

            var nameDatasets = new List<string>();

            for (int i = 0; i < resData.Count; i++)
            {
                nameDatasets.Add(resData[i].Item1);

                foreach (var order in resData[i].Item2)
                {
                    var previousHasOrderState = order.Story[order.Story.Count - 2];
                    previousHasOrderState.NodeTo = OrderState.OrderStatesFromDb.Find(el => el.Id == previousHasOrderState.NodeToId);
                    var previousNameOfState = ((OrderState)previousHasOrderState.NodeTo).NameOfState;
                    var dataItem = resQueryData.Find(el => el.X == previousNameOfState);

                    if(dataItem == null)
                    {
                        dataItem = new StatisticQueryDataItemOutDTO() { Y = new List<double>(), X = previousNameOfState };
                        resQueryData.Add(dataItem);
                    }

                    foreach (var item in resQueryData)
                    {
                        while (item.Y.Count != i + 1)
                            item.Y.Add(0);
                    }

                    dataItem.Y[i]++;
                }

                
            }

            return Ok(new { queryData = resQueryData, nameDatasets });
        }

        [HttpGet("query5")]
        public async Task<IActionResult> GetQuery5()
        {
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var resData = await ((IOrderRepository)_repositoryFactory.GetRepository<Order>(true)).GetCountFinishedOrderAndClientsStatistic();

            foreach (var item in resData)
            {
                resQueryData.Add(new StatisticQueryDataItemOutDTO() { Y = new List<double>() { item.Item2, item.Item3 }, X = item.Item1 });
            }

            return Ok(resQueryData);
        }

        [HttpGet("query6")]
        public async Task<IActionResult> GetQuery6()
        {
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var resData = await ((IOrderRepository)_repositoryFactory.GetRepository<Order>(true)).GetNodesAsync(limitCount:100);

            for (int i = 0, j = 1; i < OrderState.OrderStatesFromDb.Count; i++, j *= 2)
            {
                if (j == (int)OrderStateEnum.Cancelled || j == (int)OrderStateEnum.Finished)
                {
                    break;
                }
                var curState = OrderState.OrderStatesFromDb.First(h => h.NumberOfStage == j);

                var orderMinutesBetweenCurStateAndNext = new List<int>();
                var needRemoveOrders = new List<Order>();
                foreach (var order in resData)
                {
                    //количество состояний в истории должно быть на одну больше чем нужно, чтобы было ОТ и ДО
                    if(order.Story.Count > i + 1)
                    {
                        orderMinutesBetweenCurStateAndNext.Add((order.Story[i+1].TimeStartState - order.Story[i].TimeStartState).Minutes);
                    }
                    else
                    {
                        //удаляем потому что нам известно, что эти заказы закончились на текущей стадии
                        needRemoveOrders.Add(order);
                    }
                }

                resData = resData.Except(needRemoveOrders).ToList();

                resQueryData.Add(new StatisticQueryDataItemOutDTO() { Y = new List<double>() { orderMinutesBetweenCurStateAndNext.Sum()/ orderMinutesBetweenCurStateAndNext.Count }, X = curState.NameOfState });
            }

            return Ok(resQueryData);
        }

        [HttpGet("query7")]
        public async Task<IActionResult> GetQuery7()
        {
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var resData = await ((IOrderRepository)_repositoryFactory.GetRepository<Order>(true)).GetCountOrdersAndOrderedDishesForEveryKitchenStatistic();

            foreach (var item in resData)
            {
                resQueryData.Add(new StatisticQueryDataItemOutDTO() { Y = new List<double>() { item.Item2, item.Item3 }, X = item.Item1.Address });
            }

            return Ok(resQueryData);
        }

        [HttpGet("query8")]
        public async Task<IActionResult> GetQuery8()
        {
            var resQueryData = new List<StatisticQueryDataItemOutDTO>();

            var dishRepo = (IDishRepository)_repositoryFactory.GetRepository<Dish>(true);

            var topDish = await dishRepo.GetTopDishByCountOrderedStatistic(10);
            topDish.Reverse();

            foreach (var item in topDish)
            {
                resQueryData.Add(new StatisticQueryDataItemOutDTO() { Y = new List<double>() { item.Item2 }, X = item.Item1.Name });
            }

            return Ok(resQueryData);
        }
    }
}

JwtService.cs
using AutoMapper.Configuration.Annotations;
using DbManager.Data.DTOs;
using DbManager.Neo4j.Interfaces;
using Microsoft.IdentityModel.Tokens;
using Newtonsoft.Json.Linq;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using WepPartDeliveryProject;

public class JwtService
{
    private readonly ApplicationSettings _appSettings;

    public JwtService(IConfiguration configuration)
    {
        // Fetch settings object from configuration
        _appSettings = new ApplicationSettings();
        configuration.GetSection("ApplicationSettings").Bind(_appSettings);
    }

    public JwtTokenInfoOutDTO GenerateAccessJwtToken(string userId, List<string> roles)
    {
        var secretKey = Encoding.ASCII.GetBytes(_appSettings.JwtSecretKey);

        var tokenHandler = new JwtSecurityTokenHandler();
        var tokenDescriptor = new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new Claim[]
            {
                new Claim(ClaimTypes.Sid, userId),
            }),
            Expires = DateTime.Now.AddMinutes(30), // Время истечения токена
            SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(secretKey), SecurityAlgorithms.HmacSha256Signature)
        };
        foreach (var role in roles)
        {
            tokenDescriptor.Subject.AddClaim(new Claim(ClaimTypes.Role, role));
        }

        var token = tokenHandler.CreateToken(tokenDescriptor);
        var tokenString = tokenHandler.WriteToken(token);

        return new JwtTokenInfoOutDTO { JwtToken = tokenString, ValidTo = token.ValidTo, RoleNames = roles };
    }

    public bool UserHasRole(string? jwtToken, string roleName)
    {
        if(jwtToken== null)
            return false;

        var clearJwtToken = jwtToken.Replace("Bearer ", "");
        var tokenHandler = new JwtSecurityTokenHandler();
        var token = tokenHandler.ReadJwtToken(clearJwtToken);

        var userRolesName = token.Claims.Where(h => h.Type == "role").ToList();

        if (userRolesName.Any(h=>h.Value == roleName))
        {
            return true;
        }

        return false;
    }
}

cart.tsx
import Head from 'next/head'
import { FC, useEffect, useState } from "react"
import ClientLayout from '@/components/structure/ClientLayout'
import { GetStaticProps } from 'next'
import DishCartCard from '@/components/cards/DishCartCard'
import { useCookies } from 'react-cookie'
import PlaceAnOrderModal from '@/components/models/PlaceAnOrderModal'
import { stringify } from 'querystring'

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories
        }
    }
}

const Cart: FC<{ categories: categoryItem[] }> = ({ categories }) => {
    const [dishes, setDishes] = useState<dishClientInfo[]>([]);
    const [cookies, setCookie, removeCookie] = useCookies(['cartDishes']);

    const [show, setShow] = useState(false);

    const handleShowModal = () =>{
        setShow(true);
    }

    const handleCloseModal = () =>{
        setShow(false);
    }

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/getCart`, {
                credentials: 'include',
            });
            if(resp.ok){
                const cartDishes = await resp.json() as dishClientInfo[];
                setDishes(cartDishes);
            }
            else{
                alert(await resp.text());
            }

        }
        fetchData();
    }, []);

    const handleDeleteItem = (dishId: string): void => {
        setDishes(prevState => prevState.filter(el => el.id != dishId));
    }

    const clearList = (): void => {
        setDishes([]);
        removeCookie('cartDishes');
    }

    const handlePlaceAnOrder = async (userAddress: string, userPhoneNumber: string, comment: string) => {

        const response = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/placeAnOrder`, {
            method: "POST",
            credentials: "include",
            headers: {
                'Content-Type': 'application/json;charset=utf-8',
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            },
            body: JSON.stringify({deliveryAddress: userAddress, phoneNumber: userPhoneNumber, comment})
        });

        if (response.ok) {
            clearList();
            setShow(false);
        }
        else {
            alert(await response.text());
        }
    }

    return (
        <ClientLayout categories={categories}>
            <main className='mb-2'>
                <div>
                    {dishes.map((dish, i) => <DishCartCard key={i} {...dish} DeleteCardFromList={handleDeleteItem} />)}
                </div>
                {dishes.length != 0 ?
                    (<div>
                        <button className='btn btn-primary w-100 mt-2' onClick={handleShowModal}>
                            Оформить заказ
                        </button>
                    </div>)
                    : (
                        <div className='d-flex justify-content-center mt-5'>
                            <h2>
                                Ваша корзина пуста
                            </h2>
                        </div>
                    )
                }
            </main>
            {show && <PlaceAnOrderModal show={show} closeModel={handleCloseModal} commitAction={handlePlaceAnOrder}/>}
        </ClientLayout>
    )
}

export default Cart;
index.tsx
import Head from 'next/head'
import { FC, useState } from "react"
import ClientLayout from '@/components/structure/ClientLayout'
import { GetStaticProps } from 'next'
import DishMainCard from '@/components/cards/DishMainCard'

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const data = await resp.json() as categoryItem[];

    const resp2 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getDishesForMainPage`);
    const dishListInfo = await resp2.json() as { dishes: dishClientInfo[], pageEnded: boolean };

    return {
        props: {
            categories: data,
            dishesProps: dishListInfo.dishes,
            pageEndedProps: dishListInfo.pageEnded,
        }
    }
}

type homePageProps = {
    categories: categoryItem[],
    dishesProps: dishClientInfo[],
    pageEndedProps: boolean,
}

const Home: FC<homePageProps> = ({ categories, dishesProps, pageEndedProps }) => {
    const [dishesState, setDishesState] = useState<dishClientInfo[]>(dishesProps);
    //нулевая страница загружается при переходе на страницу
    const [page, setPage] = useState(1);
    const [pageEnded, setPageEnded] = useState(pageEndedProps);

    const handleShowMoreDishes = async () => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getDishesForMainPage?page=${page}`);

        if (resp.ok) {
            const loadedData = await resp.json() as { dishes: dishClientInfo[], pageEnded: boolean };
            setPage(page + 1);
            setDishesState(dishesState.concat(loadedData.dishes));
            setPageEnded(loadedData.pageEnded);
        }
        else {
            setPageEnded(true);
            alert(await resp.text());
        }
    }

    return (
        <ClientLayout categories={categories}>
            <Head>
                <title>Create Next App</title>
                <meta name="viewport" content="width=device-width, initial-scale=1" />
                <link rel="icon" href="/favicon.ico" />
            </Head>
            <main>
                <div>
                    {dishesState.map((dish, i) => <DishMainCard key={i} {...dish} />)}
                </div>
                {!pageEnded && (<div>
                    <button className='btn btn-primary w-100 mt-2' onClick={handleShowMoreDishes}>
                        Показать больше
                    </button>
                </div>)
                }
            </main>
        </ClientLayout>
    )
}

export default Home;
login.tsx
import { ChangeEvent, Component, FormEvent } from "react"
import Link from 'next/link'
import { Col, Form, Row, Container, Button } from "react-bootstrap";
import { NextRouter, withRouter } from "next/router";
import { AuthContext } from "@/components/contexts/AuthContext";

type LoginState = {
    login: string,
    password: string,
    success: boolean,
    errors: string[],
}

type WithRouterProps = {
    router: NextRouter
  }

class Login extends Component<WithRouterProps, LoginState> {
    declare context: React.ContextType<typeof AuthContext>
    static contextType = AuthContext; 

    state = {
        login: '',
        password: '',
        success: false,
        errors: [],
    }

    handleInputLogin = (e:ChangeEvent<HTMLInputElement>):void => {
        const inputText = e.target.value;
        this.setState({login:inputText});
    }

    handleInputPassword = (e:ChangeEvent<HTMLInputElement>):void => {
        const inputText = e.target.value;
        this.setState({password:inputText});
    }

    handleSubmit = async (e:FormEvent) => {
        e.preventDefault();

        const response = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/auth/login`, {
            method: "POST",
            credentials: "include",
            headers: {
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({login:this.state.login, password:this.state.password})
        });

        if(response.ok){
            this.context.toggleIsAuthed();
            this.props.router.push('/');
        }
        else{
            alert(await response.text());
        }
    }

    render() {
        return (
            <Container fluid={'xl'} className='mt-5 mb-5'>
                <h1>Войти</h1>
                <Form onSubmit={this.handleSubmit}>
                    <h3>Используйте данные от аккаунта dot Food для входа</h3>
                    <div className="text-danger"></div>
                    {/* {this.state.errors.map((error, i) => <p key={i}>{error}</p>)} */}
                    <Row>
                        <Col sm={10} md={6} lg={4}>
                            <Form.Group className={`mb-2`}>
                                <Form.Label>Email</Form.Label>
                                <Form.Control type="email" placeholder="Введите логин" value={this.state.login} onChange={this.handleInputLogin}/>
                                <span className="text-danger"></span>
                            </Form.Group>
                            <Form.Group className={`mb-3`}>
                                <Form.Label>Пароль</Form.Label>
                                <Form.Control type="password" placeholder="Введите пароль" value={this.state.password} onChange={this.handleInputPassword}/>
                                <span className="text-danger"></span>
                            </Form.Group>
                            <Row>
                                <Col xs={6} className="g-0 pe-1 ps-2">
                                    <Button variant="primary" type="submit" className="w-100">
                                        Войти
                                    </Button>
                                </Col>
                                <Col xs={6} className="g-0 ps-1 pe-2">
                                    <Link href={'/signup'} className="w-100">
                                        <Button variant="primary" className="w-100">
                                            Регистрация
                                        </Button>
                                    </Link>
                                </Col>
                            </Row>
                        </Col>
                    </Row>
                </Form>
            </Container>)
    }
};

export default withRouter(Login);
search.tsx
import Head from 'next/head'
import { FC, useEffect, useState } from "react"
import ClientLayout from '@/components/structure/ClientLayout'
import { GetStaticProps } from 'next'
import DishMainCard from '@/components/cards/DishMainCard'
import { useRouter } from 'next/router'

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories
        }
    }
}

const Search: FC<{ categories: categoryItem[] }> = ({ categories }) => {
    const [dishes, setDishes] = useState<dishClientInfo[]>([]);
    //нулевая страница загружается при переходе на страницу
    const [page, setPage] = useState(1);
    const [pageEnded, setPageEnded] = useState(false);

    const router = useRouter();
    const searchTextFromParam = router.query.searchText;

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getSearchedDishes?searchText=${searchTextFromParam}`);
            if (resp.ok) {
                const loadedData = await resp.json() as { dishes: dishClientInfo[], pageEnded: boolean };

                setDishes(loadedData.dishes);

                setPageEnded(loadedData.pageEnded);
            }
            else {
                alert(await resp.text());
            }
        }
        fetchData();
    }, [searchTextFromParam])

    const handleShowMoreDishes = async () => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getSearchedDishes?searchText=${searchTextFromParam}&page=${page}`);

        if (resp.ok) {
            const loadedData = await resp.json() as { dishes: dishClientInfo[], pageEnded: boolean };
            setPage(page + 1);
            setDishes(dishes.concat(loadedData.dishes));
            setPageEnded(loadedData.pageEnded);
        }
        else {
            setPageEnded(true);
            alert(await resp.text());
        }
    }

    return (
        <ClientLayout categories={categories}>
            <Head>
                <title>Create Next App</title>
                <meta name="viewport" content="width=device-width, initial-scale=1" />
                <link rel="icon" href="/favicon.ico" />
            </Head>
            <main className='mb-2'>
                <div>
                    {dishes.map((dish, i) => <DishMainCard key={i} {...dish} />)}
                </div>
                {dishes.length != 0 ?
                    (!pageEnded && (<div>
                        <button className='btn btn-primary w-100 mt-2' onClick={handleShowMoreDishes}>
                            Показать больше
                        </button>
                    </div>))
                    : (
                        <div className='d-flex justify-content-center mt-5'>
                            <h2>
                                В результате поиска не нашлось ни одного подходящего блюда
                            </h2>
                        </div>
                    )
                }
            </main>
        </ClientLayout>
    )
}

export default Search;
signup.tsx
import { ChangeEvent, Component, FormEvent } from "react"
import Link from 'next/link'
import { Col, Form, Row, Container, Button } from "react-bootstrap";
import { NextRouter, withRouter } from "next/router";
import { AuthContext } from "@/components/contexts/AuthContext";

type SignupState = {
    login: string,
    password: string,
    name: string,
    born: string,
    address: string,
    phoneNumber: string,
    secondPassword: string,
    success: boolean,
    errors: string[],
}

type WithRouterProps = {
    router: NextRouter,
}

function isValidDate(dateString:string) : boolean {
    const date:number = Date.parse(dateString);
    return !isNaN(date);
}

class Signup extends Component<WithRouterProps, SignupState> {
    declare context: React.ContextType<typeof AuthContext>
    static contextType = AuthContext; 

    state = {
        login: '',
        password: '',
        name: '',
        born: '',
        address: '',
        phoneNumber: '',
        secondPassword: '',
        success: false,
        errors: [],
    }

    handleInputData = (e: ChangeEvent<HTMLInputElement>): void => {
        const value:string = e.target.value;
        const name:string = e.target.name;
        
        this.setState(prevState => ({ ...prevState, [name]: value }));
    }

    handleSubmit = async (e:FormEvent) => {
        if(this.state.password == "" || this.state.login == "" || this.state.name == ""|| this.state.born == "" ){
            alert("Вы не заполнили все обязательные поля. Пожалуйста, заполните поля, отмеченные звездочкой")
            return;
        }
        if(this.state.password != this.state.secondPassword){
            alert("Вы ввели два разных пароля, пожалуйста, проверьте введенные пароли")
            return;
        }
        if(!isValidDate(this.state.born)){
            alert("Вы ввели не верную дату рождения, пожалуйста, проверьте введенные данные")
            return;
        }

        e.preventDefault();
        const response = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/auth/signup`, {
            method: "POST",
            credentials: "include",
            body: JSON.stringify({login:this.state.login, 
                                password:this.state.password, 
                                name: this.state.name,
                                phoneNumber: this.state.phoneNumber, 
                                address: this.state.address, 
                                born: this.state.born })
        });

        if(response.ok){
            this.context.toggleIsAuthed();
            this.props.router.push('/');
        }
        else{
            alert(await response.text());
        }
    }

    render() {
        return (
            <Container fluid={'xl'} className='mt-5 mb-5'>
                <h1>Регистрация</h1>
                <Form onSubmit={this.handleSubmit}>
                    <h3>Введите данные для аккаунта dot Food</h3>
                    <div className="text-danger">
                        {/* {this.state.errors.map((error, i) => <p key={i}>{error}</p>)} */}
                    </div>
                    <Row>
                        <Col sm={10} md={6} lg={4}>
                            <Form.Group className={`mb-2`}>
                                <Form.Label>Ваше имя<div className="text-danger d-inline">*</div></Form.Label>
                                <Form.Control type="text" placeholder="Введите свое имя" name="name" value={this.state.name} onChange={this.handleInputData}/>
                            </Form.Group>
                            <Form.Group className={`mb-2`}>
                                <Form.Label>Дата рождения<div className="text-danger d-inline">*</div></Form.Label>
                                <Form.Control type="text" placeholder="Введите свою дату рождения" name="born" value={this.state.born} onChange={this.handleInputData}/>
                            </Form.Group>
                            <Form.Group className={`mb-2`}>
                                <Form.Label>Ваш адрес</Form.Label>
                                <Form.Control type="text" placeholder="Введите свой адрес" name="address" value={this.state.address} onChange={this.handleInputData}/>
                            </Form.Group>
                            <Form.Group className={`mb-2`}>
                                <Form.Label>Ваш номер телефона</Form.Label>
                                <Form.Control type="tel" placeholder="+7" maxLength={12} name="phoneNumber" value={this.state.phoneNumber} onChange={this.handleInputData}/>
                            </Form.Group>
                            <Form.Group className={`mb-2`}>
                                <Form.Label>Email<div className="text-danger d-inline">*</div></Form.Label>
                                <Form.Control type="email" placeholder="Введите логин" name="login" value={this.state.login} onChange={this.handleInputData}/>
                            </Form.Group>
                            <Form.Group className={`mb-3`}>
                                <Form.Label>Пароль<div className="text-danger d-inline">*</div></Form.Label>
                                <Form.Control type="password" placeholder="Введите пароль" name="password" value={this.state.password} onChange={this.handleInputData}/>
                            </Form.Group>
                            <Form.Group className={`mb-3`}>
                                <Form.Label>Введите пароль еще раз<div className="text-danger d-inline">*</div></Form.Label>
                                <Form.Control type="password" placeholder="Введите пароль" name="secondePassword" value={this.state.password} onChange={this.handleInputData}/>
                            </Form.Group>
                            <Row>
                                <Col xs={6} className="g-0 pe-1 ps-2">
                                    <Button variant="primary" type="submit" className="w-100">
                                        Зарегестрироваться
                                    </Button>
                                </Col>
                                <Col xs={6} className="g-0 ps-1 pe-2">
                                    <Link href={'/login'} className="w-100">
                                        <Button variant="primary" className="w-100">
                                            Войти
                                        </Button>
                                    </Link>
                                </Col>
                            </Row>
                        </Col>
                    </Row>
                </Form>
            </Container>)
    }
};

export default withRouter(Signup);
_app.tsx
import '@/styles/globals.css'
import type { AppProps } from 'next/app'
import 'bootstrap/dist/css/bootstrap.min.css';
import { SSRProvider } from 'react-bootstrap';
import { CookiesProvider } from 'react-cookie';
import Layout from '@/components/structure/Layout';

const App = ({ Component, pageProps }: AppProps) => {

  return (
    <SSRProvider>
        <Layout>
          <CookiesProvider>
            <Component {...pageProps} />
          </CookiesProvider>
        </Layout>
    </SSRProvider>
    )
}

export default App;
_document.tsx
import { Html, Head, Main, NextScript } from 'next/document'

export default function Document() {
  return (
    <Html lang="en">
      <Head>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="" />
        <link href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;700&family=Work+Sans:wght@400;700&display=swap" rel="stylesheet"/>
      </Head>
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  )
}

changeDish.tsx
import { ChangeEvent, FC, useState, FormEvent, useEffect } from "react"
import ClientLayout from '@/components/structure/ClientLayout'
import { GetStaticProps } from 'next'
import { Row, Col, Form, InputGroup, Button, DropdownButton, Dropdown } from 'react-bootstrap'
import { useRouter } from "next/router"

export const getStaticProps: GetStaticProps = async () => {
    const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categoryList = await resp1.json() as categoryItem[];

    return {
        props: {
            categories: categoryList,
        }
    }
}

const ChangeDish: FC<{ categories: categoryItem[], }> = ({ categories }) => {
    const router = useRouter();
    const dishId = router.query["dishId"];
    const [dish, setDish] = useState<dishAdminInfo>({ id: "", description: "", images: [], isAvailableForUser: true, isDeleted: false, name: "", price: 0, weight: 0 });
    const [selectedCategory, setSelectedCategory] = useState<categoryItem | undefined>();
    const [loadedFilesName, setLoadedFilesName] = useState<string[]>([]);
    const [loadedFiles, setLoadedFiles] = useState<FileList | null>(null);

    useEffect(() => {
        if(dishId == undefined || dishId == null)
            return;
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/getDish/${dishId}`, {
                credentials: 'include',
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                }, 
            });
            
            if(resp.ok){
                const dishInfo = await resp.json() as {dish: dishAdminInfo, category: categoryItem};
                setDish(dishInfo.dish);
                setSelectedCategory(dishInfo.category);
            }
            else{
                alert(await resp.text());
            }
        }
        fetchData();
    }, [dishId, router]);

    const handleInputData = (e: ChangeEvent<HTMLInputElement>): void => {
        const value:string|boolean = e.target.type === 'checkbox' ? e.target.checked : e.target.value;
        const name:string = e.target.name;
        
        setDish(prevDish => ({ ...prevDish, [name]: value }));
    }

    const handleLoadFiles = (e: ChangeEvent<HTMLInputElement>): void => {
        const value:string[] = [];

        for(let i = 0; i < (e.target.files?.length ?? 0); i++){
            if(e.target.files != null)
                value.push(e.target.files[i].name);
        }

        const name:string = e.target.name;

        setLoadedFiles(e.target.files);
        setLoadedFilesName(value);
    }

    const handleSelectCategory = (eventKey:string|null): void => {
        setSelectedCategory(categories.find(el=>el.id == eventKey));
    }

    const handleSubmitForm = async (e:FormEvent) => {
        e.preventDefault();

        const formData:FormData = new FormData();
        const body:any = {...dish, categoryId: selectedCategory?.id};

        if(loadedFiles != null){
            for(let i = 0; i < loadedFiles.length; i++){
                formData.append('imagesFiles', loadedFiles[i]);
            }
        };

        for(let key in body){
            formData.append(key, body[key]);
        }

        const response = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/changeDish`, {
            method: "PATCH",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            },
            body: formData,
        });

        if(response.ok){
            router.push("/dishes/"+ await response.json());
        }
        else{
            alert(await response.text());
        }
    }

    return (
        <ClientLayout categories={categories}>
            <h3 className="text-center mb-5 mt-2">Изменение блюда</h3>
            <Form onSubmit={handleSubmitForm} >
                <Row className="mx-2">
                    <Col xs={12} lg={5}>
                        <div className="text-danger">Если вы загрузите изображения, то предыдущие будут удалены</div>
                        <InputGroup className="mb-3">
                            <Form.Control type="file" multiple name="images" onChange={handleLoadFiles}/>
                        </InputGroup>
                        {loadedFilesName.length != 0 && <div>Выбранные файлы: </div>}
                        {loadedFilesName.map((value, i)=> <InputGroup.Text className="mt-1" key={i}>{value}</InputGroup.Text>)}
                    </Col>
                    <Col xs={12} lg={7} className="mt-3 mt-lg-0">
                        <Row>
                            <Col md={12} className="mb-3 flex-grow-1 w-100">
                                <InputGroup >
                                    <InputGroup.Text className="">Название блюда</InputGroup.Text>
                                    <Form.Control type="text" name="name" value={dish.name} onChange={handleInputData} />
                                </InputGroup>
                            </Col>
                            <Col md={4} className="mb-3 pe-0">
                                <InputGroup>
                                    <DropdownButton variant="outline-secondary" title={selectedCategory == undefined ? "Категория" : selectedCategory.name} onSelect={handleSelectCategory}>
                                        {categories.map((value,i) => <Dropdown.Item eventKey={value.id} key={i}>{value.name}</Dropdown.Item>)}
                                    </DropdownButton>
                                </InputGroup>
                            </Col>
                            <Col md={4} className="mb-3 pe-0">
                                <InputGroup>
                                    <Form.Control className="ms-1" type="text" name="weight" value={dish.weight} onChange={handleInputData} />
                                    <InputGroup.Text className="">Грамм</InputGroup.Text>
                                </InputGroup>
                            </Col>
                            <Col md={4} className="mb-3">
                                <InputGroup >
                                    <Form.Control type="text" name="price" value={dish.price} onChange={handleInputData} />
                                    <InputGroup.Text className="">Р</InputGroup.Text>
                                </InputGroup>
                            </Col>
                            <InputGroup className="mb-3">
                                <InputGroup.Text className="">Описание блюда:</InputGroup.Text>
                                <Form.Control as="textarea" type="textarea" name="description" value={dish.description} onChange={handleInputData} />
                            </InputGroup>
                            <Col md={6} className="pe-0">
                                <Form.Switch label="Отметить как удаленное?" name="isDeleted" checked={dish.isDeleted} onChange={handleInputData} />
                            </Col>
                            <Col md={6}>
                                <Form.Switch label="Доступно пользователю?" name="isAvailableForUser" checked={dish.isAvailableForUser} onChange={handleInputData} />
                            </Col>
                        </Row>
                    </Col>
                </Row>
                <Row className="m-2 d-flex justify-content-end">
                    <Col xs={12} md={4}>
                        <Button type="submit" className="w-100">Изменить блюдо</Button>
                    </Col>

                </Row>

            </Form>
        </ClientLayout>
    )
}

export default ChangeDish;
createDish.tsx
import { ChangeEvent, MouseEvent, FC, useState, FormEvent } from "react"
import ClientLayout from '@/components/structure/ClientLayout'
import { GetStaticProps } from 'next'
import { Carousel, Row, Image, Col, Card, Form, InputGroup, Button, DropdownButton, Dropdown } from 'react-bootstrap'
import styles from '@/styles/Home.module.css'
import CounterMainDish from "@/components/cards/components/CounterMainDish"
import { useRouter } from "next/router"

export const getStaticProps: GetStaticProps = async () => {
    const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categoryList = await resp1.json() as categoryItem[];

    return {
        props: {
            categories: categoryList,
        }
    }
}

const CreateDish: FC<{ categories: categoryItem[], }> = ({ categories }) => {
    const router = useRouter();
    const [dish, setDish] = useState<dishAdminInfo>({ id: "", description: "", images: [], isAvailableForUser: true, isDeleted: false, name: "", price: 0, weight: 0 });
    const [selectedCategory, setSelectedCategory] = useState<categoryItem | undefined>();
    const [loadedFilesName, setLoadedFilesName] = useState<string[]>([]);
    const [loadedFiles, setLoadedFiles] = useState<FileList | null>(null);

    const handleInputData = (e: ChangeEvent<HTMLInputElement>): void => {
        const value:string|boolean = e.target.type === 'checkbox' ? e.target.checked : e.target.value;
        const name:string = e.target.name;
        
        setDish(prevDish => ({ ...prevDish, [name]: value }));
    }

    const handleLoadFiles = (e: ChangeEvent<HTMLInputElement>): void => {
        const value:string[] = [];

        for(let i = 0; i < (e.target.files?.length ?? 0); i++){
            if(e.target.files != null)
                value.push(e.target.files[i].name);
        }

        const name:string = e.target.name;

        setLoadedFiles(e.target.files);
        setLoadedFilesName(value);
    }

    const handleSelectCategory = (eventKey:string|null): void => {
        setSelectedCategory(categories.find(el=>el.id == eventKey));
    }

    const handleSubmitForm = async (e:FormEvent) => {
        e.preventDefault();

        const formData:FormData = new FormData();
        const body:any = {...dish, categoryId: selectedCategory?.id};

        if(loadedFiles != null){
            for(let i = 0; i < loadedFiles.length; i++){
                formData.append('imagesFiles', loadedFiles[i]);
            }
        };

        for(let key in body){
            formData.append(key, body[key]);
        }

        const response = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/createDish`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            },
            body: formData,
        });

        if(response.ok){
            router.push("/dishes/"+ await response.json());
        }
        else{
            alert(await response.text());
        }
    }

    return (
        <ClientLayout categories={categories}>
            <h3 className="text-center mb-5 mt-2">Создание блюда</h3>
            <Form onSubmit={handleSubmitForm} >
                <Row className="mx-2">
                    <Col xs={12} lg={5}>
                        <InputGroup className="mb-3">
                            <Form.Control type="file" multiple name="images" onChange={handleLoadFiles}/>
                            {/* <Button>Загрузить</Button> */}
                        </InputGroup>
                        {loadedFilesName.length != 0 && <div>Выбранные файлы: </div>}
                        {loadedFilesName.map((value, i)=> <InputGroup.Text className="mt-1" key={i}>{value}</InputGroup.Text>)}
                    </Col>
                    <Col xs={12} lg={7} className="mt-3 mt-lg-0">
                        <Row>
                            <Col md={12} className="mb-3 flex-grow-1 w-100">
                                <InputGroup >
                                    <InputGroup.Text className="">Название блюда</InputGroup.Text>
                                    <Form.Control type="text" name="name" value={dish.name} onChange={handleInputData} />
                                </InputGroup>
                            </Col>
                            <Col md={4} className="mb-3 pe-0">
                                <InputGroup>
                                    <DropdownButton variant="outline-secondary" title={selectedCategory == undefined ? "Категория" : selectedCategory.name} onSelect={handleSelectCategory}>
                                        {categories.map((value,i) => <Dropdown.Item eventKey={value.id} key={i}>{value.name}</Dropdown.Item>)}
                                    </DropdownButton>
                                </InputGroup>
                            </Col>
                            <Col md={4} className="mb-3 pe-0">
                                <InputGroup>
                                    <Form.Control className="ms-1" type="text" name="weight" value={dish.weight} onChange={handleInputData} />
                                    <InputGroup.Text className="">Грамм</InputGroup.Text>
                                </InputGroup>
                            </Col>
                            <Col md={4} className="mb-3">
                                <InputGroup >
                                    <Form.Control type="text" name="price" value={dish.price} onChange={handleInputData} />
                                    <InputGroup.Text className="">Р</InputGroup.Text>
                                </InputGroup>
                            </Col>
                            <InputGroup className="mb-3">
                                <InputGroup.Text className="">Описание блюда:</InputGroup.Text>
                                <Form.Control as="textarea" type="textarea" name="description" value={dish.description} onChange={handleInputData} />
                            </InputGroup>
                            <Col md={6} className="pe-0">
                                <Form.Switch label="Отметить как удаленное?" name="isDeleted" checked={dish.isDeleted} onChange={handleInputData} />
                            </Col>
                            <Col md={6}>
                                <Form.Switch label="Доступно пользователю?" name="isAvailableForUser" checked={dish.isAvailableForUser} onChange={handleInputData} />
                            </Col>
                        </Row>
                    </Col>
                </Row>
                <Row className="m-2 d-flex justify-content-end">
                    <Col xs={12} md={4}>
                        <Button type="submit" className="w-100">Создать блюдо</Button>
                    </Col>

                </Row>

            </Form>
        </ClientLayout>
    )
}

export default CreateDish;
dishes.tsx
import DishAdminCard from "@/components/cards/DishAdminCard";
import UserCard from "@/components/cards/UserCard";
import PanelToHandleDishes from "@/components/PanelToHandleDishes";
import PanelToHandleUsers from "@/components/PanelToHandleUsers";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { FC, useEffect, useState } from "react";
import { Button } from "react-bootstrap";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories,
        }
    }
}

const Dishes: FC<{categories:categoryItem[]}> = ({ categories}) => {
    const [dishes, setDishes] = useState<dishAdminInfo[]>([]);

    //нулевая страница загружается при переходе на страницу
    const [page, setPage] = useState(0);
    const [pageEnded, setPageEnded] = useState(true);

    const [searchText, setSearchText] = useState<string>("");
    
    const handleChangeSearchedText = (searchedText:string) => {
        setSearchText(searchedText);
        setPage(0);
        setDishes([]);
    }

    const handleShowMoreDishes = async () => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/getDishes?${searchText != "" ? "searchText=" + searchText + "&" : ""}page=${page}`, {
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            }
        });
    
        if(resp.ok){
            const loadedData = await resp.json() as {dishes: dishAdminInfo[], pageEnded: boolean};

            setPage(page + 1);
            setDishes(dishes.concat(loadedData.dishes));
            setPageEnded(loadedData.pageEnded);
        }
        else{
            setPageEnded(true);
            alert(await resp.text());
        }
    }

    const handleChangeDeleteStatusOfDish = async (dishId:string) => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/changeDeleteStatusOfDish`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({id: dishId})
        });
        if(resp1.ok){
            const respData = await resp1.json() as boolean;

            setDishes(prevDishes => {
                const changedDish:dishAdminInfo | undefined = prevDishes.find(el => el.id == dishId );
                if(changedDish != undefined)
                    changedDish.isDeleted = respData;

                return prevDishes.slice();
            });
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleChangeVisibleStatusOfDish = async (dishId:string) => {
        console.log(dishId);
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/changeVisibleStatusOfDish`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({id: dishId})
        });
        if(resp1.ok){
            const respData = await resp1.json() as boolean;

            setDishes(prevDishes => {
                const changedDish:dishAdminInfo | undefined = prevDishes.find(el => el.id == dishId );
                if(changedDish != undefined)
                    changedDish.isAvailableForUser = respData;

                return prevDishes.slice();
            });
        }
        else{
            alert(await resp1.text());
        }
    }

    useEffect(()=>{
        if(page == 0){
            handleShowMoreDishes();
        }
    },[page, searchText]);

    return (
        <ClientLayout categories={categories}>
            <PanelToHandleDishes changeSearchedText={handleChangeSearchedText}/>
            {dishes.map((dish, i)=> <DishAdminCard key={i} {...dish} changeDeletedState={handleChangeDeleteStatusOfDish} changeVisibleState={handleChangeVisibleStatusOfDish}/>)}
            {!pageEnded && (
                <div>
                    <Button className='btn btn-primary w-100 mt-2' onClick={handleShowMoreDishes}>
                        Показать больше
                    </Button>
                </div>)
            }
        </ClientLayout>
    );
}

export default Dishes;
map.tsx
import { GetStaticProps } from "next";
import ClientLayout from "@/components/structure/ClientLayout";
import { FC, useState } from "react";
import CustomMap from "@/components/mapComponents/customMap";
import { fromLonLat } from "ol/proj";
import Layers from "@/components/mapComponents/mapLayers/Layers";
import TileLayer from "@/components/mapComponents/mapLayers/TitleLayer";
import * as olSource from "ol/source";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories,
        }
    }
}


const MapPage: FC<{ categories: categoryItem[]}> = ({ categories}) => {
    const [center, setCenter] = useState([48.003456, 37.802683]);
    const [zoom, setZoom] = useState(9);

    return (
        <ClientLayout categories={categories}>
            <CustomMap zoom={zoom} center={fromLonLat(center)}>
            <Layers>
                <TileLayer
                    source={new olSource.OSM()}
                    zIndex={0}
                />
            </Layers>
            </CustomMap>
        </ClientLayout>
    )
}



export default MapPage;
order.tsx
import DishOrderCard from "@/components/cards/DishOrderCard";
import OrderCard from "@/components/cards/OrderCard";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { useRouter } from "next/router";
import { FC, useEffect, useState } from "react";
import { Col, Row } from "react-bootstrap";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories
        }
    }
}

const Order: FC<{ categories: categoryItem[]}> = ({ categories }) => {
    const router = useRouter();
    const [orderInfo, setOrderInfo] = useState<orderInfo>({ order: {id:"", deliveryAddress: "", phoneNumber:'', price:0, sumWeight:0, DeleteOrder: ()=>{}, MoveOrderToNextStage: ()=>{}, MoveOrderToPreviousStage: ()=>{} }, orderedDishes: []});
    const orderId = router.query["orderId"];

    const handleDeleteOrder = async () => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/cancelOrder`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({ orderId })
        });

        if (resp1.ok) {
            router.push("/profile/orderStory");
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleDeleteItemDish = async (dishId: string) => {
        const dishWillDelete = orderInfo.orderedDishes.find(el => el.dishInfo.id == dishId)
        if (dishWillDelete != null) {
            setOrderInfo(prevOrderInfo => {
                prevOrderInfo.orderedDishes = prevOrderInfo.orderedDishes.filter(el => el.dishInfo.id != dishId);
                prevOrderInfo.order.price -= dishWillDelete.count*dishWillDelete.dishInfo.price;
                return { ...prevOrderInfo };
            });

            const response = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/cancelOrderedDish`, {
                method: "POST",
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                    'Content-Type': 'application/json;charset=utf-8',
                },
                body: JSON.stringify({ orderId, dishId })
            });

            if(!response.ok){
                alert(await response.text());
            }

            if (orderInfo.orderedDishes.length == 0) {
                await handleDeleteOrder();
            }
        }
    }

    useEffect(() => {
        if(orderId == undefined || orderId == null)
            return;
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/getOrder/${orderId}`, {
                credentials: 'include',
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                }, 
            });
            
            if(resp.ok){
                const orderInfo = await resp.json() as orderInfo;
                setOrderInfo(orderInfo);
            }
            else{
                alert(await resp.text())
            }
        }
        fetchData();
    }, [orderId, router]);

    return (
        <>
            <ClientLayout categories={categories}>
                <OrderCard {...orderInfo.order} DeleteOrder={handleDeleteOrder} canWriteReview={false}/>
                {orderInfo.order.clientRating != null && <h3>Оценка клиента: {orderInfo.order.clientRating}</h3>}
                {orderInfo.order.review != null && <h3>Отзыв клиента: {orderInfo.order.review}</h3>}
                <Row className="mt-3 ">
                    <Col >
                        <h3>Список блюд из заказа: </h3>
                    </Col>
                </Row>
                {orderInfo.orderedDishes.map((dish, i) => {
                    dish.dishInfo.DeleteCardFromList = handleDeleteItemDish
                    return (<DishOrderCard key={i} {...dish} orderId={orderInfo.order.id} />)
                })}
                
            </ClientLayout>
        </>
    );
}

export default Order;
orders.tsx
import PanelToHandleOrders from "@/components/PanelToHandleOrders";
import OrderCard from "@/components/cards/OrderCard";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { FC, useEffect, useState } from "react";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getOrderStates`);
    const states = await resp1.json() as orderState[];

    return {
        props: {
            categories,
            states,
        }
    }
}

const AdminOrders: FC<{categories:categoryItem[], states:orderState[]}> = ({ categories, states }) => {
    const [orders, setOrders] = useState<orderCardInfo[]>([]);
    const [page, setPage] = useState(0);
    const [pageEnded, setPageEnded] = useState(true);
    const [selectedState, setSelectedState] = useState<orderState>(states[0]);

    const handleMoveOrderToPreviousStage = async (orderId:string, orderStateId:string) => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/moveToPreviousStage`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({ orderId })
        });

        if (resp1.ok) {
            const changedOrderIndex = orders.findIndex(el => el.id == orderId);
            const updatedOrders = [...orders];
            const deletedStage = updatedOrders[changedOrderIndex].story?.pop();

            if(deletedStage?.orderStateId == orderStateId)
                setOrders(updatedOrders);
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleMoveOrderToNextStage = async (orderId:string, orderStateId:string) => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/moveToNextStage`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({ orderId })
        });

        if (resp1.ok) {
            const newOrderState = await resp1.json() as orderState;
            const changedOrderIndex = orders.findIndex(el => el.id == orderId);
            const updatedOrders = [...orders];
            updatedOrders[changedOrderIndex].story?.push(newOrderState);

            if (newOrderState.orderStateId != orderStateId)
                setOrders(updatedOrders);
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleShowMoreOrders = async  () => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/getOrders?page=${page}&numberOfState=${selectedState.numberOfStage}`, {
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            }
        });
    
        if(resp.ok){
            const loadedData = await resp.json() as {orders: orderCardInfo[], pageEnded: boolean};
            setPage(page + 1);
            setOrders(orders.concat(loadedData.orders));
            setPageEnded(loadedData.pageEnded);
        }
        else{
            setPageEnded(true);
            alert(await resp.text());
        }
    }

    const handleDeleteItem = async (orderId:string) => {
        setOrders(prevOrders => prevOrders.filter(el => el.id != orderId ));

        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/cancelOrder`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({orderId})
        });

        if(!resp1.ok){
            alert(await resp1.text());
        }
    }

    const handleSelectState = (selectState: orderState) => {
        setSelectedState(selectState);
        setOrders([]);
        setPage(0);
    }

    useEffect(()=>{
        if(page == 0){
            handleShowMoreOrders();
        }
    }, [page]);

    return (
        <ClientLayout categories={categories}>
            <PanelToHandleOrders orderStates={states} selectState={handleSelectState}/>
            {orders.map((order, i)=> <OrderCard key={i} {...order} DeleteOrder={handleDeleteItem} MoveOrderToPreviousStage={handleMoveOrderToPreviousStage} MoveOrderToNextStage={handleMoveOrderToNextStage}/>)}
            {!pageEnded && (<div>
                    <button className='btn btn-primary w-100 mt-2' onClick={handleShowMoreOrders}>
                        Показать больше
                    </button>
                </div>)
            }
        </ClientLayout>
    );
}

export default AdminOrders;
statistics.tsx
import PanelToHandleStatistics from "@/components/PanelToHandleStatistics";
import BarChart from "@/components/statisticsCharts/BarChart";
import LineChart from "@/components/statisticsCharts/LineChart";
import RadarChart from "@/components/statisticsCharts/RadarChart";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { FC, useEffect, useState } from "react";
import { Col, Row } from "react-bootstrap";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories,
        }
    }
}

const Statistics: FC<{ categories: categoryItem[] }> = ({ categories }) => {
    const [statisticQueries, setStatisticQueries] = useState<statisticQueryInfo[]>([]);
    const [selectedQuery, setSelectecQuery] = useState<statisticQueryInfo>();
    
    const handleGetQueryDataFromServer = async (query:statisticQueryInfo) => {
        setSelectecQuery(query);
    };

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/statistic/getStatisticQueries`, {
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                },
            });
            if(resp.ok){
                const resInfo = await resp.json() as statisticQueryInfo[];
                setStatisticQueries(resInfo);
            }
            else{
                alert(await resp.text());
            }

        }
        fetchData();
    }, []);

    const drawChart:any = {
        "line": <LineChart query={selectedQuery as statisticQueryInfo}/>,
        "bar": <BarChart query={selectedQuery as statisticQueryInfo}/>,
        "radar": <RadarChart query={selectedQuery as statisticQueryInfo}/>,
    }

    return (
        <ClientLayout categories={categories}>
            <PanelToHandleStatistics statisticQueries={statisticQueries} buildChart={handleGetQueryDataFromServer} />
            <Row className="d-flex justify-content-center mt-3 mb-3">
                <Col md={9}>
                    {selectedQuery != undefined && drawChart[selectedQuery.chartName]}
                </Col>
            </Row>
        </ClientLayout>
    );
}

export default Statistics;
users.tsx
import UserCard from "@/components/cards/UserCard";
import PanelToHandleUsers from "@/components/PanelToHandleUsers";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { FC, useEffect, useState } from "react";
import { Button } from "react-bootstrap";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories,
        }
    }
}

const Users: FC<{categories:categoryItem[]}> = ({ categories}) => {
    const [users, setUsers] = useState<profileInfo[]>([]);
    const [roles, setRoles] = useState<string[]>([]);

    const [markedUsers, setMarkedUsers] = useState<string[]>([]);

    //нулевая страница загружается при переходе на страницу
    const [page, setPage] = useState(0);
    const [pageEnded, setPageEnded] = useState(true);

    const [searchText, setSearchText] = useState<string>("");
    
    const handleChangeSearchedText = (searchedText:string) => {
        setSearchText(searchedText);
        setPage(0);
        setUsers([]);
    }

    const handleMarkUser = async (userId:string) => {
        setMarkedUsers(prevMarkedUsers => prevMarkedUsers.concat(userId));
    }

    const handleUnmarkUser = async (userId:string) => {
        setMarkedUsers(prevMarkedUsers => prevMarkedUsers.filter(h => h != userId));
    }

    const handleShowMoreUsers = async () => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/getUsers?${searchText != "" ? "searchText=" + searchText + "&" : ""}page=${page}`, {
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            }
        });
    
        if(resp.ok){
            const loadedData = await resp.json() as {users: profileInfo[], pageEnded: boolean};
            setPage(page + 1);
            setUsers(users.concat(loadedData.users));
            setPageEnded(loadedData.pageEnded);
        }
        else{
            setPageEnded(true);
            alert(await resp.text());
        }
    }

    const handleBlockUser = async () => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/blockUsers`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify(markedUsers.map<{userId: string}>((value) => { return {userId: value} }))
        });

        if(resp1.ok){
            setUsers(prevUsers => prevUsers.map((value)=> {
                if(markedUsers.includes(value.id as string))
                    value.isBlocked = true; 
                return value;
            }))
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleUnblockUser = async () => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/unblockUsers`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify(markedUsers.map<{userId: string}>((value) => { return {userId: value} }))
        });

        if(resp1.ok){
            setUsers(prevUsers => prevUsers.map((value)=> {
                if(markedUsers.includes(value.id as string))
                    value.isBlocked = false; 
                return value;
            }))
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleAddRoleTokUser = async (newRole:string) => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/addUserRole`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify(markedUsers.map<{userId: string}>((value) => { return {userId: value, changeRole: newRole} }))
        });

        if(resp1.ok){
            setUsers(prevUsers => prevUsers.map((value)=> {
                if(markedUsers.includes(value.id as string) && !value.roles?.includes(newRole)) {
                    value.roles += ", " + newRole;
                }
                return value;
            }))
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleRemoveRoleTokUser = async (oldRole:string) => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/removeUserRole`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify(markedUsers.map<{userId: string}>((value) => { return {userId: value, changeRole: oldRole} }))
        });

        if(resp1.ok){
            setUsers(prevUsers => prevUsers.map((value)=> {
                if(markedUsers.includes(value.id as string)  && value.roles?.includes(oldRole)){
                    value.roles = (value.roles as string).replaceAll(", " + oldRole, "");
                }
                return value;
            }))
        }
        else{
            alert(await resp1.text());
        }
    }

    useEffect(()=>{
        if(page == 0){
            handleShowMoreUsers();

            const fetchData = async () => {
                const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/admin/getRoles`, {
                    headers: {
                        'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                    }
                });
            
                if(resp.ok){
                    const loadedData = await resp.json() as string[];
                    setRoles(loadedData);
                }
                else{
                    alert(await resp.text());
                }
            }
            fetchData();
        }
    },[page, searchText]);

    return (
        <ClientLayout categories={categories}>
            <PanelToHandleUsers roles={roles} changeSearchedText={handleChangeSearchedText} blockUsers={handleBlockUser} unblockUsers={handleUnblockUser} addRole={handleAddRoleTokUser} removeRole={handleRemoveRoleTokUser}/>
            {users.map((user, i)=> <UserCard key={i} userInfo={user} markUser={handleMarkUser} unmarkUser={handleUnmarkUser}/>)}
            {!pageEnded && (
                <div>
                    <Button className='btn btn-primary w-100 mt-2' onClick={handleShowMoreUsers}>
                        Показать больше
                    </Button>
                </div>)
            }
        </ClientLayout>
    );
}

export default Users;
[category].tsx
import Head from 'next/head'
import { FC } from "react"
import ClientLayout from '@/components/structure/ClientLayout'
import { GetStaticPaths, GetStaticProps } from 'next'
import DishMainCard from '@/components/cards/DishMainCard'

export const getStaticPaths:GetStaticPaths = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];
    const paths = categories.map((value)=> ({params: {category: value.linkName}}))

  return {
    paths,
    fallback: false, // can also be true or 'blocking'
  }
}

export const getStaticProps:GetStaticProps = async (context) => {
    const category = context.params?.category;
    const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categoryList = await resp1.json() as categoryItem[];

    const resp2 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getDishesList/${category}`);
    const dishList = await resp2.json() as dishClientInfo[];

    return {
        props:{
            categories: categoryList,
            dishes: dishList,
        }
    }
}

type categoryPageProps = {
  categories:categoryItem[], 
  dishes: dishClientInfo[],
}

const Category: FC<categoryPageProps> = ({categories, dishes}) => {
  return (
    <ClientLayout categories={categories}>
      <Head>
        <title>Create Next App</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main>
        <div>
          {dishes.map((dish, i) => <DishMainCard key={i} {...dish}/>)}
        </div>
      </main>
    </ClientLayout>
  )
}

export default Category;
[id].tsx
import { FC, useEffect, useState } from "react"
import ClientLayout from '@/components/structure/ClientLayout'
import { GetStaticPaths, GetStaticProps } from 'next'
import { Carousel, Row, Image, Col } from 'react-bootstrap'
import Head from 'next/head'
import styles from '@/styles/Home.module.css'
import CounterMainDish from "@/components/cards/components/CounterMainDish"
import { useRouter } from "next/router"

export const getStaticPaths: GetStaticPaths = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getDishIds`);
    const dishIds = await resp.json() as string[];
    const paths = dishIds.map((value) => ({ params: { id: value } }))

    return {
        paths,
        fallback: false, // can also be true or 'blocking'
    }
}

export const getStaticProps: GetStaticProps = async (context) => {
    const id = context.params?.id;
    const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categoryList = await resp1.json() as categoryItem[];

    const resp2 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getDish/${id}`);
    const dish = await resp2.json() as dishClientInfo;

    return {
        props: {
            categories: categoryList,
            dish,
        }
    }
}

type dishPageProps = {
    categories: categoryItem[],
    dish: dishClientInfo,
}

const Dish: FC<dishPageProps> = ({ categories, dish }) => {
    const [index, setIndex] = useState(0);
    const router = useRouter();
    const [ability, setAbility] = useState(true);

    const handleSelect = (selectedIndex: number): void => {
        setIndex(selectedIndex);
    };

    useEffect(() => {
        const fetchData = async () => {
            const { id } = router.query;
            const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getDishAbilityInfo/${id}`);
            if (resp1.ok) {
                const abilityRes = await resp1.json() as boolean;
                setAbility(abilityRes);
            }
            else {
                alert(await resp1.text());
            }
        }
        fetchData();
    }, [router]);

    if (!ability)
        router.push("/")

    return (
        <ClientLayout categories={categories}>
            <main>
                <div>
                    <Row className="justify-content-center">
                        <Col xs={12} sm={10} md={8} lg={6}>
                            <Carousel activeIndex={index} onSelect={handleSelect}>
                                {dish.images?.map((value, i) =>
                                    <Carousel.Item key={i} >
                                        <Image className="d-block w-100" src={value} alt="No image" />
                                    </Carousel.Item>
                                )}
                            </Carousel>
                        </Col>
                    </Row>
                    <Row className="justify-content-center mb-3">
                        <Col xs={12} sm={11} md={10} lg={9}>
                            <div>
                                <div className="d-flex mb-3 mt-2">
                                    <h5 className="flex-grow-1">{dish.name}</h5>
                                    <h5 className=""><b>{dish.price}Р</b></h5>
                                </div>
                                <p className="text-justify">{dish.description}</p>
                            </div>
                            <CounterMainDish dishId={dish.id} />
                        </Col>
                    </Row>
                </div>
            </main>
        </ClientLayout>
    )
}

export default Dish;
orders.tsx
import PanelToHandleOrders from "@/components/PanelToHandleOrders";
import OrderCard from "@/components/cards/OrderCard";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { FC, useEffect, useState } from "react";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getOrderStates`);
    const states = await resp1.json() as orderState[];

    return {
        props: {
            categories,
            states,
        }
    }
}

const KitchenOrders: FC<{categories:categoryItem[], states:orderState[]}> = ({ categories, states }) => {
    const [orders, setOrders] = useState<orderCardInfo[]>([]);
    const [page, setPage] = useState(0);
    const [pageEnded, setPageEnded] = useState(true);
    const [selectedState, setSelectedState] = useState<orderState>(states[0]);

    const handleMoveOrderToPreviousStage = async (orderId:string, orderStateId:string) => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/moveToPreviousStage`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({ orderId })
        });

        if (resp1.ok) {
            setOrders(prevOrders => prevOrders.filter(el => el.id != orderId ));
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleMoveOrderToNextStage = async (orderId:string, orderStateId:string) => {
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/moveToNextStage`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({ orderId })
        });

        if (resp1.ok) {
            setOrders(prevOrders => prevOrders.filter(el => el.id != orderId ));
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleSelectState = (selectState: orderState) => {
        setSelectedState(selectState);
        setOrders([]);
        setPage(0);
    }

    const handleShowMoreOrders = async  () => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/kitchen/getOrders?page=${page}&numberOfState=${selectedState.numberOfStage}`, {
            credentials: "include",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            }
        });
    
        if(resp.ok){
            const loadedData = await resp.json() as {orders: orderCardInfo[], pageEnded: boolean};
            setPage(page + 1);
            setOrders(orders.concat(loadedData.orders));
            setPageEnded(loadedData.pageEnded);
        }
        else{
            setPageEnded(true);
            alert(await resp.text());
        }
    }

    useEffect(()=>{
        if(page == 0){
            handleShowMoreOrders();
        }
    }, [page]);

    return (
        <ClientLayout categories={categories}>
            <PanelToHandleOrders orderStates={states} selectState={handleSelectState}/>
            {orders.map((order, i)=> <OrderCard key={i} {...order} DeleteOrder={()=>{}} MoveOrderToPreviousStage={handleMoveOrderToPreviousStage} MoveOrderToNextStage={handleMoveOrderToNextStage}/>)}
            {!pageEnded && (<div>
                    <button className='btn btn-primary w-100 mt-2' onClick={handleShowMoreOrders}>
                        Показать больше
                    </button>
                </div>)
            }
        </ClientLayout>
    );
}

export default KitchenOrders;
workers.tsx
import WorkerCard from "@/components/cards/WorkerCard";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { FC, useEffect, useState } from "react";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories,
        }
    }
}

const Workers: FC<{categories:categoryItem[]}> = ({ categories}) => {
    const [workers, setWorkers] = useState<profileInfo[]>([]);

    useEffect(()=>{
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/kitchen/getWorkers`, {
                credentials: "include",
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                }
            });
        
            if(resp.ok){
                const loadedData = await resp.json() as profileInfo[];
                setWorkers(loadedData);
            }
            else{
                alert(await resp.text());
            }
        }
        fetchData();
    },[]);

    return (
        <ClientLayout categories={categories}>
            {workers.map((user, i)=> <WorkerCard key={i} userInfo={user}/>)}
        </ClientLayout>
    );
}

export default Workers;
index.tsx
import { AuthContext } from "@/components/contexts/AuthContext";
import Link from "next/link";
import { FC, useContext, useEffect, useState } from "react";
import { Card, Col, Container, Row } from "react-bootstrap";

const ProfileInfo: FC = () => {
    const [profile, setProfileInfo] = useState<profileInfo>({ id: null, login: "", name: "", isBlocked:null, bonuses: null, born: null, jobTitle: null, phoneNumber: null, roles: null, gotJob: null, address: null });
    const authContextData = useContext<authContextProps>(AuthContext);

    const orderStoryButtonVisibility:boolean = !(authContextData.isAdmin || authContextData.isKitchenWorker || authContextData.isDeliveryMan);

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getProfileInfo`, {
                credentials: 'include',
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                }, 
            });
            if(resp.ok){
                const profileInfo = await resp.json() as profileInfo;
                setProfileInfo(profileInfo);
            }
            else{
                alert(await resp.text());
            }
        }
        fetchData();
    }, []);

    return (
        <Container className="mt-5">
            <Row className="d-flex justify-content-center">
                <Col md={8}>
                    <Card className="p-3 py-4">
                        <div className="text-center">
                            <img src="https://i.imgur.com/bDLhJiP.jpg" width="100" className="rounded-circle" alt=""/>
                        </div>
                        <div className="text-center mt-3">
                            {/* <span className="bg-secondary p-1 px-4 rounded text-white">{profile.jobTitle}</span> */}
                            <h5 className="mt-2 mb-0">{profile.name}</h5>
                            <span>{profile.login}</span>
                            <div className="px-2 px-md-4 mt-1">
                                <p className="fonts">Consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. </p>
                            </div>
                            <div className="buttons">
                                {orderStoryButtonVisibility && <Link href="/profile/orderStory" className="btn btn-outline-primary px-4">История заказов</Link>}
                                <button className="btn btn-primary px-4 ms-3">Contacts</button>
                            </div>
                        </div>
                    </Card>
                </Col>
            </Row>
        </Container>
    );
}

export default ProfileInfo;
order.tsx
import DishOrderCard from "@/components/cards/DishOrderCard";
import OrderCard from "@/components/cards/OrderCard";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { useRouter } from "next/router";
import { FC, useEffect, useState } from "react";
import { Col, Row } from "react-bootstrap";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    return {
        props: {
            categories
        }
    }
}

const Order: FC<{ categories: categoryItem[]}> = ({ categories }) => {
    const router = useRouter();
    const [orderInfo, setOrderInfo] = useState<orderInfo>({ order: {id:"", deliveryAddress: "", price:0, sumWeight:0, phoneNumber: '', DeleteOrder: ()=>{}, MoveOrderToNextStage: ()=>{}, MoveOrderToPreviousStage: ()=>{} }, orderedDishes: []});
    const orderId = router.query["orderId"];

    useEffect(() => {
        if(orderId == undefined || orderId == null)
            return;
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/getOrder/${orderId}`, {
                credentials: 'include',
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                }, 
            });

            if(resp.ok){
                const orderInfo = await resp.json() as orderInfo;
                setOrderInfo(orderInfo);
            }
            else{
                router.push("/profile/orderStory");
                //alert(await resp.text());
            }
        }
        fetchData();
    }, [orderId, router]);

    return (
        <>
            <ClientLayout categories={categories}>
                <OrderCard {...orderInfo.order} canWriteReview={orderInfo.order.clientRating == null}/>
                {orderInfo.order.clientRating != null && <h3>Оценка клиента: {orderInfo.order.clientRating}</h3>}
                {orderInfo.order.review != null && <h3>Отзыв клиента: {orderInfo.order.review}</h3>}
                <Row className="mt-3 ">
                    <Col >
                        <h3>Список блюд из заказа: </h3>
                    </Col>
                </Row>
                {orderInfo.orderedDishes.map((dish, i) => {
                    return (<DishOrderCard key={i} {...dish} orderId={orderInfo.order.id} />)
                })}
                
            </ClientLayout>
        </>
    );
}

export default Order;
orderStory.tsx
import PanelToHandleOrders from "@/components/PanelToHandleOrders";
import OrderCard from "@/components/cards/OrderCard";
import CancelOrderModal from "@/components/models/CancelOrderModal";
import ClientLayout from "@/components/structure/ClientLayout";
import { GetStaticProps } from "next";
import { FC, useEffect, useState } from "react";

export const getStaticProps: GetStaticProps = async () => {
    const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getCategoriesList`);
    const categories = await resp.json() as categoryItem[];

    const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getOrderStates`);
    const states = await resp1.json() as orderState[];

    return {
        props: {
            categories,
            states,
        }
    }
}

const OrderStory: FC<{categories:categoryItem[], states:orderState[]}> = ({ categories, states }) => {
    const [orders, setOrders] = useState<orderCardInfo[]>([]);
    const [selectedState, setSelectedState] = useState<orderState>(states[0]);
    const [page, setPage] = useState(0);
    const [pageEnded, setPageEnded] = useState(true);

    const handleDeleteItem = async (orderId:string, reasonOfCancel:string) => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/cancelOrder`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({orderId, reasonOfCancel})
        });

        if(resp.ok){
            setOrders(prevOrders => prevOrders.filter(el => el.id != orderId ));
        }
        else{
            alert(await resp.text())
        }
    }

    const handleSelectState = (selectState: orderState) => {
        setSelectedState(selectState);
        setOrders([]);
        setPage(0);
    }

    const handleShowMoreOrders = async  () => {
        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/getClientOrders?page=${page}&numberOfState=${selectedState.numberOfStage}`, {
            credentials: "include",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            }
        });
    
        if(resp.ok){
            const loadedData = await resp.json() as {orders: orderCardInfo[], pageEnded: boolean};

            setPage(page + 1);
            setOrders(orders.concat(loadedData.orders));
            setPageEnded(loadedData.pageEnded);
        }
        else{
            setPageEnded(true);
            alert(await resp.text())
        }
    }

    useEffect(()=>{
        if(page == 0){
            handleShowMoreOrders();
        }
    }, [page, selectedState]);

    return (
        <ClientLayout categories={categories}>
            <PanelToHandleOrders orderStates={states} selectState={handleSelectState}/>
            {orders.map((order, i)=> <OrderCard key={i} {...order} DeleteOrder={handleDeleteItem} canWriteReview={false}/>)}
            {!pageEnded && (<div>
                    <button className='btn btn-primary w-100 mt-2' onClick={handleShowMoreOrders}>
                        Показать больше
                    </button>
                </div>)
            }
        </ClientLayout>
    );
}

export default OrderStory;
FooterPanelItem.tsx
import Link from "next/link";
import { FC } from "react"
import { Nav, Container, Navbar } from "react-bootstrap";

const FooterPanelItem : FC<footerPanelInfo> = (contentPanel:footerPanelInfo) =>{
    return (
        <Navbar bg="light" expand="md">
            <Container fluid="xl" className="g-0" >
                <Navbar.Toggle aria-controls="basic-navbar-nav" className="w-100">{contentPanel.panelName}</Navbar.Toggle>
                <Navbar.Collapse id="basic-navbar-nav">
                    <Nav className="me-auto flex-column w-100">
                        <Nav.Item className='w-100 d-none d-md-block text-center'>
                            <b>{contentPanel.panelName}</b>
                        </Nav.Item>

                        {contentPanel.panelItems.map((value, i) =>
                            (<Nav.Item className="w-100" key={i}>
                                <Link className="nav-link" href={value.itemHref}>
                                        {value.itemName}
                                </Link>
                            </Nav.Item>)
                        )}
                    </Nav>
                </Navbar.Collapse>
            </Container>
        </Navbar>
    );
}

export default FooterPanelItem;
PanelToHandleDishes.tsx
import Link from 'next/link';
import React, { ChangeEvent, FC, useState } from 'react';
import { Button, Col, Dropdown, Form, Image, Row } from 'react-bootstrap';

interface PanelToHandleUsersProps {
    changeSearchedText: (newSearchedText:string) => void, 
}

const PanelToHandleDishes: FC<PanelToHandleUsersProps> = ({ changeSearchedText }) => {
    const [searchValue, setSearchValue] = useState("");

    const changeSearchValue = (e: ChangeEvent<HTMLInputElement>): void => {
        e.preventDefault();
        setSearchValue(e.target.value);
    }

    const handleSearchClick = ():void =>{
        changeSearchedText(searchValue);
    }

    return (
        <>
            <Row className='pe-md-3'>
                <Col xs={12} md='auto' className='mt-2 flex-grow-1'>
                    <Form className="d-flex w-100">
                        <Form.Control className='w-100' placeholder="Поиск по названию и описанию" aria-describedby="basic-addon2" value={searchValue} onChange={changeSearchValue} />
                        <Button variant="outline-secondary" className='ms-1' onClick={handleSearchClick}>
                            <Image src="\loupe.svg" width="20" height="20" alt="Поиск по Id и логину" />
                        </Button>
                    </Form>
                </Col>
                <Col xs={12} md='auto' className='mt-2 g-0'>
                    <Row className='ms-1 d-flex justify-content-center'>
                        <Col xs='auto' className='mt-1 mt-xxl-0'>
                            <Link href={"/admin/createDish"} className={`btn btn-secondary`}>
                                Создать новое блюдо
                            </Link>
                        </Col>
                    </Row>
                </Col>
            </Row>
        </>
    );
}

export default PanelToHandleDishes;


PanelToHandleOrders.tsx
import React, {  FC, useState } from 'react';
import { Col, Dropdown, Row } from 'react-bootstrap';

interface PanelToHandleUsersProps {
    orderStates: orderState[],
    selectState: (selectedState: orderState) => void;
}

const PanelToHandleOrders: FC<PanelToHandleUsersProps> = ({ orderStates, selectState }) => {
    const [selectedState, setSelectedState] = useState<orderState>(orderStates[0]);

    const handleSelectState = (eventKey: string | null): void => {
        if(eventKey != null)
        {
            const selState = orderStates.find(el => el.numberOfStage == Number.parseInt(eventKey));
        
            if(selState != undefined){
                setSelectedState(selState);
                selectState(selState);
            }
        }

    }

    return (
        <>
            <Row className='g-0 m-1'>
                <Col xs='auto' className='g-0 me-1'>
                    <Dropdown onSelect={handleSelectState}>
                        <Dropdown.Toggle variant="success" id="dropdown-basic">
                            {selectedState.nameOfState}
                        </Dropdown.Toggle>
                        <Dropdown.Menu >
                            {orderStates.map((value, i) => <Dropdown.Item eventKey={value.numberOfStage} key={i}>{value.nameOfState}</Dropdown.Item>)}
                        </Dropdown.Menu>
                    </Dropdown>
                </Col>
            </Row>
        </>
    );
}

export default PanelToHandleOrders;


PanelToHandleStatistics.tsx
import React, {  FC, useState } from 'react';
import { Col, Dropdown, Row } from 'react-bootstrap';

interface PanelToHandleUsersProps {
    statisticQueries: statisticQueryInfo[],
    buildChart: (linkQuery: statisticQueryInfo) => void;
}

const PanelToHandleStatistics: FC<PanelToHandleUsersProps> = ({ statisticQueries, buildChart }) => {
    const [selectedQuery, setSelectedQuery] = useState<statisticQueryInfo>();

    const handleSelectQuery = (eventKey: string | null): void => {
        const selQuery = statisticQueries.find(el => el.nameQuery == eventKey);
        setSelectedQuery(selQuery);
        
        if(selQuery != undefined){
            buildChart(selQuery);
        }
    }

    return (
        <>
            <Row className='g-0 m-1'>
                <Col xs='auto' className='g-0 me-1'>
                    <Dropdown onSelect={handleSelectQuery}>
                        <Dropdown.Toggle variant="success" id="dropdown-basic">
                            {selectedQuery == undefined ? "Выберете аналитический запрос" : selectedQuery.nameQuery}
                        </Dropdown.Toggle>
                        <Dropdown.Menu >
                            {statisticQueries.map((value, i) => <Dropdown.Item eventKey={value.nameQuery} key={i}>{value.nameQuery}</Dropdown.Item>)}
                        </Dropdown.Menu>
                    </Dropdown>
                </Col>
            </Row>
        </>
    );
}

export default PanelToHandleStatistics;


PanelToHandleUsers.tsx
import React, { ChangeEvent, FC, MouseEvent, SyntheticEvent, useState } from 'react';
import { Button, Col, Dropdown, Form, Image, Row } from 'react-bootstrap';
import Link from 'next/link';

interface PanelToHandleUsersProps {
    roles: string[], 
    blockUsers: () => void, 
    unblockUsers: () => void,
    addRole: (role:string) => void, 
    removeRole: (role: string) => void,
    changeSearchedText: (newSearchedText:string) => void, 
}

const PanelToHandleUsers: FC<PanelToHandleUsersProps> = ({ roles, blockUsers, unblockUsers, addRole, removeRole, changeSearchedText }) => {
    const [searchValue, setSearchValue] = useState("");
    const [selectedRole, setSelectedRole] = useState("Роль");

    const changeSearchValue = (e: ChangeEvent<HTMLInputElement>): void => {
        e.preventDefault();
        setSearchValue(e.target.value);
    }

    const handleSearchClick = ():void =>{
        changeSearchedText(searchValue);
    }

    const handleAddRole = (): void => {
        if(selectedRole != "Роль")
            addRole(selectedRole);
        else
            alert("Вы не выбрали новую роль для пользователей")
    }

    const handleRemoveRole = (): void => {
        if(selectedRole != "Роль")
            removeRole(selectedRole);
        else
            alert("Вы не выбрали старую роль пользователей")
    }

    const handleSelectRole = (eventKey:string|null): void => {
        setSelectedRole(eventKey ?? "Роль");
    }

    const handleBlockUsers = (): void => {
        blockUsers()
    }

    const handleUnblockUsers = (): void => {
        unblockUsers()
    }

    return (
        <>
            <Row className='pe-md-3'>
                <Col xs={12} md='auto' className='mt-2 flex-grow-1'>
                    <Form className="d-flex w-100">
                        <Form.Control className='w-100' placeholder="Поиск по Id и логину" aria-describedby="basic-addon2" value={searchValue} onChange={changeSearchValue} />
                        <Button variant="outline-secondary" className='ms-1' onClick={handleSearchClick}>
                            <Image src="\loupe.svg" width="20" height="20" alt="Поиск по Id и логину" />
                        </Button>
                    </Form>
                </Col>
                <Col xs={12} md='auto' className='mt-2 g-0'>
                    <Row className='ms-1 d-flex justify-content-center'>
                        <Col xs='auto'  className='mt-1 mt-xxl-0'>
                            <Row className='g-0 me-1'>
                                <Col xs='auto' className='g-0 me-1'>
                                    <Dropdown onSelect={handleSelectRole}>
                                        <Dropdown.Toggle variant="success" id="dropdown-basic">
                                            {selectedRole}
                                        </Dropdown.Toggle>
                                        <Dropdown.Menu >
                                            {roles.map((value, i) => <Dropdown.Item eventKey={value} key={i}>{value}</Dropdown.Item>)}
                                        </Dropdown.Menu>
                                    </Dropdown>
                                </Col>
                                <Col xs='auto' className='g-0 me-1'>
                                    <Button onClick={handleAddRole} className={`btn btn-danger`}>
                                        Добавить роль
                                    </Button>
                                </Col>
                                <Col xs='auto' className='g-0 me-1'>
                                    <Button onClick={handleRemoveRole} className={`btn btn-danger`}>
                                        Удалить роль
                                    </Button>
                                </Col>
                            </Row>
                        </Col>

                        <Col xs='auto' className='mt-1 mt-xxl-0'>
                            <Row className='g-0 me-1 d-flex justify-content-center'>
                                <Col xs='auto' className='g-0 me-1'>
                                    <Button onClick={handleBlockUsers} className={`btn btn-danger`}>
                                        Заблокировать
                                    </Button>
                                </Col>
                                <Col xs='auto' className='g-0 me-1'>
                                    <Button onClick={handleUnblockUsers} className={`btn btn-danger`}>
                                        Разблокировать
                                    </Button>
                                </Col>
                            </Row>
                        </Col>
                    </Row>
                </Col>
            </Row>
        </>
    );
}

export default PanelToHandleUsers;


DishAdminCard.tsx
import React, { FC } from 'react';
import DishStandartLayout from '../structure/DishStandartLayout';
import HandlerAdminDish from './components/HandlerAdminDish';

interface DishAdminCard extends dishAdminInfo {
    changeVisibleState: (dishId:string)=>void, 
    changeDeletedState: (dishId:string)=>void
}

const DishAdminCard: FC<DishAdminCard> = (dishInfo) => {
    return (
        <DishStandartLayout dishInfo={dishInfo}>
            <HandlerAdminDish 
                dishId={dishInfo.id}
                dishDeleted={dishInfo.isDeleted} 
                isVisibleForUsers={dishInfo.isAvailableForUser} 
                changeDeleteStateDish={dishInfo.changeDeletedState}
                changeVisibleStateDish={dishInfo.changeVisibleState}/>
        </DishStandartLayout>
    );
}

export default DishAdminCard;


DishCartCard.tsx
import React, { FC } from 'react';
import CounterCartDish from './components/CounterCartDish';
import DishStandartLayout from '../structure/DishStandartLayout';

const DishCartCard: FC<dishCartInfo> = (dishInfo) => {

    return (
        <DishStandartLayout dishInfo={dishInfo}>
            <CounterCartDish dishId={dishInfo.id} cancelDish={dishInfo.DeleteCardFromList}/>
        </DishStandartLayout>
    );
}

export default DishCartCard;


DishMainCard.tsx
import React, { FC } from 'react';
import CounterMainDish from './components/CounterMainDish';
import DishStandartLayout from '../structure/DishStandartLayout';

const DishMainCard: FC<dishClientInfo> = (dishInfo) => {

    return (
        <DishStandartLayout dishInfo={dishInfo}>
            <CounterMainDish dishId={dishInfo.id}/>
        </DishStandartLayout>
    );
}

export default DishMainCard;


DishOrderCard.tsx
import React, { FC, useContext } from 'react';
import CounterOrderDish from './components/CounterOrderDish';
import { AuthContext } from '../contexts/AuthContext';
import DishStandartLayout from '../structure/DishStandartLayout';

const DishOrderCard: FC<orderedDishClientInfo> = ({count, dishInfo, orderId}) => {
    const roleContextData = useContext<authContextProps>(AuthContext);

    const changeCountOrderedDish = async (dishId:string, newCount: number) =>{
        const response = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/changeCountOrderedDish`, {
            method: "POST",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({newCount, orderId, dishId})
        });
        if(!response.ok){
            alert(await response.text())
        }
    }

    return (
        <DishStandartLayout dishInfo={dishInfo}>
            {roleContextData.isAdmin && <CounterOrderDish dishId={dishInfo.id} cancelDish={dishInfo.DeleteCardFromList} changeCountDish={changeCountOrderedDish} countOrdered={count}/>}
        </DishStandartLayout>
    );
}

export default DishOrderCard;


OrderCard.tsx
import React, { FC, useContext, useState } from 'react';
import { Card, Col, Row } from 'react-bootstrap';
import Link from 'next/link';
import { AuthContext } from '../contexts/AuthContext';
import OrderStateItem from './components/OrderStateItem';
import CancelOrderModal from '../models/CancelOrderModal';
import ReviewOrderModal from '../models/ReviewOrderModal';

const OrderCard: FC<orderCardInfo> = (orderInfo) => {
    const authContextData = useContext<authContextProps>(AuthContext);
    const [showStory, setShowStory] = useState(false);
    const [showCancelModel, setShowCancelModal] = useState(false);
    const [showReviewModel, setShowReviewModal] = useState(false);

    const handleShowCancelModal = () =>{
        setShowCancelModal(true);
    }

    const handleCloseCancelModal = () =>{
        setShowCancelModal(false);
    }

    const handleShowReviewModal = () =>{
        setShowReviewModal(true);
    }

    const handleCloseReviewModal = () =>{
        setShowReviewModal(false);
    }

    const handleCancelClick = (reasonOfCancel:string): void => {
        orderInfo.DeleteOrder(orderInfo.id, reasonOfCancel);
        setShowCancelModal(false);
    }

    const handleSendReviewClick = async (review:string, rating:number)=>{
        const resp1 = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/order/reviewOrder`, {
            method: "POST",
            credentials: "include",
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                'Content-Type': 'application/json;charset=utf-8',
            },
            body: JSON.stringify({ orderId: orderInfo.id, review, clientRating:rating })
        });

        if (resp1.ok) {
            setShowReviewModal(false);
        }
        else{
            alert(await resp1.text());
        }
    }

    const handleShowStoryClick = (): void => {
        setShowStory(!showStory);
    }

    const handleMoveToNextOrderStage = ():void => {
        const orderStory = orderInfo.story as orderState[];
        orderInfo.MoveOrderToNextStage(orderInfo.id, orderStory[orderStory.length - 1].orderStateId)
    }

    const handleMoveToPreviousOrderStage = ():void => {
        const orderStory = orderInfo.story as orderState[];
        orderInfo.MoveOrderToPreviousStage(orderInfo.id, orderStory[orderStory.length - 1].orderStateId)
    }

    let clientCanCancelOrder:Boolean = false;
    if(orderInfo.story != null ){
        const curOrderStatus = orderInfo.story[orderInfo.story.length-1];
        clientCanCancelOrder = (authContextData.isClient && curOrderStatus.numberOfStage != 16 && curOrderStatus.numberOfStage != 32) as Boolean;
    }

    let clientCanReviewOrder:Boolean = false;
    if(orderInfo.story != null ){
        const curOrderStatus = orderInfo.story[orderInfo.story.length-1];
        clientCanReviewOrder = (authContextData.isClient && curOrderStatus.numberOfStage == 16  && orderInfo.canWriteReview) as Boolean;
    }

    return (
        <>
            <Card className="mt-2 bg-light">
                <Row className="g-0 align-items-center">
                    <Col className="col-md">
                        <Card.Body>
                            <Card.Title>Номер заказа: {orderInfo.id}</Card.Title>
                            <Row className='mb-2 d-flex justify-content-between'>
                                <Col className='col-auto'>
                                    <Card.Text>Стоимость:{orderInfo.price}</Card.Text>
                                </Col>
                                <Col className='col-auto'>
                                    <Card.Text>Адрес доставки: {orderInfo.deliveryAddress}</Card.Text>
                                </Col>
                                <Col className='col-auto'>
                                    <Card.Text>Номер клиента: {orderInfo.phoneNumber}</Card.Text>
                                </Col>
                            </Row>

                            {orderInfo.story != null && <Card.Text>Статус: {orderInfo.story[orderInfo.story.length-1].nameOfState}</Card.Text>}
                            <Row className='d-flex justify-content-center'>
                                <Col className='col-10 col-lg-auto me-lg-auto mt-2'>
                                    <Link href={(authContextData.isAdmin ? '/admin':'/profile') + "/order?orderId=" + orderInfo.id} className='btn btn-secondary w-100'>Посмотреть детали</Link>
                                </Col>
                                {(authContextData.isAdmin || clientCanCancelOrder) &&
                                    <Col className='col-10 col-lg-auto mt-2'>
                                        <button className='btn btn-danger w-100' onClick={handleShowCancelModal}>Отменить</button>
                                    </Col>}
                                {clientCanReviewOrder &&
                                    <Col className='col-10 col-lg-auto mt-2'>
                                        <button className='btn btn-primary w-100' onClick={handleShowReviewModal}>Написать отзыв</button>
                                    </Col>}
                                <Col className='col-10 col-lg-auto mt-2'>
                                    <button className='btn btn-secondary w-100' onClick={handleShowStoryClick}>{showStory ? 'Скрыть':'Показать'} историю заказа</button>
                                </Col>
                                {showStory && orderInfo.story?.map((value,i)=><OrderStateItem key={i} {...value}/>)}
                                {((showStory && authContextData.isAdmin) || authContextData.isKitchenWorker) && 
                                    <Row className='d-flex justify-content-center'>
                                        <Col className='col-auto mt-2'>
                                            <button className='btn btn-danger w-100' onClick={handleMoveToPreviousOrderStage}>Вернуть к предыдущей стадии</button>
                                        </Col>
                                        <Col className='col-auto mt-2'>
                                            <button className='btn btn-danger w-100' onClick={handleMoveToNextOrderStage}>Перевести в следующую стадию</button>
                                        </Col>
                                    </Row>
                                }
                            </Row>
                            
                        </Card.Body>
                    </Col>
                </Row>
            </Card>
            {showCancelModel && <CancelOrderModal show={showCancelModel} closeModel={handleCloseCancelModal} commitCancelOrder={handleCancelClick}/>}
            {showReviewModel && <ReviewOrderModal show={showReviewModel} closeModel={handleCloseReviewModal} commitAction={handleSendReviewClick}/>}
        </>
    );
}

export default OrderCard;


UserCard.tsx
import React, { FC, ReactElement, useEffect, useState } from 'react';
import { Card, Col, Row, Button, Form } from 'react-bootstrap';

const UserCard: FC<{ userInfo: profileInfo, markUser: (userId: string) => void, unmarkUser: (userId: string) => void, }> = ({ userInfo, markUser, unmarkUser }) => {
    const [showMoreInfo, setShowMoreInfo] = useState(false);
    const [unmarked, setUnmarked] = useState(true);

    const handleShowStoryClick = (): void => {
        setShowMoreInfo(!showMoreInfo);
    }

    const handleClickToCheckBox = (): void => {
        if (unmarked) {
            markUser(userInfo.id as string);
        }
        else {
            unmarkUser(userInfo.id as string);
        }
        setUnmarked(!unmarked);
    }

    return (
        <>
            <Card className="mt-2 bg-light">
                <Row className="g-0 align-items-center">
                    <Card.Body>
                        <Row className='d-flex justify-content-start'>
                            <Col xs={12} lg='auto' className='mt-1'>
                                <Card.Title>Id: {userInfo.id}</Card.Title>
                            </Col>
                            <Col xs={12} lg='auto' className='mt-1 me-auto'>
                                <Card.Text className='m-0'>Роли пользователя: {userInfo.roles}</Card.Text>
                            </Col>
                            <Col xs={12} lg='auto' className='mt-1 d-flex justify-content-end me-auto '>
                                <Form className='d-flex justify-content-end'>
                                    <Form.Check reverse type="switch" onClick={handleClickToCheckBox} label="Выбрать пользователя" />
                                </Form>
                            </Col>
                        </Row>
                        <Row className='d-flex justify-content-start'>
                            <Col xs={12} lg='auto' className='me-lg-auto mt-1'>
                                <Card.Text>Логин пользователя: {userInfo.login}</Card.Text>
                            </Col>
                            {userInfo.isBlocked &&
                                <Col xs={12} lg='auto' className='mt-1'>
                                    <Card.Text className='text-danger'>Заблокирован</Card.Text>
                                </Col>}
                            <Col xs={12} lg='auto' className='mt-1'>
                                <Button className='btn btn-secondary w-100' onClick={handleShowStoryClick}>{showMoreInfo ? 'Скрыть' : 'Показать'} подробную информацию</Button>
                            </Col>
                        </Row>
                        {showMoreInfo &&
                            <>
                                <Row className='d-flex justify-content-start'>
                                    <Col md='auto' className='mt-1'>
                                        <Card.Text>Имя: {userInfo.name}</Card.Text>
                                    </Col>
                                    <Col md='auto' className='mt-1'>
                                        <Card.Text>Дата рождения: {new Date(userInfo.born as string).toLocaleDateString()}</Card.Text>
                                    </Col>
                                    <Col md='auto' className='mt-1'>
                                        <Card.Text>Номер телефона: {userInfo.phoneNumber}</Card.Text>
                                    </Col>
                                </Row>
                                <Row className='d-flex justify-content-start'>
                                    <Col md='auto' className='mt-1'>
                                        <Card.Text>Адрес: {userInfo.address}</Card.Text>
                                    </Col>
                                </Row>
                            </>
                        }
                    </Card.Body>
                </Row>
            </Card>
        </>
    );
}

export default UserCard;


WorkerCard.tsx
import React, { FC, useState } from 'react';
import { Card, Col, Row, Button } from 'react-bootstrap';

const WorkerCard: FC<{ userInfo: profileInfo }> = ({ userInfo }) => {
    const [showMoreInfo, setShowMoreInfo] = useState(false);

    const handleShowStoryClick = (): void => {
        setShowMoreInfo(!showMoreInfo);
    }

    return (
        <>
            <Card className="mt-2 bg-light">
                <Row className="g-0 align-items-center">
                    <Card.Body>
                        <Row className='d-flex justify-content-start'>
                            <Col xs={12} lg='auto' className='mt-1'>
                                <Card.Title>Id: {userInfo.id}</Card.Title>
                            </Col>
                            <Col xs={12} lg='auto' className='mt-1'>
                                <Card.Title>Должность: {userInfo.jobTitle}</Card.Title>
                            </Col>
                        </Row>
                        <Row className='d-flex justify-content-start'>
                            <Col xs={12} lg='auto' className='me-lg-auto mt-1'>
                                <Card.Text>Имя: {userInfo.name}</Card.Text>
                            </Col>
                            <Col xs={12} lg='auto' className='me-lg-auto mt-1'>
                                <Card.Text>Логин пользователя: {userInfo.login}</Card.Text>
                            </Col>
                            {userInfo.isBlocked &&
                                <Col xs={12} lg='auto' className='mt-1'>
                                    <Card.Text className='text-danger'>Заблокирован</Card.Text>
                                </Col>}
                            <Col xs={12} lg='auto' className='mt-1'>
                                <Button className='btn btn-secondary w-100' onClick={handleShowStoryClick}>{showMoreInfo ? 'Скрыть' : 'Показать'} подробную информацию</Button>
                            </Col>
                        </Row>
                        {showMoreInfo &&
                            <Row className='d-flex justify-content-start'>
                                <Col md='auto' className='mt-1'>
                                    <Card.Text>Получил работу: {new Date (userInfo.gotJob as Date).toLocaleDateString()}</Card.Text>
                                </Col>
                                <Col md='auto' className='mt-1'>
                                    <Card.Text>Дата рождения: {new Date(userInfo.born as string).toLocaleDateString()}</Card.Text>
                                </Col>
                                <Col md='auto' className='mt-1'>
                                    <Card.Text>Номер телефона: {userInfo.phoneNumber}</Card.Text>
                                </Col>
                            </Row>
                        }
                    </Card.Body>
                </Row>
            </Card>
        </>
    );
}

export default WorkerCard;


CounterCartDish.tsx
import React, { FC, useState } from 'react';
import styles from '@/styles/Home.module.css'
import { useCookies } from 'react-cookie';
import { Button, Col, Row } from 'react-bootstrap';


const CounterCartDish: FC<{ dishId: string, cancelDish: (dishId: string) => void }> = ({ dishId, cancelDish }) => {
    const [cookies, setCookie] = useCookies(['cartDishes']);
    const [count, setCount] = useState(Number.parseInt(cookies?.cartDishes[dishId]) ?? 1);

    //Изменяет количество блюд, находящихся в корзине
    const changeCountDishToCookies = (): void => {
        cookies.cartDishes[dishId] = count;

        setCookie('cartDishes', JSON.stringify(cookies.cartDishes), { path: '/', sameSite: "none", secure: true })
    };

    const handleChangeCountClick = (countToAdd: number): void => {
        setCount((count) => {
            let sum = count + countToAdd;
            return sum > 20 || sum < 1 ? count : sum;
        });
    }

    //Удаляет свойство с id текущего блюда из куки, обновляет куки, удаляет блюдо из списка
    const handleCancelClick = (): void => {
        delete cookies.cartDishes[dishId];
        setCookie('cartDishes', JSON.stringify(cookies.cartDishes), { path: '/', sameSite: "none", secure: true })
        cancelDish(dishId);
    }

    return (
        <>
            <Row className='d-flex justify-content-end pe-md-3'>
                <Col xs={12} md={4} className='d-flex justify-content-md-start justify-content-center mt-2'>
                    <Button onClick={handleCancelClick} className={`btn btn-danger me-2`}>
                        Отменить
                    </Button>
                </Col>
                <Col xs={12} md={4} className='mt-2'>
                    <Row className='d-flex justify-content-md-end justify-content-center'>
                        <Button onClick={() => handleChangeCountClick(1)} className={`btn btn-secondary ${styles.cardCountBtnAndP}`}>
                            +
                        </Button>
                        <div className={`d-flex align-items-center justify-content-center ${styles.cardCountBtnAndP}`}>
                            <p className='m-0'>
                                {count}
                            </p>
                        </div>
                        <Button onClick={() => handleChangeCountClick(-1)} className={`btn btn-secondary ${styles.cardCountBtnAndP}`}>
                            -
                        </Button>
                    </Row>
                </Col>
                <Col xs={12} md={4} className='d-flex justify-content-md-start justify-content-center mt-2'>
                    <Button onClick={changeCountDishToCookies}>
                        Изменить количество
                    </Button>
                </Col>
            </Row>
        </>
    );
}

export default CounterCartDish;


CounterMainDish.tsx
import React, { FC, useState } from 'react';
import styles from '@/styles/Home.module.css'
import { useCookies } from 'react-cookie';
import { Button } from 'react-bootstrap';


const CounterMainDish: FC<{dishId: string}> = ({dishId}) => {
    const [count, setCount] = useState(1);
    const [cookies, setCookie] = useCookies(['cartDishes']);    

    //Добавляет количество блюд, к находящимся в корзине
    const addCountDishToCookies = ():void => {
        let futureCookie:any = {};
        if(cookies.cartDishes != undefined)
            futureCookie = cookies.cartDishes;

        var countCurDish = futureCookie[dishId] ?? 0;

        futureCookie[dishId] = countCurDish + count;

        setCookie('cartDishes', JSON.stringify(futureCookie), { path: '/', sameSite: "none", secure: true });
    };

    const handleClick = (countToAdd: number): void => {
        setCount((count) => {
            let sum = count + countToAdd;
            return sum > 20 || sum < 1 ? count : sum;
        });
    }

    return (
        <>
            <div className='d-flex justify-content-end pe-md-3'>
                <button onClick={() => handleClick(1)} className={`btn btn-secondary ${styles.cardCountBtnAndP}`}>
                    +
                </button>
                <div className={`d-flex align-items-center justify-content-center ${styles.cardCountBtnAndP}`}>
                    <p className='m-0'>
                        {count}
                    </p>
                </div>
                <button onClick={() => handleClick(-1)} className={`btn btn-secondary me-2 ${styles.cardCountBtnAndP}`}>
                    -
                </button>
                <Button onClick={addCountDishToCookies}>
                    Добавить в корзину
                </Button>
            </div>
        </>
    );
}

export default CounterMainDish;


CounterOrderDish.tsx
import React, { FC, useState } from 'react';
import styles from '@/styles/Home.module.css'
import { Button, Col, Row } from 'react-bootstrap';

interface CounterOrderDishProps { 
    dishId: string, 
    cancelDish: (dishId: string) => void, 
    changeCountDish: (dishId: string, newCount:number) => void, 
    countOrdered: number,
}

const CounterOrderDish: FC<CounterOrderDishProps> = ({ dishId, cancelDish, changeCountDish, countOrdered }) => {
    const [count, setCount] = useState(countOrdered);

    const handleChangeCountClick = (countToAdd: number) => {
        setCount((count) => {
            let sum = count + countToAdd;
            return sum > 20 || sum < 1 ? count : sum;
        });
    }

    const handleCommitChangeCountClick = async () =>{
        changeCountDish(dishId, count);
    }

    const handleCancelClick = (): void => {
        cancelDish(dishId);
    }

    return (
        <>
            <Row className='d-flex justify-content-end pe-md-3'>
                <Col xs={12} md={4} className='d-flex justify-content-md-start justify-content-center mt-2'>
                    <Button onClick={handleCancelClick} className={`btn btn-danger me-2`}>
                        Отменить
                    </Button>
                </Col>
                <Col xs={12} md={4} className='mt-2'>
                    <Row className='d-flex justify-content-md-end justify-content-center'>
                        <Button onClick={() => handleChangeCountClick(1)} className={`btn btn-secondary ${styles.cardCountBtnAndP}`}>
                            +
                        </Button>
                        <div className={`d-flex align-items-center justify-content-center ${styles.cardCountBtnAndP}`}>
                            <p className='m-0'>
                                {count}
                            </p>
                        </div>
                        <Button onClick={() => handleChangeCountClick(-1)} className={`btn btn-secondary ${styles.cardCountBtnAndP}`}>
                            -
                        </Button>
                    </Row>
                </Col>
                <Col xs={12} md={4} className='d-flex justify-content-md-start justify-content-center mt-2'>
                    <Button onClick={handleCommitChangeCountClick}>
                        Изменить количество
                    </Button>
                </Col>
            </Row>
        </>
    );
}

export default CounterOrderDish;


HandlerAdminDish.tsx
import React, { FC, useState } from 'react';
import styles from '@/styles/Home.module.css'
import { useCookies } from 'react-cookie';
import { Button, Col, Row } from 'react-bootstrap';
import Link from 'next/link';

interface HandlerAdminDishProps {
    dishId: string, 
    dishDeleted: boolean, 
    isVisibleForUsers: boolean, 
    changeDeleteStateDish: (dishId:string)=>void,
    changeVisibleStateDish: (dishId:string)=>void,
}

const HandlerAdminDish: FC<HandlerAdminDishProps> = ({ dishId, dishDeleted, isVisibleForUsers, changeDeleteStateDish, changeVisibleStateDish }) => {

    const handleDeleteStateDish = () =>{
        changeDeleteStateDish(dishId);
    }

    const handleVisibleStateDish = () =>{
        changeVisibleStateDish(dishId);
    }

    return (
        <>
            <Row className='ms-1 d-flex justify-content-center'>
                <Col xs='auto' className='mt-1 mt-xxl-0'>
                    <Link href={"/admin/changeDish?dishId=" + dishId} className={`btn btn-secondary`}>
                        Изменить блюдо
                    </Link>
                </Col>
                <Col xs='auto' className='mt-1 mt-xxl-0'>
                    <Button onClick={handleDeleteStateDish} className={`btn btn-secondary`}>
                        {dishDeleted ? "Восстановить блюдо" : "Удалить блюдо"}
                    </Button>
                </Col>
                <Col xs='auto' className='mt-1 mt-xxl-0'>
                    <Button onClick={handleVisibleStateDish} className={`btn btn-secondary`}>
                        {isVisibleForUsers ? "Скрыть от пользователей" : "Сделать доступным для пользователей"}
                    </Button>
                </Col>
            </Row>
        </>
    );
}

export default HandlerAdminDish;


OrderStateItem.tsx
import React, { FC, useState } from 'react';
import { Card, Col, Row } from 'react-bootstrap';

const OrderStateItem: FC<orderState> = (orderState) => {

    return (
        <Card className='mt-2'>
            <Row className='p-md-1'>
                <Col xs={12} md={5} >
                    <div>Статус: {orderState.nameOfState}</div>
                </Col>
                <Col xs={12} md={7} >
                    <div>Время начала стадии: {orderState.timeStartState.toLocaleString()}</div>
                </Col>
            </Row>
            <Row className='p-md-1'>
                <Col xs={12} >
                    <div>Описание стадии: {orderState.descriptionForClient}</div>
                </Col>
            </Row>
            <Row className='p-md-1'>
                <Col xs={12} >
                    <div>Комментарий: {orderState.comment}</div>
                </Col>
            </Row>
        </Card>
    );
}

export default OrderStateItem;


customMap.tsx
import { MapContext } from "../contexts/MapContext";
import { FC, ReactNode, useEffect, useRef, useState } from "react";
import * as ol from "ol";
import { MapOptions } from "ol/Map";

const CustomMap: FC<{ children: ReactNode, zoom: number, center: Array<number> }> = ({ children, zoom, center }) => {
    const mapRef = useRef<HTMLDivElement | null>(null);
    const [map, setMap] = useState<ol.Map | null>(null);
    
    // on component mount
    useEffect(() => {
        const options:MapOptions = {
            view: new ol.View({ zoom, center }),
            layers: [],
            controls: [],
            overlays: []
        };
        const mapObject = new ol.Map(options);
        mapObject.setTarget(mapRef.current as string | HTMLElement | undefined);
        setMap(mapObject);
        return () => mapObject.setTarget(undefined);
    }, []);
    // zoom change handler
    useEffect(() => {
        if (!map) return;
        map.getView().setZoom(zoom);
    }, [zoom]);
    // center change handler
    useEffect(() => {
        if (!map) return;
        map.getView().setCenter(center)
    }, [center])
    return (
        <MapContext.Provider value={{ map }}>
            <div ref={mapRef} style={{height:'500px'}} >
                {children}
            </div>
        </MapContext.Provider>
    )
}
export default CustomMap;
Layers.tsx
import React, { FC, ReactNode } from "react";

const Layers: FC<{ children: ReactNode }> = ({ children }) => {
  return (<div>
        {children}
    </div>);
};

export default Layers;

TitleLayer.tsx
import { FC, useContext, useEffect } from "react";
import OLTileLayer from "ol/layer/Tile";
import { MapContext } from "@/components/contexts/MapContext";
import * as ol from "ol";
import { Options } from "ol/layer/Layer";

interface mapContextProps {
    map: ol.Map | null,
}

const TileLayer:FC<Options<any>> = ({ source, zIndex = 0 }) => {
  const { map } = useContext<mapContextProps>(MapContext); 
  useEffect(() => {
    if (!map) return;
    
    let tileLayer = new OLTileLayer({
      source,
      zIndex,
    });
    map.addLayer(tileLayer);
    tileLayer.setZIndex(zIndex);
    return () => {
      if (map) {
        map.removeLayer(tileLayer);
      }
    };
  }, [map]);
  return null;
};
export default TileLayer;
CancelOrderModal.tsx
import React, { ChangeEvent, FC, useState } from 'react';
import { Form } from 'react-bootstrap';
import Button from 'react-bootstrap/Button';
import Modal from 'react-bootstrap/Modal';

interface CancelOrderModelProps {
    show: boolean | undefined,
    commitCancelOrder: (reasonOfCancel: string) => void,
    closeModel: () => void,
}

const CancelOrderModal: FC<CancelOrderModelProps> = ({ show, commitCancelOrder, closeModel }) => {
    const [reasonOfCancel, setReasonOfCancel] = useState("")

    const changeTextOfReason = (e:ChangeEvent<HTMLInputElement>) => {
        const newValue = e.target.value;
        setReasonOfCancel(newValue);
    }

    const handleCommit = async () => {
        commitCancelOrder(reasonOfCancel)
    }

    return (
        <>
            <Modal show={show} onHide={closeModel} keyboard={false} aria-labelledby="contained-modal-title-vcenter">
                <Modal.Header closeButton>
                    <Modal.Title>Отмена заказа</Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    <Form>
                        <Form.Group className="mb-3">
                            <Form.Label>Пожалуйста, введите причину, из-за которой Вы отменяете заказ: </Form.Label>
                            <Form.Control as="textarea" rows={3} value={reasonOfCancel} onChange={changeTextOfReason}/>
                        </Form.Group>
                    </Form>
                </Modal.Body>
                <Modal.Footer>
                    <Button variant="secondary" onClick={closeModel}>
                        Закрыть
                    </Button>
                    <Button variant="primary" onClick={handleCommit}>Отменить заказ</Button>
                </Modal.Footer>
            </Modal>
        </>
    );
}

export default CancelOrderModal;
PlaceAnOrderModal.tsx
import React, { ChangeEvent, FC, useEffect, useState } from 'react';
import { Form } from 'react-bootstrap';
import Button from 'react-bootstrap/Button';
import Modal from 'react-bootstrap/Modal';

interface PlaceAnOrderModelProps {
    show: boolean | undefined,
    commitAction: (userAddress: string, userPhoneNumber: string, comment: string) => void,
    closeModel: () => void,
}

const PlaceAnOrderModal: FC<PlaceAnOrderModelProps> = ({ show, commitAction, closeModel }) => {
    const [address, setAddress] = useState("")
    const [phoneNumber, setPhoneNumber] = useState("")
    const [comment, setComment] = useState("")

    const changeAddress = (e:ChangeEvent<HTMLInputElement>) => {
        const newValue = e.target.value;
        setAddress(newValue);
    }

    const changePhoneNumber = (e:ChangeEvent<HTMLInputElement>) => {
        const newValue = e.target.value;
        setPhoneNumber(newValue);
    }

    const changeComment = (e:ChangeEvent<HTMLInputElement>) => {
        const newValue = e.target.value;
        setComment(newValue);
    }

    const handleCommit = async () => {
        if(address == "" || phoneNumber == "")
        {
            alert("Для оформления заказа необходимо ввести ваш номер телефона и адрес")
            return;
        }
        commitAction(address, phoneNumber, comment)
    }

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/main/getProfileInfo`, {
                credentials: 'include',
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                }, 
            });

            if(resp.ok){
                const profileInfo = await resp.json() as {address: string, phoneNumber: string};
                setAddress(profileInfo.address);
                setPhoneNumber(profileInfo.phoneNumber);
            }        
            else{
                const errorText = await resp.text()
                if(errorText != "")
                    alert(errorText);
            }
        }
        fetchData();
    }, []);

    return (
        <>
            <Modal show={show} onHide={closeModel} keyboard={false} aria-labelledby="contained-modal-title-vcenter">
                <Modal.Header closeButton>
                    <Modal.Title>Оформление заказа</Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    <Form>
                        <Form.Group className="mb-3" >
                            <Form.Label>Пожалуйста, введите адрес, по которому необходимо доставить заказ: </Form.Label>
                            <Form.Control type="text" value={address} onChange={changeAddress}/>
                        </Form.Group>
                        <Form.Group className="mb-3">
                            <Form.Label>Пожалуйста, введите свой номер телефона: </Form.Label>
                            <Form.Control type="tel" placeholder="+7" maxLength={12} value={phoneNumber} onChange={changePhoneNumber}/>
                        </Form.Group>
                        <Form.Group className="mb-3">
                            <Form.Label>Комментарий к заказу: </Form.Label>
                            <Form.Control as="textarea" rows={2} value={comment} onChange={changeComment}/>
                        </Form.Group>
                    </Form>
                </Modal.Body>
                <Modal.Footer>
                    <Button variant="secondary" onClick={closeModel}>
                        Закрыть
                    </Button>
                    <Button variant="primary" onClick={handleCommit}>Оформить заказ</Button>
                </Modal.Footer>
            </Modal>
        </>
    );
}

export default PlaceAnOrderModal;
ReviewOrderModal.tsx
import React, { ChangeEvent, FC, useState } from 'react';
import { Form, Row } from 'react-bootstrap';
import Button from 'react-bootstrap/Button';
import Modal from 'react-bootstrap/Modal';
import styles from '@/styles/Home.module.css'

interface ReviewOrderModelProps {
    show: boolean | undefined,
    commitAction: (review: string, rating:number) => void,
    closeModel: () => void,
}

const ReviewOrderModal: FC<ReviewOrderModelProps> = ({ show, commitAction, closeModel }) => {
    const [clientReview, setClientReview] = useState("")
    const [rating, setRating] = useState(10);

    const changeTextOfReason = (e: ChangeEvent<HTMLInputElement>) => {
        const newValue = e.target.value;
        setClientReview(newValue);
    }

    const handleCommit = async () => {
        commitAction(clientReview, rating)
    }

    const handleChangeCountClick = (countToAdd: number): void => {
        setRating((count) => {
            let sum = count + countToAdd;
            return sum > 10 || sum < 1 ? count : sum;
        });
    }

    return (
        <>
            <Modal show={show} onHide={closeModel} keyboard={false} aria-labelledby="contained-modal-title-vcenter">
                <Modal.Header closeButton>
                    <Modal.Title>Отзыв</Modal.Title>
                </Modal.Header>
                <Modal.Body>
                    <Form>
                        <Form.Group className="mb-3">
                            <Form.Label>Ваша оценка: </Form.Label>
                            <Row className='d-flex justify-content-center'>
                                <Button onClick={() => handleChangeCountClick(1)} className={`btn btn-secondary ${styles.cardCountBtnAndP}`}>
                                    +
                                </Button>
                                <div className={`d-flex align-items-center justify-content-center ${styles.cardCountBtnAndP}`}>
                                    <p className='m-0'>
                                        {rating}
                                    </p>
                                </div>
                                <Button onClick={() => handleChangeCountClick(-1)} className={`btn btn-secondary ${styles.cardCountBtnAndP}`}>
                                    -
                                </Button>
                            </Row>
                        </Form.Group>
                        <Form.Group className="mb-3">
                            <Form.Label>Пожалуйста, введите отзыв: </Form.Label>
                            <Form.Control as="textarea" value={clientReview} onChange={changeTextOfReason} />
                        </Form.Group>
                    </Form>
                </Modal.Body>
                <Modal.Footer>
                    <Button variant="secondary" onClick={closeModel}>
                        Закрыть
                    </Button>
                    <Button variant="primary" onClick={handleCommit}>Оставить отзыв</Button>
                </Modal.Footer>
            </Modal>
        </>
    );
}

export default ReviewOrderModal;
BarChart.tsx
import { ChartData } from "chart.js";
import { FC, useEffect, useState } from "react";
import { Bar } from 'react-chartjs-2';
import ChartDataLabels from 'chartjs-plugin-datalabels';

import {
    Chart as ChartJS,
    CategoryScale,
    LinearScale,
    BarElement,
    Title,
    Tooltip,
    Legend,
  } from 'chart.js';
  
  ChartJS.register(
    CategoryScale,
    LinearScale,
    BarElement,
    Title,
    Tooltip,
    Legend
  );

  function getRandomInt(max:number) {
    return Math.floor(Math.random() * max);
}

const BarChart: FC<{ query:statisticQueryInfo }> = ({ query }) => {
    const [chartData, setChartData] = useState<ChartData<"bar">>();

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/statistic/${query.linkToQuery}`, {
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                },
            });

            if(resp.ok){
                const resInfo = await resp.json() as statisticQueryDataItem[];
    
                const data:{labels:string[], datasets:any} = {
                    labels: resInfo.map((value) => value.x),
                    datasets: [],
                }
                
                for( let i = 0; i < (query.nameDatasets?.length ?? 1); i++)
                {
                    data.datasets.push({
                        label: query.nameDatasets == null ? query.nameQuery : query.nameDatasets[i],
                        data: resInfo.map((value) => value.y[i]),
                        borderColor: `rgb(${getRandomInt(255)}, ${getRandomInt(255)}, ${getRandomInt(255)})`,
                        backgroundColor: `rgb(${getRandomInt(255)}, ${getRandomInt(255)}, ${getRandomInt(255)})`,
                        borderWidth: 1,
                    });
                };
    
                setChartData(data);
            }
            else{
                alert(await resp.text());
            }

        }
        fetchData();
    }, [query]);

    const options = {
        plugins: {
            datalabels: {
                color: '#000',
                font: {
                    weight: 'bold' as 'bold'
                },
                align: 'center' as 'center'
              }
        },
    };

    return (
        <>
            {chartData != undefined && <Bar plugins={[ChartDataLabels]} options={options} data={chartData}/>}
        </>    
    );
}

export default BarChart;
LineChart.tsx
import { ChartData } from "chart.js";
import { FC, useEffect, useState } from "react";
import { Line } from "react-chartjs-2";
import ChartDataLabels from 'chartjs-plugin-datalabels';

import {
    Chart as ChartJS,
    CategoryScale,
    LinearScale,
    PointElement,
    LineElement,
    Title,
    Tooltip,
    Legend,
  } from 'chart.js';

  ChartJS.register(
    CategoryScale,
    LinearScale,
    PointElement,
    LineElement,
    Title,
    Tooltip,
    Legend,
  );

const LineChart: FC<{ query:statisticQueryInfo }> = ({ query }) => {
    const [chartsData, setChartsData] = useState<ChartData<"line">[]>([]);

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/statistic/${query.linkToQuery}`, {
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                },
            });

            if(resp.ok){
                const resInfo = await resp.json() as statisticQueryDataItem[];
    
                const datasets:ChartData<"line">[] = [];
                
                for( let i = 0; i < (query.nameDatasets?.length ?? 1); i++)
                {
                    datasets.push({
                        labels: resInfo.map((value) => value.x),
                        datasets: [
                            {
                                label: query.nameDatasets == null ? query.nameQuery : query.nameDatasets[i] ,
                                data: resInfo.map((value) => value.y[i]),
                                borderColor: 'rgb(255, 99, 132)',
                                backgroundColor: '#7E07A9',
                            },
                        ],
                    });
                };
    
                setChartsData(datasets);
            }
            else{
                alert(await resp.text());
            }
           
        }
        fetchData();
    }, [query]);

    const options = {
        plugins: {
            datalabels: {
                color: '#000',
                font: {
                    weight: 'bold' as 'bold'
                },
                align: 'left' as 'left'
              }
        },
    };

    return (
        <>
            {chartsData.map((chartData, i) => <Line key={i} plugins={[ChartDataLabels]} options={options} data={chartData}/>) }
        </>    
    );
}

export default LineChart;
RadarChart.tsx
import { ChartData } from "chart.js";
import { FC, useEffect, useState } from "react";
import { Radar } from 'react-chartjs-2';
import ChartDataLabels from 'chartjs-plugin-datalabels';

import {
    Chart as ChartJS,
    RadialLinearScale,
    PointElement,
    LineElement,
    Filler,
    Tooltip,
    Legend,
  } from 'chart.js';
  
  ChartJS.register(
    RadialLinearScale,
    PointElement,
    LineElement,
    Filler,
    Tooltip,
    Legend
  );

function getRandomInt(max:number) {
    return Math.floor(Math.random() * max);
}

const RadarChart: FC<{ query:statisticQueryInfo }> = ({ query }) => {
    const [chartData, setChartData] = useState<ChartData<"radar">>();

    useEffect(() => {
        const fetchData = async () => {
            const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/statistic/${query.linkToQuery}`, {
                headers: {
                    'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
                },
            });

            if(resp.ok){
                const resInfo = await resp.json() as {queryData: statisticQueryDataItem[], nameDatasets:string[]};
    
                const data:{labels:string[], datasets:any} = {
                    labels: resInfo.queryData.map((value) => value.x),
                    datasets: [],
                }
                
                for( let i = 0; i < resInfo.nameDatasets.length; i++)
                {
                    data.datasets.push({
                        label: resInfo.nameDatasets[i] ,
                        data: resInfo.queryData.map(value => value.y[i]),
                        borderColor: `rgb(${getRandomInt(255)}, ${getRandomInt(255)}, ${getRandomInt(255)}, 0.5)`,
                        backgroundColor: `rgb(${getRandomInt(255)}, ${getRandomInt(255)}, ${getRandomInt(255)}, 0.3)`,
                        borderWidth: 1,
                        fill: true,
                    });
                };
    
                setChartData(data);
            }
            else{
                alert(await resp.text());
            }
        }
        fetchData();
    }, [query]);

    const options = {
        plugins: {
            datalabels: {
                color: '#000',
                font: {
                    weight: 'bold' as 'bold'
                },
                align: 'top' as 'top'
              }
        },
    };

    return (
        <>
            {chartData != undefined && <Radar plugins={[ChartDataLabels]} options={options} data={chartData}/> }
        </>    
    );
}

export default RadarChart;
ClientLayout.tsx
import {FC, ReactNode} from "react"
import Sidebar from "./Sidebar";
import { Col, Container, Row } from "react-bootstrap";
import React from "react";

type clientLayoutProps = {
    children: ReactNode,
    categories:Array<categoryItem>,
}

const ClientLayout:FC<clientLayoutProps> = ({children, categories}) => (
        <>
            <Container fluid="xl" className="row pt-2 mx-auto mb-1">
                <Col xs={2} md={3} lg={2} className="g-0 px-1">
                    <Sidebar categories={categories}/> 
                </Col>
                <Col xs={10} md={9} lg={10} className="g-0">
                    {children}
                </Col>
            </Container>
        </>);

export default ClientLayout;
DishStandartLayout.tsx
import React, { FC, ReactNode, useState } from 'react';
import { Card, Col, Row, Carousel, Image } from 'react-bootstrap';
import styles from '@/styles/Home.module.css'
import Link from 'next/link';

const DishStandartLayout: FC<{ dishInfo: dishClientInfo, children: ReactNode }> = ({ dishInfo, children }) => {
    const [index, setIndex] = useState(0);

    const handleSelect = (selectedIndex: number): void => {
        setIndex(selectedIndex);
    };

    return (
        <Card className='mt-1'>
            <Row className='g-0'>
                <Col xs={12} sm={5} md={4} lg={3}>
                    <Carousel activeIndex={index} onSelect={handleSelect}>
                        {dishInfo.images?.slice(0, 3).map((value, i) =>
                            <Carousel.Item key={i}>
                                <Image className="d-block w-100" src={value} alt="First slide" />
                            </Carousel.Item>
                        )}
                    </Carousel>
                </Col>
                <Col xs={12} sm={7} md={8} lg={9}>
                    <Card.Body>
                        <Row className='align-items-center'>
                            <Col xs={9}>
                                <Link href={'/dishes/' + dishInfo.id} className={`${styles.linkWithoutDefaultStyles}`}>
                                    <h3>{dishInfo.name}</h3>
                                </Link>
                            </Col>
                            <Col ><p className='text-start text-lg-center m-0'>Цена: {dishInfo.price}р</p></Col>
                        </Row>
                        <Card.Text>
                            {dishInfo.description}
                        </Card.Text>
                        {children}
                    </Card.Body>
                </Col>
            </Row>
        </Card>
    );
}

export default DishStandartLayout;


Footer.tsx
import Link from "next/link";
import { FC } from "react"
import { Col, Container, NavbarBrand } from "react-bootstrap";
import FooterPanelItem from "../FooterPanelItem";
import Image from "next/image";

const questionsPanel:footerPanelInfo = 
{
    panelName: "Часто задаваемые вопросы",
    panelItems: [
        {
            itemName: "Как получить бонусы?",
            itemHref: "/",
        },
        {
            itemName: "Как связаться с менеджером?",
            itemHref: "/",
        },
        {
            itemName: "Как стать частью вашей команды?",
            itemHref: "/",
        },
        {
            itemName: "Какие доступны способы оплаты?",
            itemHref: "/",
        },
    ]
}
const informationPanel:footerPanelInfo = 
{
    panelName: "Общая информация",
    panelItems: [
        {
            itemName: "История сервиса",
            itemHref: "/",
        },
        {
            itemName: "Действия при возникновении проблем с сайтом",
            itemHref: "/",
        },
        {
            itemName: "Вакансии",
            itemHref: "/",
        },
    ]
}

const Footer: FC = () => {
    return (
        <Container className="row mx-auto">
            <Col md={4} xs={12} className="p-1 h-100">
                {FooterPanelItem(informationPanel)}
            </Col>
            <Col md={4} xs={12} className="p-1">
                {FooterPanelItem(questionsPanel)}
            </Col>
            <Col md={4} xs={12} className="order-md-first d-flex justify-content-center align-items-center p-1">
                <Link href="/">
                    <NavbarBrand>
                        <Image src="/2_logo.svg" alt="logo" width={220} height={80}/>
                    </NavbarBrand>
                </Link>
            </Col>
        </Container>
    );
}

export default Footer;
Header.tsx
import Link from "next/link";
import { FC, MouseEvent } from "react"
import { Button, Col, Container, NavbarBrand } from "react-bootstrap";
import styles from '@/styles/Home.module.css'
import { useRouter } from "next/router";
import Image from "next/image";

interface HeaderProps { 
    isAdmin: boolean, 
    isKitchenWorker: boolean,
    isDeliveryMan: boolean,
    isAuthed: boolean, 
    dropJwtToken: () => void
}

const Header: FC<HeaderProps> = ({isAuthed, dropJwtToken, isAdmin, isKitchenWorker, isDeliveryMan}) => {
    const router = useRouter();

    const logoutClickHandler = async (e:MouseEvent):Promise<void> => {
        e.preventDefault();

        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/auth/logout`, {
            method: "POST",
            credentials: 'include',
            headers: {
                'Authorization': 'Bearer ' + localStorage.getItem("jwtToken"),
            }, 
        });

        if(resp.ok)
        {
            dropJwtToken();
            router.push("/");
        }
        else{
            alert(await resp.text());
        }
        
    }

    const cartButtonVisibility:boolean = !(isAdmin || isKitchenWorker || isDeliveryMan);

    return (
        <Container fluid="xl" className="row pt-2 mx-auto">
            <Col sm={5} md={6} className="d-flex justify-content-center align-items-center">
                <Link href="/">
                    <NavbarBrand>
                        <Image src="/2_logo.svg" alt="logo" width={220} height={80}/>
                    </NavbarBrand>
                </Link>
            </Col>
            <Col sm={7} md={6} className="d-flex justify-content-end align-items-center">
                {cartButtonVisibility &&  <Col xs={isAuthed ? 4 : 6} sm={4} className={`p-1 ${styles.headerButton}`}>
                    <Link href='/cart' className="btn btn-primary w-100">
                        Корзина
                    </Link>
                </Col>}
                { isAuthed ? 
                    <>
                        <Col xs={4} sm={4} className={`p-1 ${styles.headerButton}`}>
                            <Link href='/profile' className="btn btn-primary w-100">
                                Профиль
                            </Link>
                        </Col>
                        <Col xs={4} sm={4} className={`p-1 ${styles.headerButton}`}>
                            <Button className="w-100" onClick={logoutClickHandler}>Выйти</Button>
                        </Col>
                    </>
                    :
                    <Col xs={6} sm={8} className={`p-1 ${styles.headerButton}`}>
                        <Link href='/login' className="btn btn-primary w-100 text-nowrap">
                            Войти/Регистрация
                        </Link>
                    </Col>
                }
            </Col>
        </Container>
    );
}

export default Header;
Layout.tsx
import {FC, ReactNode, useEffect, useState} from "react"
import MainNavbar from "./Navbar";
import Header from "./Header";
import Footer from "./Footer";
import React from "react";
import { AuthContext as AuthContext } from "../contexts/AuthContext";

type layoutProps = {
    children: ReactNode
}

const Layout:FC<layoutProps> = ({children}) =>  {
    const [isAuthed, setIsAuthed] = useState(false);
    const [roles, setRoles] = useState(["User"]);

    const DropJwtToken = () => {
        setRoles(["User"]);
        setIsAuthed(false);

        localStorage.removeItem("jwtToken");
        localStorage.removeItem("jwtTokenValidTo");
    };

    const JwtTokenIsValid = ():boolean => {
        const jwtTokenValidTo: string | null = localStorage.getItem("jwtTokenValidTo");

        if(jwtTokenValidTo == null || new Date(jwtTokenValidTo) < new Date()){
            return false;
        }

        return true;
    };

    const UpdateJwtToken = async () => {
        //Если пользователь авторизован и при этом
        //Если с jwt токеном все ок, то нет смысла его обновлять
        if(JwtTokenIsValid() && isAuthed == true)
            return;

        const resp = await fetch(`${process.env.NEXT_PUBLIC_HOME_API}/auth/refreshAccessToken`, {
            method: "POST",
            credentials: "include"
        });
    
        if(resp.ok){
            const token = await resp.json() as jsonTokenInfo;

            setRoles(token.roleNames);
            setIsAuthed(true);

            localStorage.setItem("jwtToken", token.jwtToken);
            localStorage.setItem("jwtTokenValidTo", token.validTo.toString());
        }
        else{
            DropJwtToken();
        }
    }

    useEffect(() => {
        UpdateJwtToken();
    },[isAuthed]);

    const authContextData = { 
        isAdmin: roles.includes("Admin"), 
        isClient: roles.includes("Client"), 
        isDeliveryMan: roles.includes("DeliveryMan"), 
        isKitchenWorker: roles.includes("KitchenWorker"), 
        isAuth: isAuthed, 
        toggleIsAuthed: () => setIsAuthed(true)
    };

    return (
        <>
            <Header {...authContextData} isAuthed={isAuthed} dropJwtToken={DropJwtToken}/>
            <MainNavbar {...authContextData} />
            <AuthContext.Provider value = {authContextData}>
                {children}
            </AuthContext.Provider>
            <Footer />
        </>
    );
};

export default Layout;
Navbar.tsx
import { Nav, Navbar, NavDropdown, Container, Button, Form } from 'react-bootstrap';
import { ChangeEvent, FC, useState } from "react";
import Link from 'next/link';
import Image from 'next/image';

const HorizontalMenuItems: Array<linkPanelItem> = [
    {
        itemName: "Главная",
        itemHref: "/",
    },
    {
        itemName: "Акции",
        itemHref: "/",
    },
    {
        itemName: "Доставка",
        itemHref: "/",
    },
];

const AdminPanelMenuItems: Array<linkPanelItem> = [
    {
        itemName: "Статистика",
        itemHref: "/admin/statistics",
    },
    {
        itemName: "Блюда",
        itemHref: "/admin/dishes",
    },
    {
        itemName: "Заказы",
        itemHref: "/admin/orders",
    },
    {
        itemName: "Пользователи",
        itemHref: "/admin/users",
    },
];

const KitchenPanelMenuItems: Array<linkPanelItem> = [
    {
        itemName: "Заказы кухни",
        itemHref: "/kitchen/orders",
    },
    {
        itemName: "Сотрудники кухни",
        itemHref: "/kitchen/workers",
    },
];

interface MainNavbarProps { 
    isAdmin: boolean, 
    isKitchenWorker: boolean 
}

const MainNavbar: FC<MainNavbarProps> = ({ isAdmin, isKitchenWorker }) => {
    const [searchValue, setSearchValue] = useState("");

    const changeSearchValue = (e: ChangeEvent<HTMLInputElement>): void => {
        e.preventDefault();
        setSearchValue(e.target.value);
    }

    return (
        <Navbar expand="md" className="upperNavbar">
            <Container>
                <Navbar.Toggle id="navbarToggle" aria-controls="offcanvasNavbar-expand" className="order-1 col-3" style={{color:"#FFF"}}></Navbar.Toggle>
                <Navbar.Collapse id="basic-navbar-nav" className='order-3'>
                    <Nav className="me-auto">
                        {HorizontalMenuItems.map((value, i) =>
                        (<Nav.Item className='mx-auto' key={i}>
                            <Link href={value.itemHref} className='nav-link' style={{color: "#FFF"}}>
                                {value.itemName}
                            </Link>
                        </Nav.Item>)
                        )}
                        {isAdmin &&
                            <NavDropdown className='mx-auto' title="Админ панель" id="nav-dropdown">
                                {AdminPanelMenuItems.map((value, i) => (
                                    <Nav.Item key={i} className='mx-auto'>
                                        <Link href={value.itemHref} className='dropdown-item pt-2 pb-2 nav-link'>
                                            {value.itemName}
                                        </Link>
                                    </Nav.Item>))
                                }
                            </NavDropdown>
                        }
                        {isKitchenWorker &&
                            <NavDropdown className='mx-auto' title="Панель кухни" id="nav-dropdown">
                                {KitchenPanelMenuItems.map((value, i) => (
                                    <Nav.Item key={i} className='mx-auto'>
                                        <Link href={value.itemHref} className='dropdown-item pt-2 pb-2'>
                                            {value.itemName}
                                        </Link>
                                    </Nav.Item>))
                                }
                            </NavDropdown>
                        }
                    </Nav>
                </Navbar.Collapse>
                <Form className="d-flex col-lg-4 col-md-5 col-8 order-md-4 order-2 ">
                    <Form.Control className='w-100' placeholder="Поиск" aria-describedby="basic-addon2" value={searchValue} onChange={changeSearchValue} />
                    <Button variant="outline-secondary" className='ms-1' id="button-addon2">
                        <Link href={searchValue.trim() != "" ? `/search?searchText=${searchValue.toLowerCase().trim()}` : '/'}>
                            <Image src="\loupe.svg" width="20" height="20" alt="Поиск"/>
                        </Link>
                    </Button>
                </Form>
            </Container>
        </Navbar>
    )
};

export default MainNavbar;
Sidebar.tsx
import { Nav, Navbar, Container, Offcanvas } from 'react-bootstrap';
import { FC, useEffect, useState } from "react"
import Link from 'next/link';
import styles from '@/styles/Home.module.css'

const Sidebar: FC<{ categories: Array<categoryItem> }> = ({ categories }) => {

    const [isFixed, setIsFixed] = useState(false);

    useEffect(() => {
      const handleScroll = () => {
        let heightOfHeaderAndNavBar = 32 + 56 + window.innerWidth >= 576 ? 88 : 133

        if (window.scrollY > heightOfHeaderAndNavBar && !isFixed) {
          setIsFixed(true);
        } else if (window.scrollY < heightOfHeaderAndNavBar && isFixed) {
          setIsFixed(false);
        }
      };
      window.addEventListener("scroll", handleScroll);
      window.addEventListener("resize", handleScroll);
      return () => {
        window.removeEventListener("scroll", handleScroll);
        window.removeEventListener("resize", handleScroll);
      };
    }, [isFixed]);

    return (
        <Navbar expand="md" style={{ maxHeight: "100vw", minHeight: "23vw", position: (isFixed?"fixed":"static"), top: "0px"}} className="h-100">
            <Container fluid className='h-100 align-items-start justify-content-end g-0 mx-auto'>
                <Navbar.Toggle aria-controls='offcanvasNavbar' className={`${styles.sidebarToggle} p-0 h-100`}>
                    <div className={`${styles.rotate90deg} align-items-center`}>Категории</div>
                </Navbar.Toggle>
                <Navbar.Offcanvas id='offcanvasNavbar' aria-labelledby='offcanvasNavbarLabel' placement="start">
                    <Offcanvas.Header closeButton>
                        <Offcanvas.Title id='offcanvasNavbarLabel'>
                            Категории
                        </Offcanvas.Title>
                    </Offcanvas.Header>
                    <Offcanvas.Body className='g-0'>
                        <Nav className="flex-column">
                            <Nav.Item className='w-100 d-none d-md-block p-2'>
                                <b>Категории</b>
                            </Nav.Item>
                            {categories?.map((value, i) =>
                            (<Nav.Item key={i} className='w-100 ms-2'>
                                <Link className="nav-link " href={`/categories/${value.linkName}`} >
                                    {value.name}
                                </Link>
                            </Nav.Item>)
                            )}
                        </Nav>
                    </Offcanvas.Body>
                </Navbar.Offcanvas>
            </Container>
        </Navbar>
    )
};

export default Sidebar;
AuthContext.ts
import React from "react"

export const AuthContext = React.createContext<authContextProps>({
    isAdmin: false,
    isClient: false,
    isDeliveryMan: false,
    isKitchenWorker: false,
    isAuth: false,
    toggleIsAuthed: ()=>{},
  });
MapContext.ts
import React from "react";
import * as ol from "ol";

interface mapContextProps {
    map: ol.Map | null,
}

export const MapContext = React.createContext<mapContextProps>({
    map: null
});

AdapterOrders.kt
package com.example.deliverymanapp

import android.content.Context
import android.content.Intent
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.Button
import android.widget.TextView
import android.widget.Toast
import com.example.deliverymanapp.dto.OrderItemDTO

class AdapterOrders (context: Context, private val resource: Int, private var orders:List<OrderItemDTO>) : ArrayAdapter<OrderItemDTO>(context, resource, orders) {
    private var inflater: LayoutInflater = LayoutInflater.from(context)

    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
        val view: View = inflater.inflate(this.resource, parent, false)

        val tvOrderId = view.findViewById<TextView>(R.id.OrderId)
        val tvPrice = view.findViewById<TextView>(R.id.Price)
        val tvWeight = view.findViewById<TextView>(R.id.Weight)
        val tvAddress = view.findViewById<TextView>(R.id.Address)

        tvOrderId.text = "Id: ${orders[position].id}"
        tvPrice.text = "Стоимость: ${orders[position].price} Р"
        tvWeight.text = "Вес: ${orders[position].sumWeight}"
        tvAddress.text = "Адрес: ${orders[position].deliveryAddress}"

        view.setOnClickListener{ v -> run{
            val intent = Intent(context, OrderActivity::class.java)
            intent.putExtra("orderId", orders[position].id);
            intent.putExtra("canChangeState", orders[position].canDelManChangestate);
            context.startActivity(intent);
        }}


        return view
    }
}
MainActivity.kt
package com.example.deliverymanapp

import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.os.Bundle
import android.view.View
import android.widget.EditText
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import com.android.volley.Request
import com.android.volley.RequestQueue
import com.android.volley.toolbox.Volley
import com.example.deliverymanapp.dto.JwtTokenInfoDTO
import com.google.gson.Gson
import org.json.JSONException
import org.json.JSONObject
import java.net.*

class MainActivity : AppCompatActivity() {
    private var mRequestQueue: RequestQueue? = null
    private var sharedPreferences :SharedPreferences? = null
    private var cookieManager: CookieManager? = null
    private var gson: Gson = Gson()
    private val nameUserId:String = "X-UserId"
    private val nameRefreshToken:String = "X-Refresh-Token"
    private var url:String = ""
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        cookieManager = CookieManager()

        CookieHandler.setDefault(cookieManager)

        url = resources.getString(R.string.url)

        mRequestQueue = Volley.newRequestQueue(this)
        sharedPreferences = getSharedPreferences("my_preference", Context.MODE_PRIVATE)

        fetchRefreshToken()

    }

    private fun saveCookieDataToSharedPreferences(responseData : JSONObject?){

        var userId = responseData?.getString("Set-Cookie")
        if (userId != null) {
            if(userId.contains("X-UserId"))
            {
                val start = userId.indexOf('=')
                val end = userId.indexOf(';')
                userId = userId.substring(start+1,end).trim('\"')
            }
        }

        var refreshToken = responseData?.getString("Set-Cookie1")
        if (refreshToken != null) {
            if(refreshToken.contains("X-Refresh-Token"))
            {
                val start = refreshToken.indexOf('=')
                val end = refreshToken.indexOf(';')
                refreshToken = refreshToken.substring(start+1,end)
            }
        }

        val editor = sharedPreferences?.edit()
        editor?.putString(nameUserId, userId)
        editor?.putString(nameRefreshToken, refreshToken)
        editor?.apply()
    }

    private fun fetchRefreshToken() {
        val userId = sharedPreferences?.getString(nameUserId, "")
        val refreshToken = sharedPreferences?.getString(nameRefreshToken, "")
        if(userId == null || refreshToken == null || userId == "" || refreshToken == ""){
            return
        }

        val userIdCookie:HttpCookie = HttpCookie(nameUserId, userId)
        userIdCookie.version = 0
        val refreshTokenCookie:HttpCookie = HttpCookie(nameRefreshToken, refreshToken)
        refreshTokenCookie.version = 0

        cookieManager?.cookieStore?.add(URI.create(url), userIdCookie)
        cookieManager?.cookieStore?.add(URI.create(url), refreshTokenCookie)

        val req = MetaRequest(
            Request.Method.POST, "${url}/auth/refreshAccessToken", null,
            { response : JSONObject? ->
                try {
                    val body = response?.getString("body")

                    val jwtToken = gson.fromJson(body, JwtTokenInfoDTO::class.java)

                    val editor = sharedPreferences?.edit()
                    editor?.putString("jwtToken", jwtToken.jwtToken)
                    editor?.apply()

                    runOnUiThread {
                        val listIntent = Intent(this@MainActivity, OrderListActivity::class.java)
                        startActivity(listIntent)
                    }
                } catch (e: JSONException) {
                    e.printStackTrace()
                }
            },
            {
                error -> run {
                    Toast.makeText(this@MainActivity, "Bad request", Toast.LENGTH_SHORT).show()
                }
            }
        )

        /* Add your Requests to the RequestQueue to execute */
        mRequestQueue!!.add(req)
    }

    private fun fetchLogin(login:String, password: String) {

        cookieManager?.cookieStore?.removeAll()
        val jsonBody = JSONObject("{\"login\":\"${login}\", \"password\":\"${password}\"}")

        // Pass second argument as "null" for GET requests
        val req = MetaRequest(
            Request.Method.POST, "${url}/auth/login", jsonBody,
            { response : JSONObject? ->
                try {
                    saveCookieDataToSharedPreferences(response)
                    fetchRefreshToken()
                } catch (e: JSONException) {
                    e.printStackTrace()
                }
            },
            {
                error -> run {
                    Toast.makeText(this@MainActivity, "Bad request", Toast.LENGTH_SHORT).show()
                }
        })

        /* Add your Requests to the RequestQueue to execute */
        mRequestQueue!!.add(req)
    }

    fun loginClick(view: View) {
        val loginValue : String = findViewById<EditText>(R.id.LoginEditText).text.toString()
        val passwordValue : String = findViewById<EditText>(R.id.PasswordEditText).text.toString()
        fetchLogin(loginValue, passwordValue)
    }

//    fun logoutClick(view: View) {
//        cookieManager?.cookieStore?.removeAll()
//
//        val editor = sharedPreferences?.edit()
//        editor?.remove(nameUserId)
//        editor?.remove(nameRefreshToken)
//        editor?.apply()
//    }
}
MetaRequest.kt
package com.example.deliverymanapp

import com.android.volley.NetworkResponse
import com.android.volley.ParseError
import com.android.volley.Response
import com.android.volley.toolbox.HttpHeaderParser
import com.android.volley.toolbox.JsonObjectRequest
import org.json.JSONException
import org.json.JSONObject
import java.io.UnsupportedEncodingException


class MetaRequest : JsonObjectRequest {
    constructor(
        method: Int,
        url: String?,
        jsonRequest: JSONObject?,
        listener: Response.Listener<JSONObject?>?,
        errorListener: Response.ErrorListener?
    ) : super(method, url, jsonRequest, listener, errorListener) {
    }

    constructor(
        url: String?,
        jsonRequest: JSONObject?,
        listener: Response.Listener<JSONObject?>?,
        errorListener: Response.ErrorListener?
    ) : super(url, jsonRequest, listener, errorListener) {
    }

    override fun parseNetworkResponse(response: NetworkResponse): Response<JSONObject> {
        return try {
            val jsonString = String(response.data)
            val jsonResponse = JSONObject()

            response.allHeaders?.forEach {
                var nameEl:String = it.name
                if(jsonResponse.has(it.name))
                    nameEl += "1"
                jsonResponse.put(nameEl, it.value)
            }
            if(jsonString != "")
                jsonResponse.put("body", jsonString)

            Response.success(
                jsonResponse,
                HttpHeaderParser.parseCacheHeaders(response)
            )
        } catch (e: UnsupportedEncodingException) {
            Response.error(ParseError(e))
        } catch (je: JSONException) {
            Response.error(ParseError(je))
        }
    }
}
OrderActivity.kt
package com.example.deliverymanapp

import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.os.Bundle
import android.view.View
import android.widget.*
import androidx.appcompat.app.AppCompatActivity
import com.android.volley.Request
import com.android.volley.RequestQueue
import com.android.volley.toolbox.JsonObjectRequest
import com.android.volley.toolbox.StringRequest
import com.android.volley.toolbox.Volley
import com.example.deliverymanapp.dto.OrderInfoDTO
import com.example.deliverymanapp.dto.OrderStateItemDTO
import com.example.deliverymanapp.dto.OrdersDTO
import com.google.gson.Gson
import org.json.JSONException
import org.json.JSONObject

class OrderActivity : AppCompatActivity() {
    private var orderId : String = ""
    private var mRequestQueue: RequestQueue? = null
    private var sharedPreferences : SharedPreferences? = null
    private val gson: Gson = Gson()
    private var url:String = ""
    private var order : OrderInfoDTO?  = null
    private var delManCanChangeStateOfOrder : Boolean?  = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_order)

        mRequestQueue = Volley.newRequestQueue(this)
        sharedPreferences = getSharedPreferences("my_preference", Context.MODE_PRIVATE)
        url = resources.getString(R.string.url)

        val arguments = intent.extras

        if (arguments != null) {
            orderId = arguments["orderId"] as String
            delManCanChangeStateOfOrder = arguments["canChangeState"] as Boolean

            val buttonChangeState = findViewById<Button>(R.id.moveOrderToNextStageButton)
            if(delManCanChangeStateOfOrder == false)
                buttonChangeState.visibility = View.GONE

            LoadOrderDataToList()
        }
    }

    private fun LoadOrderDataToList(){
        val req = object : StringRequest(
            Request.Method.GET, "${url}/Order/getOrder/${orderId}",
            { response ->
                try {
                    order = gson.fromJson(response, OrderInfoDTO::class.java)

                    val orderView = findViewById<View>(R.id.orderInfo)
                    val tvOrderId = orderView.findViewById<TextView>(R.id.OrderId)
                    val tvPrice = orderView.findViewById<TextView>(R.id.Price)
                    val tvWeight = orderView.findViewById<TextView>(R.id.Weight)
                    val tvAddress = orderView.findViewById<TextView>(R.id.Address)

                    tvOrderId.text = "Id: ${order?.order?.id}"
                    tvPrice.text = "Стоимость: ${order?.order?.price} Р"
                    tvWeight.text = "Вес: ${order?.order?.sumWeight}"
                    tvAddress.text = "Адрес: ${order?.order?.deliveryAddress}"

                    val dishes = order?.orderedDishes?.map{it.dishInfo.name + " " + it.count + " шт"}?.toTypedArray() as Array<String>

                    val arrayAdapter = ArrayAdapter<String>(this,android.R.layout.simple_list_item_1, dishes)
                    val listView = findViewById<ListView>(R.id.orderDishesList)

                    listView.adapter = arrayAdapter

                } catch (e: JSONException) {
                    e.printStackTrace()
                }
            },
            { error ->
                run {
                    Toast.makeText(this, "Bad request", Toast.LENGTH_SHORT).show()
                }
            })
        {
            override fun getHeaders(): MutableMap<String, String> {
                val headers = HashMap<String, String>()
                headers["Authorization"] = "Bearer " + sharedPreferences?.getString("jwtToken", "")
                return headers
            }
        }

        /* Add your Requests to the RequestQueue to execute */
        mRequestQueue!!.add(req)
    }

    fun moveOrderToNextStageClick(view: View) {
        val jsonBody = JSONObject("{\"orderId\":\"${orderId}\"}")

        val req = object : JsonObjectRequest(
            Request.Method.POST, "${url}/Order/moveToNextStage", jsonBody,
            { response ->
                try {
                    val intent = Intent(this, OrderListActivity::class.java)
                    this.startActivity(intent);

                } catch (e: JSONException) {
                    e.printStackTrace()
                }
            },
            { error ->
                run {
                    Toast.makeText(this, "Bad request", Toast.LENGTH_SHORT).show()
                }
            })
        {
            override fun getHeaders(): MutableMap<String, String> {
                val headers = HashMap<String, String>()
                headers["Authorization"] = "Bearer " + sharedPreferences?.getString("jwtToken", "")
                return headers
            }
        }

        /* Add your Requests to the RequestQueue to execute */
        mRequestQueue!!.add(req)
    }
}
OrderListActivity.kt
package com.example.deliverymanapp

import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.os.Bundle
import android.text.Editable
import android.view.View
import android.widget.*
import androidx.appcompat.app.AppCompatActivity
import com.android.volley.Request
import com.android.volley.RequestQueue
import com.android.volley.toolbox.StringRequest
import com.android.volley.toolbox.Volley
import com.example.deliverymanapp.dto.OrderItemDTO
import com.example.deliverymanapp.dto.OrderStateItemDTO
import com.example.deliverymanapp.dto.OrdersDTO
import com.google.android.gms.location.*
import com.google.gson.Gson
import org.json.JSONException
import java.net.CookieHandler
import java.net.CookieManager


class OrderListActivity : AppCompatActivity() {
    private var mRequestQueue: RequestQueue? = null
    private var sharedPreferences :SharedPreferences? = null
    private var states = arrayOf<OrderStateItemDTO>()
    private val gson: Gson = Gson()
    private var url:String = ""
    private var orders = mutableListOf<OrderItemDTO>()
    private var page = 0
    private var lastPage = true
    private var selectedState: OrderStateItemDTO? = null
    private var statesAdapter:ArrayAdapter<String>? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_order_list)

        mRequestQueue = Volley.newRequestQueue(this)
        sharedPreferences = getSharedPreferences("my_preference", Context.MODE_PRIVATE)
        url = resources.getString(R.string.url)

        fetchListOfStates()
    }

    private fun fetchListOfStates() {

        val req = StringRequest(
            Request.Method.GET, "${url}/main/getOrderStates",
            { response ->
                try {
                    states = gson.fromJson(response, Array<OrderStateItemDTO>::class.java)

                    statesAdapter = ArrayAdapter(this, R.layout.dropdown_item, states.map { it.nameOfState })
                    val headerView = findViewById<View>(R.id.header)

                    val autocompleteTV = headerView.findViewById<AutoCompleteTextView>(R.id.autoCompleteTextView)

                    autocompleteTV.setAdapter(statesAdapter)

                } catch (e: JSONException) {
                    e.printStackTrace()
                }
            },
            { error ->
                run {
                    Toast.makeText(this@OrderListActivity, "Bad request", Toast.LENGTH_SHORT).show()
                }
            })

        /* Add your Requests to the RequestQueue to execute */
        mRequestQueue!!.add(req)
    }

    fun selectOrderState(view: View) {
        val textView:TextView = view as TextView
        selectedState = states.find { it.nameOfState == textView.text }

        if(selectedState != null){
            orders.clear()
            loadAndAddOrdersToList()
        }

        val headerView = findViewById<View>(R.id.header)

        val autocompleteTV = headerView.findViewById<AutoCompleteTextView>(R.id.autoCompleteTextView)
        autocompleteTV.clearFocus()

//        autocompleteTV.text = Editable.Factory.getInstance().newEditable(selectedState?.nameOfState)
//        autocompleteTV.setAdapter(statesAdapter)
    }

    private fun loadAndAddOrdersToList(){
        val req = object : StringRequest(
            Request.Method.GET, "${url}/DeliveryMan/getOrders?page=${page}&numberOfState=${selectedState?.numberOfStage}",
            { response ->
                try {
                    val ordersInput = gson.fromJson(response, OrdersDTO::class.java)
                    orders.addAll(ordersInput.orders)
                    lastPage = ordersInput.pageEnded

                    if(selectedState != null) {
                        val res:Boolean = (selectedState!!.numberOfStage == 4 || selectedState!!.numberOfStage == 8)
                        orders.forEach{it.canDelManChangestate = res}
                    }

                    val showMoreButton = findViewById<Button>(R.id.showMoreButton)
                    if(lastPage){
                        showMoreButton.visibility = View.INVISIBLE
                    }
                    else{
                        showMoreButton.visibility = View.VISIBLE
                    }

                    val arrayAdapter = AdapterOrders(this, R.layout.order_item, orders.toList())
                    val listView = findViewById<ListView>(R.id.orderList)

                    listView.adapter = arrayAdapter

                } catch (e: JSONException) {
                    e.printStackTrace()
                }
            },
            { error ->
                run {
                    Toast.makeText(this@OrderListActivity, "Bad request", Toast.LENGTH_SHORT).show()
                }
            })
        {
            override fun getHeaders(): MutableMap<String, String> {
                val headers = HashMap<String, String>()
                headers["Authorization"] = "Bearer " + sharedPreferences?.getString("jwtToken", "")
                return headers
            }
        }

        /* Add your Requests to the RequestQueue to execute */
        mRequestQueue!!.add(req)
    }

    fun showMoreOrdersClick(view: View) {
        loadAndAddOrdersToList()
    }

    fun logoutClick(view: View) {
        val cookieManager = CookieManager()
        CookieHandler.setDefault(cookieManager)

        cookieManager.cookieStore?.removeAll()

        val sharedPreferences = getSharedPreferences("my_preference", Context.MODE_PRIVATE)
        val editor = sharedPreferences?.edit()
        editor?.remove("X-UserId")
        editor?.remove("X-Refresh-Token")
        editor?.apply()

        val intent = Intent(this, MainActivity::class.java)
        this.startActivity(intent);
    }
}


DishInfoDTO.kt
package com.example.deliverymanapp.dto

class DishInfoDTO(val name: String,
                  val description: String,
                  val price : Int,
                  val id: String,) {
}
JwtTokenInfoDTO.kt
package com.example.deliverymanapp.dto

class JwtTokenInfoDTO(val jwtToken:String) {
}
OrderedDishItemDTO.kt
package com.example.deliverymanapp.dto

class OrderedDishItemDTO(val count:Int,
                         val orderId:String,
                         val dishInfo:DishInfoDTO,) {
}
OrderInfoDTO.kt
package com.example.deliverymanapp.dto

class OrderInfoDTO(val order: OrderItemDTO, val orderedDishes: Array<OrderedDishItemDTO>) {
}
OrderItemDTO.kt
package com.example.deliverymanapp.dto

class OrderItemDTO(val id: String,
                   val price: Int,
                   val sumWeight: Int,
                   val deliveryAddress: String,
                   var canDelManChangestate: Boolean?) {
}
OrdersDTO.kt
package com.example.deliverymanapp.dto

class OrdersDTO(val orders: Array<OrderItemDTO>,
                val pageEnded: Boolean) {
}
OrderStateItemDTO.kt
package com.example.deliverymanapp.dto

class OrderStateItemDTO(val orderStateId: String,
                        val numberOfStage: Int,
                        val nameOfState: String,) {
}

activity_main.xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <LinearLayout
        android:id="@+id/linearLayout"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginHorizontal="10dp"
        android:gravity="center"
        android:orientation="vertical"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Введите логин"
            android:textSize="18sp" />

        <EditText
            android:id="@+id/LoginEditText"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="10dp"
            android:hint="Ваш логин"
            android:text="deliveryMan@deliveryMan"
            android:inputType="text"
            android:minHeight="48dp"
            android:textSize="18sp" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="10dp"
            android:text="Введите пароль"
            android:textSize="18sp" />

        <EditText
            android:id="@+id/PasswordEditText"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="10dp"
            android:hint="Ваш пароль"
            android:text="deliveryMan"
            android:inputType="textPassword"
            android:minHeight="48dp"
            android:textSize="18sp" />

        <Button
            android:id="@+id/Login"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="10dp"
            android:text="Войти"
            android:onClick="loginClick"
            android:textSize="18sp" />
    </LinearLayout>
</androidx.constraintlayout.widget.ConstraintLayout>
activity_order.xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_margin="10dp"
    tools:context=".OrderActivity">

    <include
        android:id="@+id/orderInfo"
        layout="@layout/order_item"/>

    <Button
        android:id="@+id/moveOrderToNextStageButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="14sp"
        android:text="Перевести заказ в следующую стадию"
        android:visibility="visible"
        android:onClick="moveOrderToNextStageClick"
        app:layout_constraintTop_toBottomOf="@id/orderInfo"/>

    <TextView
        android:text="Заказ содержит следующие блюда"
        android:id="@+id/textViewDishes"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="18sp"
        android:layout_marginTop="5dp"
        app:layout_constraintTop_toBottomOf="@id/moveOrderToNextStageButton"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"/>

    <ListView
        android:id="@+id/orderDishesList"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        app:layout_constraintTop_toBottomOf="@id/textViewDishes"
        android:scrollbars="vertical"/>

</androidx.constraintlayout.widget.ConstraintLayout>
activity_order_list.xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".OrderListActivity">

    <include
        android:id="@+id/header"
        layout="@layout/header" />

    <androidx.constraintlayout.widget.ConstraintLayout
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_margin="10dp"
        app:layout_constraintTop_toBottomOf="@id/header"
        app:layout_constraintBottom_toTopOf="@id/showMoreButton"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent">
        <ListView
            android:id="@+id/orderList"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:scrollbars="vertical"/>
    </androidx.constraintlayout.widget.ConstraintLayout>

    <Button
        android:id="@+id/showMoreButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="18sp"
        android:text="Показать больше"
        android:onClick="showMoreOrdersClick"
        android:visibility="invisible"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"/>

</androidx.constraintlayout.widget.ConstraintLayout>
dropdown_item.xml
<?xml version="1.0" encoding="utf-8"?>
<TextView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/textView"
    android:layout_width="match_parent"
    android:textColor="@color/black"
    android:textStyle="bold"
    android:padding="14dp"
    android:layout_height="wrap_content"
    android:onClick="selectOrderState"/>
header.xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_marginVertical="10dp"
    android:layout_marginHorizontal="15dp">

    <Button
        android:id="@+id/Login"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:text="Выйти"
        android:textSize="18sp"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toLeftOf="@id/textInputLayout"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintWidth_default="percent"
        app:layout_constraintWidth_percent="0.35"
        android:onClick="logoutClick"/>

    <com.google.android.material.textfield.TextInputLayout
        android:id="@+id/textInputLayout"
        style="@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox.ExposedDropdownMenu"
        android:layout_width="0dp"
        android:layout_height="60dp"
        android:minWidth="250dp"
        app:layout_constraintWidth_default="percent"
        app:layout_constraintWidth_percent="0.65"
        app:layout_constraintLeft_toRightOf="@id/Login"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent">

        <!-- Inside text input layout add
              an auto complete text view
                and make its input type to none-->
        <AutoCompleteTextView
            android:id="@+id/autoCompleteTextView"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_marginStart="10dp"
            android:layout_weight="1"
            android:inputType="none"
            android:text="Состояние заказа" />

    </com.google.android.material.textfield.TextInputLayout>

</androidx.constraintlayout.widget.ConstraintLayout>
order_item.xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    style="@style/Widget.AppCompat.Button.Borderless"
    android:layout_marginBottom="10dp">

    <TextView
        android:id="@+id/OrderId"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="18sp"
        app:layout_constraintTop_toTopOf="parent"/>

    <TextView
        android:id="@+id/Weight"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:textSize="18sp"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintTop_toBottomOf="@id/OrderId"
        app:layout_constraintWidth_default="percent"
        app:layout_constraintWidth_percent="0.5" />

    <TextView
        android:id="@+id/Price"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:textSize="18sp"
        app:layout_constraintLeft_toRightOf="@id/Weight"
        app:layout_constraintTop_toBottomOf="@id/OrderId"
        app:layout_constraintWidth_default="percent"
        app:layout_constraintWidth_percent="0.5" />

    <TextView
        android:id="@+id/Address"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="18sp"
        app:layout_constraintTop_toBottomOf="@id/Price"/>

</androidx.constraintlayout.widget.ConstraintLayout>
